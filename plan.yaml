name: merge-review-drawer
summary: >
  Complete the merge review approval gate UI by adding unit tests for the server action
  and Storybook stories for visual documentation. The feature is 95% implemented with all
  core components, server actions, and integration already in place. This plan focuses on
  closing the remaining test coverage and story documentation gaps to meet the mandatory
  TDD requirements and comprehensive visual regression testing standards established in
  the codebase.

relatedFeatures: []

technologies:
  - React 19 (Next.js 16+ App Router)
  - TypeScript 5.3
  - shadcn/ui (Radix primitives + Tailwind CSS v4)
  - React Flow (@xyflow/react v12)
  - Storybook 8.6
  - Vitest 4.0 + Testing Library
  - Playwright (E2E)
  - Lucide React icons
  - Sonner (toast notifications)
  - tsyringe (DI container)

relatedLinks: []

phases:
  - id: phase-1
    name: 'Server Action Testing Foundation'
    description: 'Implement comprehensive unit tests for get-merge-review-data server action following TDD principles. This phase establishes the test foundation for all conditional branches including input validation, error handling, data mapping, and graceful degradation paths.'
    parallel: false

  - id: phase-2
    name: 'Storybook Documentation Enhancement'
    description: 'Add missing story variants to feature-node and control-center stories for merge review visualization. This phase ensures complete visual documentation for the emerald badge state and multi-feature integration scenarios, maintaining consistency with existing comprehensive coverage standards.'
    parallel: false

  - id: phase-3
    name: 'Integration Validation & Quality Assurance'
    description: 'Run full test suite, perform visual regression testing in Storybook, execute E2E smoke tests, and validate lint/format compliance. This phase verifies that the new feature integrates correctly with existing systems and meets all quality gates before shipping.'
    parallel: false

filesToCreate:
  - tests/unit/presentation/web/app/actions/get-merge-review-data.test.ts

filesToModify:
  - src/presentation/web/components/common/feature-node/feature-node.stories.tsx
  - src/presentation/web/components/features/control-center/control-center.stories.tsx

openQuestions: []

content: |
  ## Architecture Overview

  The merge review drawer feature completes the three-drawer approval gate system (PRD Review →
  Tech Decisions Review → Merge Review) following Clean Architecture principles and established
  component patterns. The implementation fits into the existing architecture as follows:

  **Presentation Layer (Web UI):**
  - **Feature Node Visualization**: Emerald badge with GitMerge icon added to feature-node.tsx
    through getBadgeIcon(), getActionRequiredBadgeClasses(), and getBadgeText() functions for
    lifecycle='review' and state='action-required' combinations (ALREADY IMPLEMENTED).

  - **Merge Review Components**: 5-file pattern at components/common/merge-review/ mirroring
    prd-questionnaire/ and tech-decisions-review/ structure. Includes merge-review-config.ts
    (7 TypeScript interfaces), merge-review.tsx (content component with PR metadata, diff summary,
    CI status, phases, branch direction, DrawerActionBar), merge-review-drawer.tsx (ReviewDrawerShell
    wrapper with loading state), merge-review.stories.tsx (11 comprehensive story variants), and
    index.ts barrel export (ALREADY IMPLEMENTED).

  - **Control Center Integration**: Inline drawer management following established pattern with
    showMergeReviewDrawer flag, mergeReviewData state, useEffect with cancellation for data loading,
    approve/reject handlers calling shared approveFeature()/rejectFeature() actions, conditional
    rendering, and FeatureDrawer suppression (ALREADY IMPLEMENTED).

  - **Server Actions**: get-merge-review-data.ts follows the server action pattern with 'use server'
    directive, input validation via trim(), DI container resolution via resolve<T>('Token'),
    graceful degradation with nested try/catch for plan phases and diff summary, and discriminated
    union return type (ALREADY IMPLEMENTED).

  **Application Layer (Use Cases):**
  - No changes required. ApproveAgentRunUseCase and RejectAgentRunUseCase already handle all
    approval gates generically. GetPlanArtifactUseCase loads plan.yaml phases for display
    (best-effort, non-blocking).

  **Domain Layer:**
  - No changes required. Feature entity with pr field (PullRequest type), PrStatus/CiStatus enums,
    and SdlcLifecycle enum are already defined in TypeSpec-generated output.ts. The merge.node.ts
    LangGraph node populates Feature.pr before the interrupt.

  **Infrastructure Layer:**
  - No changes required. IFeatureRepository.findById() loads Feature with populated pr field.
    IGitPrService.getPrDiffSummary() computes diff stats from git worktree. merge.node.ts agent
    node handles interrupt logic.

  **Reused Shared Components (Zero Modifications):**
  - ReviewDrawerShell (143 lines): Drawer container with header, delete button, feature actions menu
  - DrawerActionBar (65 lines): Approve/reject footer with inline revision input and feedback dialog
  - CiStatusBadge: Color-coded status badge for Success/Pending/Failure states
  - DrawerRevisionInput: Inline text input with send button for quick rejection
  - RejectFeedbackDialog: AlertDialog with textarea for detailed rejection feedback
  - useFeatureActions hook (139 lines): IDE/shell/folder action handlers

  **Data Flow:**
  ```
  User clicks feature node (lifecycle='review', state='action-required')
    ↓
  Control center derives showMergeReviewDrawer = true
    ↓
  useEffect calls getMergeReviewData(featureId) server action
    ↓
  Server action resolves IFeatureRepository, loads Feature.pr
    ↓
  Server action resolves GetPlanArtifactUseCase (best-effort, nested try/catch)
    ↓
  Server action resolves IGitPrService, calls getPrDiffSummary(worktreePath, 'main') if available
    ↓
  Returns MergeReviewData { pr, diffSummary?, phases?, branch, warning? }
    ↓
  MergeReviewDrawer renders with ReviewDrawerShell + MergeReview content
    ↓
  User clicks approve → approveFeature() → ApproveAgentRunUseCase resumes LangGraph agent
    OR
  User clicks reject → rejectFeature(feedback) → RejectAgentRunUseCase resumes with feedback
  ```

  ## Key Design Decisions

  ### 1. Server Action Unit Testing Strategy (TDD with Comprehensive Coverage)

  **Decision:** Write unit tests first (RED → GREEN → REFACTOR) for the get-merge-review-data.ts
  server action covering all 7+ conditional branches: input validation (empty/whitespace featureId),
  feature not found error, successful data mapping (PR metadata, branch construction, phases, diff),
  plan loading failure (graceful degradation), diff summary failure (graceful fallback), missing PR
  scenario, and missing worktree scenario.

  **Rationale:** CLAUDE.md mandates TDD for all implementation work: "MANDATORY — TDD: Write failing
  tests FIRST (RED → GREEN → REFACTOR). Every plan phase must define explicit TDD cycles." The
  server action has multiple conditional branches requiring isolated testing. Unit tests provide
  fast feedback (<100ms), pinpoint failure messages for specific branches, and serve as executable
  documentation of expected behavior. This aligns with existing test patterns in approve-feature.test.ts
  and reject-feature.test.ts which both use vi.mock('@/lib/server-container') with token-based mocks,
  beforeEach cleanup, and describe blocks for validation/errors/success paths.

  **Alternatives Considered:**
  - Integration tests only: Rejected because it violates the TDD mandate, provides slower feedback,
    and less granular failure diagnosis
  - Manual Storybook testing: Rejected because it provides zero automated regression coverage for
    server-side logic

  **Implementation Pattern:**
  ```typescript
  // Test structure from research findings:
  vi.mock('@/lib/server-container')
  beforeEach(() => { vi.clearAllMocks() })

  describe('Input Validation', () => {
    test('returns error for empty featureId', ...)
    test('returns error for whitespace-only featureId', ...)
  })

  describe('Error Handling', () => {
    test('returns error when feature not found', ...)
    test('handles DI container not initialized', ...)
  })

  describe('Data Mapping', () => {
    test('extracts PR metadata from Feature.pr', ...)
    test('constructs branch info from feature.branch', ...)
  })

  describe('Graceful Degradation', () => {
    test('continues when plan loading fails', ...)
    test('continues when worktreePath is undefined', ...)
    test('continues when getPrDiffSummary throws', ...)
  })
  ```

  ### 2. Storybook Story Coverage (Comprehensive Visual Documentation)

  **Decision:** Add story variants to feature-node.stories.tsx (MergeReviewActionRequired showing
  emerald badge + GitMerge icon) and control-center.stories.tsx (merge review nodes in multi-feature
  variants like MultipleFeatures, FullWorkflowStates). Total estimated ~45 lines across both files.

  **Rationale:** The research findings show merge-review.stories.tsx already has 11 comprehensive
  story variants covering all data states (complete PR + diff + phases + CI, missing diff, missing
  phases, missing CI, all CI status variants). However, feature-node and control-center stories lack
  merge review visualization examples. Comprehensive story coverage serves dual purposes: (1) visual
  regression testing to catch styling/rendering regressions, and (2) living documentation for
  designers and QA to understand all possible states. The codebase standard is thorough coverage:
  prd-questionnaire.stories.tsx has 9 variants, tech-decisions-review.stories.tsx has 8 variants.

  **Alternatives Considered:**
  - Default state only: Rejected because edge cases (CI status variants) affect user approval
    decisions and need visual verification
  - Skip control center integration stories: Rejected because the multi-feature workflow stories
    document how different lifecycle phases appear together in the canvas

  **Story Variants to Add:**
  ```typescript
  // feature-node.stories.tsx (~15 lines)
  export const MergeReviewActionRequired: Story = {
    args: {
      data: {
        id: 'feature-1',
        name: 'User Authentication',
        lifecycle: 'review' as const,
        state: 'action-required' as const,
        // ... other required fields
      }
    }
  }

  // control-center.stories.tsx (~30 lines across 3 variants)
  // Add merge review node to MultipleFeatures, FullWorkflowStates, etc.
  ```

  ### 3. Phase Ordering and Parallelization

  **Decision:** Execute phases sequentially (parallel: false for all phases) with clear dependencies:
  Phase 1 (Server Action Tests) → Phase 2 (Storybook Stories) → Phase 3 (Integration Validation).

  **Rationale:** Phases 1 and 2 are independent and could be parallelized, but the sequential approach
  maintains the established TDD workflow (tests first, then documentation, then validation). Phase 3
  must run after Phases 1 and 2 complete because it validates the full system including both unit
  tests and stories. Sequential execution also aligns with the codebase convention where the feature
  is already implemented and we're filling gaps methodically.

  **Task-Level Parallelism:** While phases are sequential, individual tasks within Phase 1 (different
  test suites for validation/errors/success paths) can be developed in parallel via multiple test
  cases within the same file, leveraging Vitest's concurrent test execution.

  ### 4. Risk Mitigation Through Graceful Degradation

  **Decision:** The implemented server action uses three-tier error handling: outer try/catch for
  unexpected failures, nested try/catch for plan loading (best-effort), and nested try/catch for
  diff summary (graceful fallback). Tests must verify each tier independently.

  **Rationale:** The graceful degradation strategy ensures the merge review drawer remains functional
  even when supplementary data (plan phases, diff summary) is unavailable. PR metadata from Feature.pr
  is always available since it's persisted before the merge interrupt. CI status provides essential
  approval context. Diff stats and plan phases are "nice to have" but not blocking. This architecture
  decision must be verified through unit tests that confirm:
  1. Plan loading failure → phases undefined, no overall error
  2. Worktree unavailable → diffSummary undefined, warning message, approve still enabled
  3. Both failures → drawer renders with PR + branch + warning, approve still works

  ## Implementation Strategy

  ### High-Level Approach

  The implementation follows a **complete-and-polish** strategy rather than build-from-scratch,
  since 95% of the feature is already implemented. The plan focuses on:

  1. **Test Coverage Closure (Phase 1)**: Close the critical gap in server action test coverage to
     meet mandatory TDD requirements. This is the highest priority since tests are missing for a
     production server action.

  2. **Documentation Enhancement (Phase 2)**: Add missing Storybook stories for complete visual
     documentation. Feature node and control center stories need merge review variants to match
     the comprehensive coverage standards already achieved in the merge review drawer stories.

  3. **Quality Validation (Phase 3)**: Run the full validation suite (unit tests, visual regression,
     E2E smoke tests, lint/format) to verify integration and ensure no regressions.

  ### Phase Ordering Rationale

  **Phase 1 First (Server Action Tests):**
  - MANDATORY per CLAUDE.md TDD requirement
  - Server action is production code handling DI resolution, data fetching, and error handling
  - Tests provide fast feedback loop for validating complex conditional logic
  - ~150 lines of tests for ~64 lines of production code indicates thorough branch coverage
  - Unblocks confident deployment since all error paths are verified

  **Phase 2 Second (Storybook Stories):**
  - Builds on stable, tested foundation from Phase 1
  - Stories document visual states but don't affect runtime behavior
  - Lower risk than untested server logic
  - Maintains consistency with existing comprehensive story coverage standards
  - ~45 lines across 2 files is low-risk, high-value documentation work

  **Phase 3 Last (Integration Validation):**
  - Requires both tests and stories to be complete for full validation
  - Full test suite must pass (includes new server action tests from Phase 1)
  - Visual regression in Storybook requires stories from Phase 2
  - E2E smoke test validates the complete workflow end-to-end
  - Lint/format check ensures code quality compliance

  ### Test-First Development Workflow

  Each task in Phase 1 follows strict RED → GREEN → REFACTOR cycle:

  **RED (Failing Test):**
  - Write test that asserts specific behavior (e.g., "returns error when featureId is empty")
  - Run test, verify it fails with expected message
  - Confirms test is actually testing the right thing

  **GREEN (Minimal Implementation):**
  - Since get-merge-review-data.ts is already implemented, this step verifies the production code
    passes the test
  - If test fails unexpectedly, fix the production code or the test (whichever has the bug)
  - Get to green as quickly as possible

  **REFACTOR (Cleanup):**
  - Improve test readability (extract helper functions like makeDefaultData())
  - Remove duplication between test cases
  - Add descriptive comments for complex assertions
  - Ensure test is maintainable and serves as clear documentation

  ## Risk Mitigation

  | Risk | Mitigation |
  | ---- | ---------- |
  | **Server action tests reveal bugs in production code** | Each test task is scoped to a specific behavior (validation, error handling, data mapping) allowing isolated debugging. The production code is already implemented and visually tested in Storybook, so major logic bugs are unlikely. Minor fixes can be made during the GREEN step without derailing the plan. |
  | **Storybook stories expose visual regressions** | Phase 2 runs after Phase 1 tests pass, ensuring server logic is solid. Stories are purely documentation and don't affect runtime behavior. Visual issues in stories indicate rendering bugs, not data issues. Leverage existing merge-review.stories.tsx as a reference for correct rendering patterns. |
  | **Full test suite fails in Phase 3 with unrelated failures** | Run `pnpm test` early in Phase 1 to establish a clean baseline. Any failures in Phase 3 that aren't from new tests indicate environmental issues or unrelated breakage. Isolate with `pnpm test:unit` for unit tests only, `pnpm test:watch` for TDD workflow. |
  | **E2E smoke test fails due to environment setup** | E2E test depends on full stack (database, worktree, agent). Document prerequisites clearly in task acceptance criteria. Provide fallback manual smoke test steps if E2E automation is blocked. The feature is already working in production, so E2E failure likely indicates test environment issues, not feature bugs. |
  | **Vitest mock setup for DI container is complex** | Follow established pattern from approve-feature.test.ts and reject-feature.test.ts which both use `vi.mock('@/lib/server-container')` with token-based resolution. Copy mock setup structure directly to minimize trial-and-error. |
  | **Test coverage calculation shows gaps** | Phase 1 tasks explicitly cover all branches: validation (empty/whitespace), errors (feature not found, DI failure), data mapping (PR, branch, phases, diff), graceful degradation (plan failure, worktree missing, diff failure). If coverage gaps remain, add targeted test cases in REFACTOR step. |
  | **Story additions break existing story structure** | Review feature-node.stories.tsx and control-center.stories.tsx structure before adding variants. Match existing story format exactly (args shape, decorators, play functions). Run Storybook locally (`pnpm dev:storybook`) after each addition to verify stories render correctly. |
  | **Merge conflicts if implementation changes during planning** | Feature is 95% complete and stable. Risk of concurrent changes is low. If conflicts occur, prioritize test coverage over story additions since tests are mandatory and higher value. Stories can be added in a follow-up if necessary. |
