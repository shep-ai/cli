name: merge-review-drawer
summary: >
  Implement the merge review drawer and feature node visualization for the Review lifecycle
  phase. The approach follows the established 5-file component pattern (config, content, drawer,
  stories, barrel) used by prd-questionnaire and tech-decisions-review, with a new server action
  for data retrieval. The feature node gets three small additions to getBadgeIcon, getBadgeText,
  and getActionRequiredBadgeClasses for the emerald/GitMerge review badge. The control center
  integrates the drawer using the same state + useEffect + conditional rendering pattern as
  existing drawers. No backend changes, no domain model changes, no new dependencies.

relatedFeatures: []
technologies:
  - React 19 (Next.js 16+ App Router)
  - shadcn/ui (Radix + Tailwind CSS v4)
  - React Flow (@xyflow/react)
  - Storybook 8
  - Vaul (drawer primitive via ReviewDrawerShell)
  - Lucide React (GitMerge, CheckCircle2, XCircle, Loader2, ExternalLink)
  - sonner (toast notifications)
  - tsyringe (DI container for server actions via resolve())
relatedLinks: []

phases:
  - id: phase-1
    name: 'Feature Node Badge Updates'
    description: >
      Add the review lifecycle case to the three badge functions in feature-node.tsx and the
      merge node mapping in page.tsx. This is the foundation because the badge determines
      how features in the review state appear on the canvas — without this, the control center
      cannot derive showMergeReviewDrawer since the lifecycle won't be set to "review" for
      merge nodes. Small, isolated changes with clear before/after behavior.
    parallel: false

  - id: phase-2
    name: 'Server Action & Data Types'
    description: >
      Create the getMergeReviewData server action and the MergeReviewData type definition in
      merge-review-config.ts. The server action resolves Feature.pr via IFeatureRepository and
      calls IGitPrService.getPrDiffSummary() with graceful fallback. This phase establishes the
      data contract that the UI components will consume. Done before components so the data
      shape is finalized and testable independently.
    parallel: false

  - id: phase-3
    name: 'Merge Review Component Suite'
    description: >
      Build the 5-file merge-review component directory: config (interfaces), content component
      (PR metadata, diff stats, CI badge, approve button), drawer wrapper (ReviewDrawerShell
      integration), barrel export, and Storybook stories. The content component is read-only
      with an approve action — no chat input, no multi-step flow. Stories cover all variants:
      default, CI states, degraded (no diff), processing.
    parallel: false

  - id: phase-4
    name: 'Control Center Integration & Story Updates'
    description: >
      Wire the merge review drawer into control-center-inner.tsx following the exact pattern
      of the PRD and Tech Decision drawers: state declarations, showMergeReviewDrawer boolean,
      useEffect with cancellation, approval handler, conditional rendering, and FeatureDrawer
      suppression. Update feature-node and control-center stories with review state variants.
      This is last because it depends on both the component suite and the server action.
    parallel: false

filesToCreate:
  - src/presentation/web/components/common/merge-review/merge-review-config.ts
  - src/presentation/web/components/common/merge-review/merge-review.tsx
  - src/presentation/web/components/common/merge-review/merge-review-drawer.tsx
  - src/presentation/web/components/common/merge-review/merge-review.stories.tsx
  - src/presentation/web/components/common/merge-review/index.ts
  - src/presentation/web/app/actions/get-merge-review-data.ts

filesToModify:
  - src/presentation/web/app/page.tsx
  - src/presentation/web/components/common/feature-node/feature-node.tsx
  - src/presentation/web/components/common/feature-node/feature-node.stories.tsx
  - src/presentation/web/components/features/control-center/control-center-inner.tsx
  - src/presentation/web/components/features/control-center/control-center.stories.tsx

openQuestions: []

content: |
  ## Architecture Overview

  The merge review drawer fits into the existing presentation layer architecture at three
  integration points:

  1. **Feature Node (canvas visualization)** — Three functions in `feature-node.tsx` dispatch
     on `data.lifecycle` to customize badge icon, color, and text. Adding a `review` case to
     each mirrors the existing `requirements` and `implementation` cases. The `page.tsx`
     `nodeToLifecyclePhase` map needs `merge: 'review'` so the agent graph node name resolves
     to the correct UI lifecycle phase.

  2. **Component Suite (common/merge-review/)** — Follows the 5-file pattern established by
     `prd-questionnaire/` (51+217+37+386+11 lines) and `tech-decisions-review/`
     (43+189+35+stories+9 lines). The merge review content is simpler than both: read-only
     display with a single approve button, no chat input, no multi-step flow. This keeps the
     content component at ~120 lines.

  3. **Control Center (orchestration)** — `control-center-inner.tsx` (262 lines) manages all
     drawer state inline with a repeating pattern: state declarations → visibility boolean →
     useEffect with cancellation → approval handler → conditional rendering. The merge drawer
     adds one more instance of this pattern plus extending the FeatureDrawer suppression
     condition.

  **Data Flow:**
  ```
  page.tsx (server) — nodeToLifecyclePhase adds `merge: 'review'`
    → FeatureNodeData.lifecycle = 'review' when agent is at merge node
    → FeatureNode renders emerald GitMerge badge

  control-center-inner.tsx (client)
    → showMergeReviewDrawer = lifecycle === 'review' && state === 'action-required'
    → useEffect calls getMergeReviewData(featureId) server action
    → server action resolves Feature.pr + getPrDiffSummary() with fallback
    → MergeReviewDrawer renders ReviewDrawerShell + MergeReview content
    → Approve button calls approveFeature(featureId) (existing action)
  ```

  ## Key Design Decisions

  ### 1. Read Feature.pr + Regenerate Diff (Not Checkpoint or Persisted)

  Feature.pr is populated in merge.node.ts (lines 144-158) before the interrupt and persisted
  to SQLite. The diff summary is regenerated on demand via IGitPrService.getPrDiffSummary().
  This avoids domain model changes (NFR-7) and follows the existing server action pattern.
  If the worktree is unavailable, the diff is omitted gracefully — PR metadata always works.

  ### 2. Read-Only Content (No Chat Input)

  Unlike PRD (option selection) and Tech Decisions (plan refinement with chat), merge review
  is a binary approval decision. The merge node's LangGraph interrupt doesn't support
  feedback-based revision. Adding a non-functional chat input would mislead users.

  ### 3. Emerald Badge with GitMerge Icon

  Creates a three-color progression for review states: amber/FileText (requirements) →
  indigo/Wrench (implementation) → emerald/GitMerge (merge). Emerald semantically means
  "ready to proceed", matching GitHub's green merge button. The badge override only affects
  the badge pill classes, not the action-required border.

  ### 4. Graceful Degradation for Diff Summary

  The server action uses a nested try/catch: outer for Feature.pr (always available during
  Review phase), inner for getPrDiffSummary (depends on live worktree). If the inner fails,
  the action returns PR metadata with diffSummary omitted. The component checks for presence
  and renders a subtle warning instead of the diff section.

  ### 5. Inline Control Center State (Not Custom Hook)

  The PRD and Tech Decision drawers both manage state inline in control-center-inner.tsx.
  Extracting merge drawer logic into a custom hook would break this established pattern.
  The merge drawer's state management is simpler than both (no selections, no chat).

  ### 6. Hardcoded "main" as Base Branch

  merge.node.ts hardcodes `baseBranch = 'main'` (line 59). The server action matches this
  for consistency. If the repo uses "master", getPrDiffSummary fails gracefully and the
  drawer shows PR metadata without diff stats.

  ## Implementation Strategy

  The phases are ordered by dependency chain:

  **Phase 1 (Feature Node)** comes first because it's the smallest change with the highest
  visibility — users immediately see the correct badge for merge review state. It also
  establishes the `merge: 'review'` mapping that the control center needs to derive
  `showMergeReviewDrawer`.

  **Phase 2 (Server Action)** comes next to establish the data contract independently of
  the UI components. The server action can be tested in isolation and the MergeReviewData
  type drives the component props.

  **Phase 3 (Components)** depends on Phase 2 for the data type and server action. Building
  the component suite with Storybook stories provides visual verification before wiring
  into the control center.

  **Phase 4 (Integration)** depends on all previous phases. It wires everything together
  in the control center and adds story variants for the integration.

  ## Risk Mitigation

  | Risk | Mitigation |
  | ---- | ---------- |
  | Worktree deleted during Review phase, blocking diff summary | Graceful degradation: nested try/catch returns PR metadata without diff. Drawer still fully functional. |
  | IGitPrService DI token not registered in web server context | Verify token registration in container setup. If missing, the server action catches the error and returns `{ error }`. |
  | Emerald badge colors clash with dark mode | Use Tailwind's emerald palette (bg-emerald-50, text-emerald-700) which has built-in dark mode variants. Follow existing amber/indigo patterns. |
  | FeatureDrawer suppression condition grows unwieldy | Extract to a named boolean `const isSpecialDrawerActive = showPrdDrawer || showTechDecisionsDrawer || showMergeReviewDrawer` for readability. |
  | Feature.pr is null when lifecycle is Review | Guard with null check in server action — return `{ error: 'No PR data available' }`. The drawer is only shown when state is action-required, which guarantees pr is populated by merge.node.ts. |
  | Story rendering fails due to missing server action mocks | Stories use the content component directly with props (not the drawer+action path), following the existing PRD/Tech pattern where stories don't call server actions. |
