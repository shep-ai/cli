name: merge-review-drawer
summary: >
  Implements the merge review drawer feature following the established 5-file review drawer
  pattern (config, content, drawer wrapper, stories, barrel). The server action reads Feature.pr
  metadata and calls IGitPrService.getPrDiffSummary() with graceful degradation. The feature
  node gains emerald/GitMerge badge visualization for the review lifecycle. Control center
  integration follows the identical inline pattern used by PRD and Tech Decision drawers.
  No domain model changes, no backend modifications, and zero new npm dependencies. Reuses
  ReviewDrawerShell, DrawerActionBar, and CiStatusBadge shared components at zero additional cost.

relatedFeatures: []

technologies:
  - React 19 (Next.js 16+ App Router)
  - shadcn/ui (Radix + Tailwind CSS v4)
  - React Flow (@xyflow/react)
  - Storybook 8
  - Vaul (drawer primitive via ReviewDrawerShell)
  - Lucide React (GitMerge, ExternalLink, FileDiff, GitCommitHorizontal, GitBranch, ArrowRight, Layers, AlertTriangle, Loader2)
  - sonner (toast notifications)
  - tsyringe (DI container for server actions)
  - vitest + @testing-library/react (unit and component tests)

relatedLinks: []

phases:
  - id: phase-1
    name: 'Foundation — Types, Config & Server Action'
    description: >
      Define all TypeScript interfaces in merge-review-config.ts (7 interfaces:
      MergeReviewDiffSummary, MergeReviewPr, MergeReviewPhase, MergeReviewBranch,
      MergeReviewData, MergeReviewProps, MergeReviewDrawerProps) and implement the
      get-merge-review-data server action with input validation, DI resolution, Feature.pr
      extraction, best-effort plan phase loading, and graceful diff summary fallback.
      This phase establishes the data contract and server-side data layer that all
      subsequent UI work depends on. TDD: server action tests written first.
    parallel: false

  - id: phase-2
    name: 'Feature Node Badge Visualization & Page Mapping'
    description: >
      Add review lifecycle handling to the three badge functions in feature-node.tsx:
      getBadgeIcon (GitMerge), getActionRequiredBadgeClasses (emerald colors), and
      getBadgeText ("Review Merge Request"). Add `merge: 'review'` entry to
      nodeToLifecyclePhase in page.tsx. Add MergeReviewActionRequired story variant
      to feature-node.stories.tsx. This phase is independent of the drawer but provides
      the visual entry point users click and the lifecycle mapping the control center
      needs for showMergeReviewDrawer derivation.
    parallel: false

  - id: phase-3
    name: 'Merge Review Component Suite'
    description: >
      Build the MergeReview content component (~195 lines: PR metadata card, diff stats
      grid, CI badge via CiStatusBadge, branch direction with badges, phases list with
      emerald numbered badges, DrawerActionBar footer) and the MergeReviewDrawer shell
      wrapper (~35 lines, thin composition layer with Loader2 spinner for loading state).
      Create barrel export and all 11+ Storybook story variants. Write component tests
      using @testing-library/react for rendering, conditional sections, interactions,
      and disabled states. TDD: component tests written first.
    parallel: false

  - id: phase-4
    name: 'Control Center Integration'
    description: >
      Wire the merge review drawer into control-center-inner.tsx following the exact
      inline pattern used by PRD and Tech Decision drawers: state declarations
      (mergeReviewData, isLoadingMergeReview), showMergeReviewDrawer boolean derived
      from lifecycle + state, useEffect with cancellation pattern for data fetching,
      handleMergeApprove using shared handleSimpleApprove('Merge'), handleMergeReject
      using shared handleReject, conditional MergeReviewDrawer rendering, and FeatureDrawer
      suppression extension. Update control-center.stories.tsx with merge review node.
    parallel: false

  - id: phase-5
    name: 'Test Coverage & Validation'
    description: >
      Write remaining test files: server action tests (get-merge-review-data.test.ts
      covering validation, error handling, data mapping, and graceful fallbacks), type
      validation tests (merge-review-config.test.ts using expectTypeOf), barrel export
      tests (merge-review-barrel.test.ts), and drawer wrapper tests
      (merge-review-drawer.test.tsx). Run full test suite, lint, and typecheck to ensure
      no regressions. Verify all 18 success criteria are met.
    parallel: false

filesToCreate:
  - src/presentation/web/components/common/merge-review/merge-review-config.ts
  - src/presentation/web/components/common/merge-review/merge-review.tsx
  - src/presentation/web/components/common/merge-review/merge-review-drawer.tsx
  - src/presentation/web/components/common/merge-review/merge-review.stories.tsx
  - src/presentation/web/components/common/merge-review/index.ts
  - src/presentation/web/app/actions/get-merge-review-data.ts
  - tests/unit/presentation/web/actions/get-merge-review-data.test.ts
  - tests/unit/presentation/web/components/common/merge-review/merge-review.test.tsx
  - tests/unit/presentation/web/components/common/merge-review/merge-review-config.test.ts
  - tests/unit/presentation/web/components/common/merge-review/merge-review-barrel.test.ts
  - tests/unit/presentation/web/components/common/merge-review/merge-review-drawer.test.tsx

filesToModify:
  - src/presentation/web/components/common/feature-node/feature-node.tsx
  - src/presentation/web/components/features/control-center/control-center-inner.tsx
  - src/presentation/web/app/page.tsx
  - src/presentation/web/components/common/feature-node/feature-node.stories.tsx
  - src/presentation/web/components/features/control-center/control-center.stories.tsx

openQuestions: []

content: |
  ## Architecture Overview

  The merge review drawer integrates into the existing clean architecture web UI layer at
  `src/presentation/web/`. It follows the identical component pattern established by the
  PRD questionnaire and tech decisions review drawers, fitting into three integration points:

  **1. Feature Node (canvas visualization)** — Three functions in `feature-node.tsx` dispatch
  on `data.lifecycle` to customize badge icon, color, and text. Adding a `review` case to
  each mirrors the existing `requirements` and `implementation` cases. The `page.tsx`
  `nodeToLifecyclePhase` map needs `merge: 'review'` so the agent graph node name resolves
  to the correct UI lifecycle phase.

  **2. Component Suite (common/merge-review/)** — Follows the 5-file pattern established by
  `prd-questionnaire/` and `tech-decisions-review/`. The merge review content is simpler than
  both: read-only display with DrawerActionBar (approve + reject), no multi-step flow, no
  option selection, no dedicated chat input beyond DrawerRevisionInput.

  **3. Control Center (orchestration)** — `control-center-inner.tsx` manages all drawer state
  inline with a repeating pattern: state declarations → visibility boolean → useEffect with
  cancellation → approval/rejection handlers → conditional rendering. The merge drawer adds
  one more instance of this pattern.

  **Data Flow:**
  ```
  page.tsx (server component)
    → nodeToLifecyclePhase maps `merge` node → `review` lifecycle
    → Feature at merge agent node gets lifecycle='review'

  control-center-inner.tsx (client component)
    → showMergeReviewDrawer = lifecycle === 'review' && state === 'action-required'
    → useEffect calls getMergeReviewData(featureId) server action
    → Server action resolves via DI:
        1. IFeatureRepository.findById → Feature.pr (PR metadata)
        2. feature.branch → MergeReviewBranch (source → 'main')
        3. GetPlanArtifactUseCase → MergeReviewPhase[] (best-effort, nested try/catch)
        4. IGitPrService.getPrDiffSummary → MergeReviewDiffSummary (graceful fallback)
    → MergeReviewDrawer renders ReviewDrawerShell + MergeReview content
    → Approve calls approveFeature(featureId) via shared handleSimpleApprove('Merge')
    → Reject calls rejectFeature(featureId, feedback) via shared handleReject
  ```

  **Component Hierarchy:**
  ```
  ReviewDrawerShell (shared: header, actions menu, delete confirmation)
    └── MergeReview (content component)
          ├── Header (emerald dot + "Merge Review" title + contextual description)
          ├── Branch Direction card (GitBranch icon + source badge → target badge)
          ├── PR Metadata card (number link + ExternalLink, status badge, CI badge, commit hash)
          ├── Diff Summary card (FileDiff icon + 4-col grid: files, +adds, -dels, commits)
          │   └── OR Warning card (AlertTriangle + message text)
          ├── Implementation Phases list (Layers icon + numbered list with emerald badges)
          └── DrawerActionBar (shared: inline revision input, reject dialog, approve button)
  ```

  **Type System (merge-review-config.ts):**
  ```
  MergeReviewDiffSummary { filesChanged, additions, deletions, commitCount }
  MergeReviewPr { url, number, status: PrStatus, commitHash?, ciStatus?: CiStatus }
  MergeReviewPhase { id, name, description? }
  MergeReviewBranch { source, target }
  MergeReviewData { pr?, diffSummary?, phases?, branch?, warning? }
  MergeReviewProps { data, onApprove, onReject?, isProcessing?, isRejecting? }
  MergeReviewDrawerProps extends Omit<MergeReviewProps, 'data'> + shell props (nullable data)
  ```

  ## Key Design Decisions

  ### 1. Server Action Architecture — Direct DI Resolution (Not a Dedicated Use Case)

  **Chosen:** Direct server action (get-merge-review-data.ts, ~64 lines) resolving
  IFeatureRepository, GetPlanArtifactUseCase, and IGitPrService via the DI container's
  resolve() helper from lib/server-container.ts.

  **Alternatives rejected:**
  - Dedicated use case class (GetMergeReviewDataUseCase): Adds unnecessary indirection for
    a simple read operation. The existing pattern (get-feature-artifact.ts, get-research-artifact.ts)
    resolves use cases directly without wrapper classes.
  - Read LangGraph checkpoint: Couples UI to agent internals; Feature.pr is already persisted
    by merge.node.ts lines 226-237 before the interrupt() call.

  **Rationale:** Follows the established server action pattern exactly. The action validates
  input with trim(), resolves dependencies via DI tokens, and returns a discriminated union
  (MergeReviewData | { error: string }). Three-tier error handling: outer try/catch for
  infrastructure errors, nested try/catch for plan phases (best-effort, silently set to
  undefined), nested try/catch for diff summary (returns warning field).

  ### 2. Component Structure — 5-File Pattern in common/ Tier

  **Chosen:** components/common/merge-review/ with config, content, drawer, stories, barrel —
  exactly mirroring prd-questionnaire/ and tech-decisions-review/.

  **Alternatives rejected:**
  - Single file: Violates established convention. All review drawers use 5 files for single
    responsibility separation.
  - features/ tier (Tier 3): Breaks parallel with prd-questionnaire and tech-decisions-review
    (both in components/common/ as Tier 1 shared domain components).

  **Rationale:** The 5-file pattern separates concerns: config defines data contracts, content
  component is standalone (testable, usable in stories without drawer shell), drawer wrapper
  is thin composition, stories provide visual verification, barrel controls the public API.

  ### 3. Content Design — Read-Only Display with DrawerActionBar (Approve + Reject)

  **Chosen:** Read-only PR metadata, diff stats, branch direction, and phases with the shared
  DrawerActionBar providing approve + reject flow (inline DrawerRevisionInput + RejectFeedbackDialog).

  **Alternatives rejected:**
  - Separate chat input for refinement: DrawerActionBar already provides inline revision input.
    Merge review doesn't need an additional chat component.
  - File-level diff display: Requires extending IGitPrService; aggregate stats match the
    existing DiffSummary interface shape exactly (filesChanged, additions, deletions, commitCount).
  - Approve-only without reject: Inconsistent with DrawerActionBar's design. The shared
    component provides reject at zero cost, and rejectFeature() already supports all gates.

  **Rationale:** Merge review is fundamentally a binary decision, but the DrawerActionBar's
  built-in reject flow gives users the option to request revisions before merging. Props:
  approveLabel="Approve Merge", approveIcon={GitMerge or Loader2 spinner},
  revisionPlaceholder="Ask AI to revise before merging...", rejectDialogTitle="Reject Merge".

  ### 4. Badge Visualization — Emerald + GitMerge Icon

  **Chosen:** Emerald (green) color scheme with GitMerge icon for review + action-required.
  Colors: text-emerald-700, bg-emerald-50.

  **Alternatives rejected:**
  - Purple/GitPullRequest: No semantic meaning for merging.
  - Amber (default): Indistinguishable from PRD review (both would be amber).

  **Rationale:** Creates clear visual progression for action-required badge states:
  amber/FileText (requirements) → indigo/Wrench (implementation) → emerald/GitMerge (merge).
  Green semantically means "ready to merge", matching GitHub's convention. No collision with
  'done' state (emerald in feature-node-state-config.ts) because done and action-required
  are mutually exclusive states.

  ### 5. Error Handling — Three-Tier Graceful Degradation

  **Chosen:** Server action structure with nested try/catch where each data section degrades
  independently. No failure blocks the approve action.

  **Alternatives rejected:**
  - Block drawer on error: Frustrates users; approval doesn't need diff data.
  - Cache diff on Feature entity: Requires domain model changes (NFR-2 violation).

  **Rationale:**
  ```
  validate featureId → resolve feature
  extract pr metadata from feature.pr (always available during Review phase)
  construct branch info from feature.branch + 'main'
  try { phases = GetPlanArtifactUseCase.execute(featureId) } catch { phases = undefined }
  if (!feature.worktreePath) → return { pr, branch, phases, warning? }
  try { diffSummary = getPrDiffSummary(worktreePath, 'main') } catch { warning }
  return { pr, branch, phases, diffSummary? }
  ```

  ### 6. Control Center Integration — Same Inline Pattern (Not Custom Hook)

  **Chosen:** Follow the identical inline pattern used by PRD and Tech Decision drawers in
  control-center-inner.tsx.

  **Alternatives rejected:**
  - Custom hook extraction: Breaks established pattern; PRD and Tech Decision drawers don't
    use hooks. The control center manages all drawer state inline.
  - React Suspense: Control center is a client component; Suspense would require restructuring.

  **Rationale:** Adds state (mergeReviewData, isLoadingMergeReview), boolean
  (showMergeReviewDrawer), useEffect with cancellation, approval handler via shared
  handleSimpleApprove('Merge'), rejection handler via shared handleReject('Merge'),
  conditional MergeReviewDrawer rendering, and FeatureDrawer suppression extension.

  ## Implementation Strategy

  The phases are ordered by dependency chain (bottom-up):

  **Phase 1 (Foundation)** comes first to establish the data contract (type interfaces) and
  server-side data layer (server action). All UI components depend on these types. Server
  action tests are written first (TDD) to validate input handling, error paths, and data mapping.

  **Phase 2 (Feature Node)** establishes the visual entry point. Users see the emerald badge
  on the canvas, and the `merge: 'review'` mapping enables the control center to derive
  showMergeReviewDrawer. This is a small, isolated change to three existing functions plus one
  line in page.tsx.

  **Phase 3 (Components)** builds the full component suite. Depends on Phase 1 for type
  definitions. Content component tests written first (TDD), then implementation, then stories
  for visual verification.

  **Phase 4 (Integration)** wires everything together. Depends on Phase 1 (server action),
  Phase 2 (lifecycle mapping), and Phase 3 (drawer component). Follows the exact inline
  pattern used by PRD and Tech Decision drawer integrations.

  **Phase 5 (Tests & Validation)** ensures comprehensive coverage. Server action tests,
  type tests, barrel tests, drawer wrapper tests, plus full validation pass (typecheck,
  lint, test suite).

  ## Risk Mitigation

  | Risk | Mitigation |
  | ---- | ---------- |
  | Worktree deleted during Review phase | Server action checks feature.worktreePath before attempting diff; nested try/catch returns PR metadata with warning |
  | DI container not initialized in test environment | Mock resolve() via vi.mock('@/lib/server-container') with token-based resolution — established pattern in approve-feature.test.ts |
  | getPrDiffSummary() timeout on large repos | Nested try/catch returns warning text; diff stats are non-blocking supplementary info |
  | Plan artifact missing or corrupted | Best-effort loading in nested try/catch; phases silently set to undefined |
  | Feature.pr is null (direct merge without PR) | Component conditionally renders PR card only when pr is defined; alternate description text shown |
  | Hardcoded baseBranch='main' incorrect for some repos | Matches merge.node.ts behavior exactly; fails gracefully via diff try/catch |
  | Emerald color collision with 'done' state | No collision — done and action-required are mutually exclusive states in deriveNodeState() |
  | FeatureDrawer suppression condition grows complex | Extended naturally: showPrdDrawer || showTechDecisionsDrawer || showMergeReviewDrawer |
  | Stories fail due to server action dependency | Stories use content component directly with props (not drawer+action path), following existing pattern |
