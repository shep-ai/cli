# Implementation Plan (YAML)
# This is the source of truth. Markdown is auto-generated from this file.

name: agent-session-listing
summary: >
  Implements 'shep session ls' and 'shep session show <id>' CLI commands using Clean Architecture.
  Domain types (AgentSession, AgentSessionMessage) are TypeSpec-first. The application layer
  defines IAgentSessionRepository and two use cases. Infrastructure provides a
  ClaudeCodeSessionRepository (reads ~/.claude/projects/ JSONL files with lazy mtime-sort) and
  stub implementations for Cursor/Gemini. Provider selection uses per-AgentType string DI tokens
  resolved through an AgentSessionRepositoryRegistry, mirroring the settings-driven executor
  pattern already mandated in the codebase.

relatedFeatures: []

technologies:
  - TypeScript
  - TypeSpec
  - tsyringe (DI)
  - Node.js fs/promises
  - Commander.js
  - Clean Architecture
  - vitest (unit + integration tests)

relatedLinks:
  - 'https://docs.anthropic.com/en/docs/claude-code/overview'

phases:
  - id: phase-1
    name: 'Domain Foundation — TypeSpec Models & Enum Extension'
    description: >
      Extend the AgentFeature enum with sessionListing and define AgentSessionMessage and
      AgentSession TypeSpec models. Compile with pnpm tsp:compile to regenerate output.ts.
      This phase must come first because all subsequent layers depend on the generated
      TypeScript types. No application or infrastructure code can be written until the
      domain types exist.
    parallel: false

  - id: phase-2
    name: 'Application Layer — Port, Registry, Use Cases & Error'
    description: >
      Define IAgentSessionRepository port interface, AgentSessionRepositoryRegistry service,
      ListAgentSessionsUseCase, GetAgentSessionUseCase, and SessionNotFoundError. These are
      pure TypeScript classes with no infrastructure dependencies, making them fast to write
      and fully testable with mock repositories. Unit tests are written TDD-first in this phase.
    parallel: false

  - id: phase-3
    name: 'Infrastructure Layer — Repositories'
    description: >
      Implement ClaudeCodeSessionRepository (reads JSONL files with lazy mtime-sort and
      Promise.allSettled parallelism) and StubSessionRepository for Cursor/Gemini. Update
      ClaudeCodeExecutorService to declare session-listing support. Integration tests for
      ClaudeCodeSessionRepository use fixture JSONL files — no real filesystem access.
    parallel: false

  - id: phase-4
    name: 'DI Wiring — Container Registration'
    description: >
      Register the new session repositories (per-AgentType string tokens), the registry,
      and the two use cases in container.ts. This is the integration point between all
      layers and must come after all classes are implemented.
    parallel: false

  - id: phase-5
    name: 'Presentation Layer — CLI Commands'
    description: >
      Create session/ls.command.ts, session/show.command.ts, and session/index.ts under
      src/presentation/cli/commands/session/. Register createSessionCommand() in the main
      CLI bootstrap. The commands resolve use cases via container.resolve(), format output
      using the existing CLI UI utilities (renderListView, colors, symbols), and handle
      provider flags and limit/messages options.
    parallel: false

  - id: phase-6
    name: 'Validation & Cleanup'
    description: >
      Run pnpm validate (lint + typecheck + tsp:compile) and pnpm test to confirm all
      checks pass with zero regressions. Fix any issues found. Update feature.yaml status.
    parallel: false

filesToCreate:
  - tsp/agents/agent-session-message.tsp
  - tsp/agents/agent-session.tsp
  - packages/core/src/application/ports/output/agents/agent-session-repository.interface.ts
  - packages/core/src/domain/errors/session-not-found.error.ts
  - packages/core/src/application/services/agents/agent-session-repository.registry.ts
  - packages/core/src/application/use-cases/agents/list-agent-sessions.use-case.ts
  - packages/core/src/application/use-cases/agents/get-agent-session.use-case.ts
  - packages/core/src/infrastructure/services/agents/sessions/claude-code-session.repository.ts
  - packages/core/src/infrastructure/services/agents/sessions/stub-session.repository.ts
  - src/presentation/cli/commands/session/index.ts
  - src/presentation/cli/commands/session/ls.command.ts
  - src/presentation/cli/commands/session/show.command.ts
  - tests/unit/application/use-cases/agents/list-agent-sessions.use-case.test.ts
  - tests/unit/application/use-cases/agents/get-agent-session.use-case.test.ts
  - tests/integration/infrastructure/services/agents/sessions/claude-code-session.repository.test.ts
  - tests/fixtures/claude-sessions/-home-user-projects-foo/session-001.jsonl
  - tests/fixtures/claude-sessions/-home-user-projects-foo/session-002.jsonl
  - tests/fixtures/claude-sessions/-home-user-projects-foo/session-003.jsonl
  - tests/fixtures/claude-sessions/-home-user-projects-bar/session-004.jsonl

filesToModify:
  - tsp/agents/enums/agent-feature.tsp
  - tsp/agents/index.tsp
  - packages/core/src/application/ports/output/agents/index.ts
  - packages/core/src/infrastructure/services/agents/common/executors/claude-code-executor.service.ts
  - packages/core/src/infrastructure/di/container.ts
  - src/presentation/cli/index.ts

openQuestions: []

content: |
  ## Architecture Overview

  The feature slots cleanly into the four Clean Architecture layers already present in the
  codebase. Each layer's responsibility is narrow and changes are localized:

  ```
  Presentation (src/presentation/cli/commands/session/)
    ↓ resolves via container.resolve()
  Application (packages/core/src/application/)
    ↓ IAgentSessionRepository port
  Infrastructure (packages/core/src/infrastructure/services/agents/sessions/)
    ↓ reads ~/.claude/projects/ JSONL
  Domain (TypeSpec-generated output.ts via tsp/agents/)
  ```

  ### Dependency Rule Compliance

  - Domain: AgentSession, AgentSessionMessage defined in TypeSpec — no external deps.
  - Application: IAgentSessionRepository interface, use cases, registry — depend only on domain types and settings singleton.
  - Infrastructure: ClaudeCodeSessionRepository, StubSessionRepository — implement application port, use Node.js fs/os/path (no framework deps).
  - Presentation: CLI commands — call use cases via DI container, use existing ui/ utilities.

  ### Key Integration Points

  1. **AgentFeature enum** — extended in TypeSpec, compiled, used by ClaudeCodeExecutorService.supportsFeature().
  2. **AgentSessionRepositoryRegistry** — injectable application-layer service that resolves "IAgentSessionRepository:${agentType}" tokens from the container. This isolates use cases from the DI container directly.
  3. **Per-AgentType DI tokens** — string tokens "IAgentSessionRepository:claude-code", "IAgentSessionRepository:cursor-cli", "IAgentSessionRepository:gemini-cli" allow drop-in implementation replacement without modifying use cases.
  4. **getSettings().agent.type** — default provider when no CLI flag is given, consistent with the mandatory settings-driven executor pattern.

  ## Key Design Decisions

  ### 1. TypeSpec-First Domain Models (NFR-9)
  AgentSession and AgentSessionMessage are defined in tsp/agents/ (one file per model, SRP)
  and compiled to packages/core/src/domain/generated/output.ts via pnpm tsp:compile.
  Hand-editing generated types is forbidden by CLAUDE.md. AgentSession extends BaseEntity
  for the id field. AgentSessionMessage.content is normalized to string in the infrastructure
  layer — keeping the domain model clean without discriminated union complexity.

  ### 2. Lazy Stat-Then-Parse Performance Strategy (NFR-1)
  For the list view: stat all .jsonl files in parallel with Promise.allSettled(), sort by
  mtime descending, then fully parse only the top-N files. This means at most 20 file reads
  regardless of total session count (~1,140 files observed on dev machine). For the show
  view: read a single targeted file. This satisfies the 2-second performance target.

  ### 3. AgentSessionRepositoryRegistry as Application-Layer Mediator (NFR-4, NFR-5)
  Rather than injecting repositories directly into use cases (which would require the use
  case to know about concrete infrastructure classes) or building a composite dispatcher
  (which violates OCP), a thin registry service resolves the correct repository by
  AgentType at runtime. Use cases inject the registry — not specific repositories. Adding
  a new provider is a drop-in with zero use-case changes.

  ### 4. isSupported() on IAgentSessionRepository (FR-6, FR-17)
  Stub implementations return false from isSupported(). The use case checks this flag and
  emits the "not yet implemented" warning to stderr, then returns an empty list with exit 0.
  This keeps warning logic centralized in the use case (not the CLI command or repository),
  consistent with how other unsupported-capability flows work in the codebase.

  ### 5. Provider-Native Filename as Session ID (FR-13)
  Using the UUID filename (without .jsonl extension) as the session ID keeps the
  implementation stateless — no write-on-read index, no sync problem when files are deleted.
  The ID appears in the ls table (first 8 chars displayed) and is passed directly to
  findById() which constructs the file path from it.

  ### 6. Injectable basePath for Testability (NFR-8)
  ClaudeCodeSessionRepository accepts an optional basePath constructor parameter defaulting
  to path.join(os.homedir(), '.claude', 'projects'). Integration tests pass a fixture
  directory — same pattern as ClaudeCodeExecutorService's injectable spawn function.

  ### 7. Subagent Session Exclusion (NFR-2)
  Subagent JSONL files live in <uuid>/subagents/ subdirectories. By enumerating only .jsonl
  files at depth 1 under each project directory (filtering out directory entries), all
  subagent sessions are excluded with zero additional I/O.

  ## Implementation Strategy

  Phase ordering is strictly bottom-up following the Dependency Rule:
  - Phase 1 (Domain) must come first — all other layers import generated types.
  - Phase 2 (Application) depends on domain types; establishes interfaces for Phase 3.
  - Phase 3 (Infrastructure) implements Phase 2's interface; needs domain types.
  - Phase 4 (DI) wires all concrete implementations; can only run after Phase 3.
  - Phase 5 (Presentation) uses DI-resolved use cases; needs Phase 4 complete.
  - Phase 6 (Validation) runs last after all code is in place.

  TDD is applied throughout: unit tests for use cases are written RED before GREEN in
  Phase 2; integration tests for ClaudeCodeSessionRepository are written RED in Phase 3
  using fixture files in tests/fixtures/claude-sessions/.

  ## Risk Mitigation

  | Risk | Mitigation |
  | ---- | ---------- |
  | Claude Code JSONL format changes between versions | Per-entry try/catch with debug logging skips malformed entries; only fails hard on show when target file is unreadable |
  | TypeSpec compilation errors blocking all other work | Do TypeSpec work as first task; verify pnpm tsp:compile passes before any application code |
  | DI circular dependency from registry calling container.resolve() | Registry is an application-layer service (not domain) — acceptable pattern, mirrors AgentExecutorProvider which also wraps container calls |
  | Terminal width overflow in session ls table | Preview column uses 'remaining' width; test with narrow terminal; truncate at column boundary using existing renderListView behavior |
  | Integration test fixtures becoming stale | Minimal realistic JSONL fixtures covering valid, array-content, malformed, and minimal cases — kept simple and documented |
