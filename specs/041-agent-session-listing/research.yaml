# Research Artifact (YAML)
# This is the source of truth. Markdown is auto-generated from this file.

name: agent-session-listing
summary: >
  Claude Code stores sessions as JSONL files in ~/.claude/projects/<encoded-path>/<uuid>.jsonl
  where directory names replace path separators with hyphens. The implementation reads these files
  using fs/promises with mtime-based sorting for performance, introduces IAgentSessionRepository
  as a new application-layer port, and uses string-token DI bindings keyed by AgentType to
  support multi-provider extensibility without modifying use cases or CLI commands.

relatedFeatures: []

technologies:
  - TypeScript
  - TypeSpec
  - tsyringe (DI)
  - Node.js fs/promises
  - Commander.js
  - Clean Architecture
  - vitest (unit + integration tests)

relatedLinks:
  - 'https://docs.anthropic.com/en/docs/claude-code/overview'

decisions:
  - title: 'Claude Code Session File Format and Parsing Strategy'
    chosen: >
      Parse JSONL files lazily: stat all files for mtime-based sorting first, then
      fully parse only the top-N files needed for the list view. Each line is a JSON
      object with a "type" field ("user", "assistant", "progress", "queue-operation").
      The session ID is the filename UUID without the .jsonl extension. The project
      path is extracted from the cwd field in the first parsed JSONL entry (unambiguous,
      no encoding/decoding needed). The first user message preview is extracted from
      the first entry where type=="user" and message.role=="user", where content may be
      a string or an array of content blocks (extract text from the first text block).
    rejected:
      - >
        Load entire file into memory for parsing: Wasteful for large files (some
        files are 300KB+). The list view only needs the first user message and
        metadata, so reading all lines is unnecessary for ls. Rejected.
      - >
        Decode project path from directory name encoding: Claude Code encodes
        working directory paths by replacing slashes and dots with hyphens, making
        deterministic decoding ambiguous (e.g. "-home-blackpc--shep-repos-..." is
        hard to decode reliably). Using cwd from JSONL is unambiguous and free
        since we parse the file anyway. Rejected.
      - >
        Store parsed sessions in a local SQLite index: Adds write-on-read
        complexity, index staleness when provider files are deleted, and violates
        the stateless session-ID approach chosen in the spec. Rejected.
    rationale: >
      The lazy mtime-sort-then-parse approach satisfies NFR-1 (under 2 seconds for
      500+ sessions): we call fs.stat() on all entries (cheap syscall) to sort by
      mtime, then read only the first N JSONL files fully. For ls --limit 20, this
      means at most 20 full file reads regardless of the total session count.
      Scale observed on dev machine: 1,140 top-level JSONL files across 119 project
      directories. Stat calls for ~1,140 files take approximately 50-200ms on SSD.
      Reading 20 files averaging ~250KB each is well under 2 seconds total.
      Using cwd from JSONL avoids directory-name decoding ambiguity entirely.

  - title: 'IAgentSessionRepository DI Token Scheme'
    chosen: >
      Register one repository implementation per AgentType using string tokens of
      the form "IAgentSessionRepository:claude-code", "IAgentSessionRepository:cursor-cli",
      "IAgentSessionRepository:gemini-cli". A thin AgentSessionRepositoryRegistry
      injectable service resolves the correct implementation at runtime by calling
      container.resolve("IAgentSessionRepository:" + agentType). Use cases inject
      AgentSessionRepositoryRegistry and call getRepository(agentType).
    rejected:
      - >
        Single "IAgentSessionRepository" token with a composite implementation
        that delegates internally: Forces the composite class to know about all
        providers, violating OCP. Adding a new provider requires modifying the
        composite class. Rejected.
      - >
        Use class tokens directly (ClaudeCodeSessionRepository): Ties use-case
        injection to concrete infrastructure classes, violating the Dependency
        Inversion Principle and making testing harder. Rejected.
    rationale: >
      The per-AgentType token approach mirrors how the existing
      IAgentExecutorFactory works (createExecutor returns the right impl by type).
      Each provider repo is registered independently so adding a new provider is
      a drop-in: implement IAgentSessionRepository, register under its
      AgentType token, done. Use cases never change. This satisfies NFR-5
      (extensibility) and NFR-4 (clean architecture). The AgentSessionRepositoryRegistry
      service is the cleanest abstraction for the use cases and keeps container
      lookup logic out of business logic.

  - title: 'Provider Selection Mechanism for CLI Flags'
    chosen: >
      The session ls/show commands accept mutually exclusive provider flags
      (--claude-code, --cursor-cli, --gemini-cli). When a flag is present, it
      maps to an AgentType and is passed as an option to the use case execute()
      input (ListAgentSessionsInput.agentType). When no flag is present,
      the use case reads getSettings().agent.type as the default. The use case
      resolves the correct IAgentSessionRepository from the registry by agentType.
    rejected:
      - >
        Resolve repository in the CLI command and inject it into the use case:
        Violates Clean Architecture. The presentation layer should not know about
        infrastructure repositories. The use case must own the resolution logic.
        Rejected.
      - >
        Pass a repository instance directly via constructor overloading: Makes
        the use case non-injectable and breaks the DI lifecycle. Rejected.
    rationale: >
      Keeping provider selection inside the use case (with settings fallback)
      mirrors the existing settings-driven executor resolution pattern. The CLI
      flag is a user-facing concern that maps to an AgentType — the use case
      accepts an optional agentType override to support this without coupling
      the CLI to infrastructure. This is consistent with how feature and agent
      commands handle optional filtering parameters.

  - title: 'TypeSpec Model Placement for AgentSession and AgentSessionMessage'
    chosen: >
      Place AgentSession and AgentSessionMessage as new TypeSpec models in
      tsp/agents/agent-session.tsp and tsp/agents/agent-session-message.tsp
      (one model per file, SRP). AgentSession extends BaseEntity. Add
      sessionListing: "session-listing" to tsp/agents/enums/agent-feature.tsp.
      Compile via pnpm tsp:compile to regenerate output.ts.
    rejected:
      - >
        Inline AgentSession and AgentSessionMessage as hand-written TypeScript
        interfaces in domain/: Violates the TypeSpec-first mandate. All domain
        types must originate from TypeSpec. Explicitly forbidden by CLAUDE.md.
        Rejected.
      - >
        Add session fields directly to the AgentRun model: Sessions are independent
        entities from the agent executor perspective (they may not correspond to a
        Shep AgentRun at all). Conflating the models would pollute AgentRun and
        make it impossible to list sessions that have no corresponding run. Rejected.
    rationale: >
      The project mandates TypeSpec-first: all domain entities must be defined
      in .tsp files and compiled. One model per file is enforced by CLAUDE.md.
      tsp/agents/ is the correct subdirectory for agent-infrastructure models
      (AgentRun already lives there). Keeping AgentSession separate from AgentRun
      maintains single responsibility and allows the session-listing feature to
      remain fully independent from the agent-run tracking feature.

  - title: 'Handling Malformed or Unreadable Session Files'
    chosen: >
      Wrap each file read in a try/catch. On any error (EACCES, ENOENT, JSON parse
      failure, missing fields), log at DEBUG level via the existing logger and skip
      the file. The list operation continues with the remaining valid sessions.
      The show operation throws a SessionNotFoundError if the specific requested
      file cannot be read or parsed.
    rejected:
      - >
        Propagate errors to the caller and crash the command: Violates NFR-2
        (graceful handling). One corrupt file should not prevent listing 200
        valid sessions. Rejected.
      - >
        Return a placeholder session object with error flag: Adds complexity to
        the display layer, which would need to conditionally render error rows.
        Silent skip plus debug log is simpler and sufficient. Rejected.
    rationale: >
      NFR-2 explicitly requires skipping invalid files with a debug-level warning.
      The existing codebase uses debug-level logging for infrastructure noise and
      reserves error-level for user-actionable failures. A silent skip with
      debug logging is consistent with how executor services handle minor
      I/O issues (e.g., heartbeat file misses in AgentRunner).

  - title: 'Filtering Subagent Sessions from List Output'
    chosen: >
      Only enumerate .jsonl files directly at depth 1 inside each project directory
      (i.e., files directly under ~/.claude/projects/<project-dir>/). Skip any
      filesystem entries that are directories (these are the <uuid>/ subdirectories
      used to store subagent sessions). This filters out subagent sessions with
      zero additional I/O using a structural check.
    rejected:
      - >
        Include subagent sessions in the listing: Subagent sessions are internal
        implementation details spawned by Claude Code. Including them would clutter
        the list with hundreds of noise entries (1,039 subagent files observed vs
        1,140 top-level sessions on dev machine). Rejected.
      - >
        Read isSidechain field from each JSONL to filter: Requires opening every
        file to check the first line. Expensive for 1,000+ files. Structural
        filtering (depth-1 .jsonl files only) is free. Rejected.
    rationale: >
      Research confirmed that subagent JSONL files are stored in
      <session-uuid>/subagents/ subdirectories. By only reading .jsonl files
      at depth 1 under each project directory (skipping subdirectory entries),
      all subagent sessions are automatically excluded with zero additional
      file I/O. This satisfies NFR-1 performance and NFR-2 correctness.

  - title: 'Injectable Base Path for ClaudeCodeSessionRepository'
    chosen: >
      Accept an optional basePath constructor parameter defaulting to
      path.join(os.homedir(), '.claude', 'projects'). The DI container factory
      registration passes no basePath for production (uses default) and
      integration tests pass a temporary fixture directory.
    rejected:
      - >
        Hard-code the default path without injection: Makes integration tests
        impossible without touching real user data. Violates NFR-8. Rejected.
      - >
        Use an environment variable (e.g. CLAUDE_PROJECTS_DIR): Less explicit
        than constructor injection and harder to type-check. The codebase
        consistently uses constructor injection for testability (see spawn
        injection in ClaudeCodeExecutorService). Rejected.
    rationale: >
      NFR-8 explicitly requires injectable base path. The same pattern is
      already used in ClaudeCodeExecutorService where the spawn function is
      injected as a SpawnFunction to allow test doubles. Consistent with
      existing codebase patterns and enables integration tests with fixture
      JSONL files in a controlled temp directory.

  - title: 'AgentSessionMessage Content Typing in TypeSpec'
    chosen: >
      Type AgentSessionMessage.content as string only. The ClaudeCodeSessionRepository
      normalizes all content to a plain string during parsing: for user messages with
      string content use as-is; for content arrays extract the first text-type block.
      Thinking blocks and tool_use blocks are excluded. Parsing complexity stays in
      the infrastructure layer.
    rejected:
      - >
        Type as a discriminated union model with TextBlock, ToolUseBlock, ThinkingBlock
        subtypes: Significantly increases TypeSpec model complexity and makes CLI
        display logic more complex. The session listing feature only needs
        human-readable text for preview and conversation display. Overkill. Rejected.
      - >
        Type as string array (one element per text block): Handles multi-part
        content but complicates display (join strategy) and adds an array type
        where a single normalized string is sufficient for all current display needs.
        Rejected.
    rationale: >
      The session listing feature's use case is browsing session history, not
      faithfully reproducing every tool call. Normalizing content to string in
      the infrastructure layer keeps the domain model clean. This is exactly
      what the spec requires for the preview field. If a future feature needs
      full content fidelity, a richer model can be added incrementally.

openQuestions:
  - question: >
      Should the project path displayed in session ls use tilde abbreviation
      for the home directory (e.g. ~/repos/project) or show the full absolute path?
    resolved: true
    options:
      - option: 'Full absolute path (e.g. /home/user/repos/project)'
        description: >
          Show the complete absolute path exactly as stored in the cwd JSONL field.
          No transformation needed. Unambiguous but longer — may truncate in
          narrow terminals.
        selected: false
      - option: 'Tilde-abbreviated path (e.g. ~/repos/project)'
        description: >
          Replace the home directory prefix with ~/. Standard Unix convention,
          shorter rows, immediately recognizable to developers. A simple
          tildeAbbreviate(path) helper replaces os.homedir() + "/" with "~/".
        selected: true
      - option: 'Last 2 path segments only (e.g. repos/project)'
        description: >
          Show only the last 2 directory components. Shortest display but loses
          context when two projects share the same last segments. Could be
          confusing in multi-user or multi-machine scenarios.
        selected: false
    selectionRationale: >
      Tilde abbreviation follows standard Unix CLI conventions used across the
      ecosystem (git, ls, shell prompts). It gives full context while being
      compact. The existing CLI formatters in src/presentation/cli/ui/formatters.ts
      can be extended with a simple helper. This is consistent with how other
      path displays work in the codebase.
    answer: 'Tilde-abbreviated path (e.g. ~/repos/project)'

  - question: >
      Should the session ls table include the git branch from the JSONL
      metadata, or keep to 5 columns (ID, path, messages, timestamp, preview)?
    resolved: true
    options:
      - option: 'Project path only, no branch column — 5 columns as specified in FR-5'
        description: >
          Keep to the 5 columns defined in FR-5. The git branch is available in
          session show. Compact table fits standard terminal widths. The first
          user message preview is the most valuable at-a-glance column.
        selected: true
      - option: 'Replace preview column with branch column'
        description: >
          Show branch instead of preview. Branch is structured and never overflows,
          but removes the most useful at-a-glance content showing what the session
          was about.
        selected: false
      - option: 'Add branch as a 6th column'
        description: >
          Show all 6 columns. Table becomes very wide (over 120 chars) and may
          not render cleanly on standard 80-column terminals without column hiding
          logic.
        selected: false
    selectionRationale: >
      FR-5 explicitly defines 5 columns. The first user message preview is
      analogous to a commit message subject line — the best at-a-glance summary
      of session content. Git branch is supplementary information visible in
      session show. Keeping 5 columns matches the existing agent ls table
      width convention and renders cleanly on standard terminal widths.
    answer: 'Project path only, no branch column'

  - question: >
      How should parallel file stat calls be handled to maximize performance
      when scanning hundreds of project directories?
    resolved: true
    options:
      - option: 'Sequential stat calls with for-await loop'
        description: >
          Process one file at a time. Simple, no concurrency control needed,
          but slower: 1,140 sequential stats could take 500ms+ on slower
          disks. Simple to implement and debug.
        selected: false
      - option: 'Promise.allSettled() for all stat calls in parallel'
        description: >
          Fire all stat calls simultaneously with Promise.allSettled(). Per-file
          errors are isolated (allSettled never rejects). Maximum throughput on
          SSD with parallel I/O. Straightforward implementation using
          Promise.allSettled() which returns fulfilled/rejected results per entry.
        selected: true
      - option: 'Batched parallel stats (e.g. p-limit with concurrency 20)'
        description: >
          Use p-limit to cap concurrency at 20 simultaneous stat calls. Avoids
          file descriptor exhaustion on large directories. Adds a dependency
          (p-limit) and complexity for marginal gain on modern SSDs.
        selected: false
    selectionRationale: >
      Promise.allSettled() is the idiomatic Node.js approach for parallel async
      I/O with per-item error isolation. The number of session files is bounded
      by disk space (not an adversarial input) so unbounded parallelism is
      acceptable. Node.js handles the OS-level concurrency limits internally.
      Using allSettled means a single unreadable directory does not abort the
      entire scan, satisfying NFR-2. No extra dependencies needed.
    answer: 'Promise.allSettled() for all stat calls in parallel'

content: |
  ## Technology Decisions

  ### 1. Claude Code Session File Format (Confirmed by Inspection)

  **Storage layout confirmed on development machine:**
  ```
  ~/.claude/projects/
    -home-blackpc--shep-repos-<hash>-wt-<branch>/   <- encoded project path
      <uuid>.jsonl                                    <- session file
      <uuid>/subagents/agent-<id>.jsonl              <- subagent sessions (SKIP)
  ```

  **Scale observed:** 1,140 top-level session files across 119 project directories.
  An additional 1,039 subagent JSONL files exist in subdirectories (excluded from listing).

  **JSONL format:** One JSON object per line. Entry types observed:

  - `queue-operation` — session bootstrap with initial system prompt
  - `progress` — hook/tool events
  - `user` — user messages (`message.role == "user"`, content is string or content block array)
  - `assistant` — model responses (content array: text, thinking, tool_use blocks)

  **Common fields across all entries:** `uuid`, `parentUuid`, `sessionId`, `timestamp`,
  `cwd`, `gitBranch`, `version`, `isSidechain`

  **Key parsing insights:**
  - Session ID = UUID filename without `.jsonl` extension
  - Project path = `cwd` field from any JSONL entry (unambiguous, no decoding needed)
  - Message count = count of entries where type is "user" or "assistant"
  - Preview = content of first `type=="user"` entry with `message.role=="user"`
  - Content normalization: string content used as-is; array content extracts first text block

  ### 2. Performance Strategy

  **Stat-first approach** for ls satisfies NFR-1 (under 2s for 500+ sessions):

  1. `fs.readdir(basePath)` — list all project directories
  2. For each project dir: `fs.readdir()` — collect `.jsonl` files at depth 1 (skips subdirs)
  3. `Promise.allSettled(files.map(f => fs.stat(f)))` — parallel stat for mtime
  4. Sort all sessions by mtime descending — O(N log N), negligible
  5. Slice top N (--limit, default 20)
  6. Parse only top N files fully (for preview, messageCount, timestamps)

  **Cost analysis for 1,140 files:**
  - ~1,140 parallel stat syscalls ≈ 50-200ms on SSD
  - 20 full JSONL reads averaging ~250KB each ≈ 5MB reads ≈ 100-500ms
  - Total: well under 2s even with slow I/O

  ### 3. TypeSpec Model Design

  **New TypeSpec files:**

  ```
  tsp/agents/agent-session-message.tsp   <- AgentSessionMessage model
  tsp/agents/agent-session.tsp           <- AgentSession model
  tsp/agents/enums/agent-feature.tsp     <- add sessionListing enum value
  ```

  **AgentSessionMessage:**
  ```
  model AgentSessionMessage {
    uuid: string;
    role: "user" | "assistant";
    content: string;          // normalized text (text blocks extracted, tools excluded)
    timestamp: utcDateTime;
  }
  ```

  **AgentSession:**
  ```
  model AgentSession extends BaseEntity {
    // id from BaseEntity = sessionId (UUID)
    agentType: AgentType;
    projectPath: string;             // tilde-abbreviated cwd
    messageCount: int32;             // total user + assistant entries
    preview?: string;                // first user message text, truncated
    messages?: AgentSessionMessage[]; // populated in show command only
    firstMessageAt?: utcDateTime;
    lastMessageAt?: utcDateTime;
  }
  ```

  **AgentFeature addition:**
  ```
  sessionListing: "session-listing",   // add to existing AgentFeature enum
  ```

  ### 4. IAgentSessionRepository Port Interface

  ```typescript
  // application/ports/output/agents/agent-session-repository.interface.ts

  export interface ListSessionsOptions {
    limit?: number;      // default 20, 0 = all
  }

  export interface GetSessionOptions {
    messageLimit?: number;  // default 20, 0 = all
  }

  export interface IAgentSessionRepository {
    list(options?: ListSessionsOptions): Promise<AgentSession[]>;
    findById(id: string, options?: GetSessionOptions): Promise<AgentSession | null>;
    isSupported(): boolean;   // false for stub implementations
  }
  ```

  The `isSupported()` method allows the use case to emit a warning for stub
  implementations without coupling to AgentFeature or executor capabilities.

  ### 5. Use Case Design

  **ListAgentSessionsUseCase:**
  - Input: `{ agentType?: AgentType; limit?: number }`
  - Resolves agentType from input or `getSettings().agent.type`
  - Gets repository from `AgentSessionRepositoryRegistry.getRepository(agentType)`
  - If `!repo.isSupported()`: prints warning to stderr, returns `[]`
  - Otherwise: calls `repo.list({ limit: input.limit ?? 20 })`

  **GetAgentSessionUseCase:**
  - Input: `{ id: string; agentType?: AgentType; messageLimit?: number }`
  - Resolves agentType from input or settings
  - Calls `repo.findById(id, { messageLimit: input.messageLimit ?? 20 })`
  - Throws `SessionNotFoundError` if result is null

  **SessionNotFoundError** — a new domain error in `packages/core/src/domain/errors/`.

  ### 6. DI Registration Pattern

  Per-AgentType string tokens in container.ts:

  ```
  "IAgentSessionRepository:claude-code"  -> ClaudeCodeSessionRepository
  "IAgentSessionRepository:cursor-cli"   -> StubSessionRepository('cursor-cli')
  "IAgentSessionRepository:gemini-cli"   -> StubSessionRepository('gemini-cli')
  ```

  **AgentSessionRepositoryRegistry** (injectable singleton):
  ```typescript
  @injectable()
  class AgentSessionRepositoryRegistry {
    getRepository(agentType: AgentType): IAgentSessionRepository {
      return container.resolve(`IAgentSessionRepository:${agentType}`);
    }
  }
  ```

  Use cases inject `AgentSessionRepositoryRegistry` — never the concrete repos.

  ### 7. CLI Command Structure

  ```
  src/presentation/cli/commands/session/
    index.ts           <- createSessionCommand() registers ls + show subcommands
    ls.command.ts      <- createLsCommand(): handles --claude-code/--cursor-cli/--gemini-cli/--limit
    show.command.ts    <- createShowCommand(): handles <id> --claude-code/... --messages
  ```

  **session ls table columns (5):**
  | Column | Width | Content |
  |--------|-------|---------|
  | ID | 8 | First 8 chars of UUID |
  | Path | 35 | ~/tilde-abbreviated cwd |
  | Messages | 10 | Total message count |
  | Last Active | 16 | Relative time (e.g. "2d ago") |
  | Preview | remaining | First user message, truncated |

  **session show sections:**
  - Metadata section: session ID, provider, project path, message count, timestamps
  - Conversation text blocks: alternating user/assistant messages (colored)
  - Footer note: "Showing last N of M messages" when N < M

  ### 8. ClaudeCodeSessionRepository Implementation Notes

  **File: `packages/core/src/infrastructure/services/agents/sessions/claude-code-session.repository.ts`**

  Key implementation details:
  - Constructor: `constructor(private readonly basePath = path.join(os.homedir(), '.claude', 'projects'))`
  - `isSupported()` returns `true`
  - Parallel stat with `Promise.allSettled()` for performance
  - Depth-1 .jsonl enumeration (skips subdirectories for subagent sessions)
  - Per-file try/catch with debug logging for malformed files
  - Content extraction helper: string content used as-is; array content finds first text block
  - Message counting: count lines where `type === "user" || type === "assistant"`

  **StubSessionRepository:**
  - Constructor: `constructor(private readonly agentType: AgentType)`
  - `isSupported()` returns `false`
  - `list()` and `findById()` return empty/null (warning emitted by use case, not repo)

  ### 9. Integration Test Strategy

  **Fixture directory structure for tests:**
  ```
  tests/fixtures/claude-sessions/
    -home-user-projects-foo/
      session-001.jsonl    <- valid session with user+assistant messages
      session-002.jsonl    <- session with array content blocks
      session-003.jsonl    <- malformed (invalid JSON on one line)
    -home-user-projects-bar/
      session-004.jsonl    <- minimal session (single user message)
  ```

  Tests instantiate `ClaudeCodeSessionRepository(fixturesPath)` directly (no DI).
  Verify: correct session count, mtime sorting, malformed file skipping, content extraction.

  ## Library Analysis

  | Library | Purpose | Decision | Reasoning |
  |---------|---------|----------|-----------|
  | Node.js fs/promises | Read session JSONL files | Use | Built-in, no extra dependency |
  | Node.js os | os.homedir() for default base path | Use | Built-in |
  | Node.js path | path.join() for file paths | Use | Built-in |
  | Node.js readline | Line-by-line JSONL parsing | Use | Built-in, zero overhead |
  | ndjson / split2 | Alternative JSONL parsers | Reject | External dep for no gain |
  | glob / fast-glob | File discovery | Reject | fs.readdir with filter is simpler |
  | p-limit | Concurrency limiting | Reject | Node.js handles OS limits; adds dep |
  | better-sqlite3 | Session index storage | Reject | Adds write-on-read; stateless is better |

  ## Security Considerations

  - **Path traversal (NFR-3):** All file paths are constructed using `path.join(basePath, ...)` where
    basePath is a trusted constructor argument (defaults to `~/.claude/projects`). Project directories
    and session filenames come from `fs.readdir()` results under the controlled base path. No user
    input is ever concatenated into file paths without going through path.join(). No shell
    execution is used for file I/O.

  - **Symlink handling:** `fs.stat()` follows symlinks (reports target file stats). Since all
    paths are constructed under the user's own `~/.claude/` directory, a symlink escape would
    require prior filesystem compromise. The implementation does not follow symlinks outside
    the base path by construction.

  - **No shell execution:** All file I/O uses Node.js `fs` APIs directly. No spawned subprocesses,
    no shell command interpolation, no template strings used as shell commands.

  - **Scope:** Session files contain potentially sensitive conversation history belonging to the
    current user (same permission scope as Claude Code itself). The repository only reads — it
    never writes, transmits, or exposes data outside the current terminal session.

  ## Performance Implications

  - **NFR-1 target:** Under 2 seconds for 500+ sessions with default --limit 20.
  - **Actual scale:** 1,140 session files across 119 project directories on dev machine.
  - **Stat-first:** ~1,140 parallel stat syscalls via Promise.allSettled() ≈ 50-200ms on SSD.
  - **Read phase:** 20 JSONL files averaging ~250KB each ≈ 5MB total reads ≈ 100-500ms.
  - **Total estimated:** 150-700ms — comfortably under the 2-second target.
  - **Memory:** Only top-N sessions held in memory. --limit 0 (all) scales linearly — acceptable.

  ## Architecture Notes

  Feature maps cleanly to existing Clean Architecture layers:

  ```
  Presentation (CLI commands/session/)
    → resolves ListAgentSessionsUseCase / GetAgentSessionUseCase via DI container

  Application (use-cases/agents/ + ports/output/agents/)
    → ListAgentSessionsUseCase, GetAgentSessionUseCase
    → IAgentSessionRepository port interface
    → AgentSessionRepositoryRegistry (also application-layer service)

  Infrastructure (services/agents/sessions/)
    → ClaudeCodeSessionRepository (reads ~/.claude/projects/ JSONL)
    → StubSessionRepository (cursor-cli, gemini-cli)

  Domain (TypeSpec-generated)
    → AgentSession, AgentSessionMessage, AgentFeature.sessionListing
  ```

  **Extensibility (NFR-5):** Adding a real Cursor or Gemini implementation requires only:
  1. Implement `IAgentSessionRepository` in a new infrastructure class
  2. Replace the stub registration in container.ts with the real class
  3. Set `supportsFeature("session-listing")` to true on the executor service
  No use case, port interface, or CLI command changes needed.
