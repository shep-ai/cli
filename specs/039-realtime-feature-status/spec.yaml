# Feature Specification (YAML)
# This is the source of truth. Markdown is auto-generated from this file.

name: realtime-feature-status
number: 039
branch: feat/realtime-feature-status
oneLiner: Real-time agent event streaming to the web UI via DB-polling SSE, Service Worker, and notification infrastructure
userQuery: >
  Feature: When feature status is updating real time update the UI.
  We already have SSE we can reuse them.
summary: >
  Build the real-time notification infrastructure that streams agent lifecycle events
  (status transitions, phase completions) from the backend to the web UI. The SSE route
  polls the database directly (avoiding cross-module singleton issues with Next.js
  Turbopack), a Service Worker multiplexes a single SSE connection across browser tabs,
  and a React hook delivers events to UI components. Backend services (NotificationBus,
  NotificationWatcherService) detect status transitions via DB polling and dispatch
  NotificationEvent objects. Both the CLI `shep ui` command and the dev-server initialize
  the watcher on startup.
phase: Implementation
sizeEstimate: M

relatedFeatures: []

technologies:
  - Next.js 16+ (App Router, route handlers, force-dynamic)
  - React 19 (hooks, useCallback, useEffect, useRef, useState)
  - Server-Sent Events (EventSource API, ReadableStream)
  - Service Workers (message passing, lifecycle events)
  - Node.js EventEmitter (typed, globalThis singleton)
  - TypeSpec-generated NotificationEvent model
  - tsyringe DI container
  - SQLite (agent_runs, phase_timings tables)

relatedLinks: []

openQuestions: []

content: |
  ## Problem Statement

  The web UI control center needs real-time updates when agent status changes (e.g.,
  agent starts running, completes a phase, fails, or requires approval). Without
  real-time events, users must manually refresh to see status changes.

  **Key challenge**: Next.js Turbopack bundles route handlers and server-side code
  into separate module contexts, breaking in-process EventEmitter singletons. An
  event bus created in one module context is invisible to route handlers in another.

  **Solution**: The SSE route polls the database directly instead of relying on an
  in-process event bus for cross-module communication. A per-connection cache ensures
  only deltas (status changes, new phase completions) are streamed to clients.
  A Service Worker multiplexes a single SSE connection across all open browser tabs
  to avoid redundant connections.

  ## Success Criteria

  - [x] SSE endpoint at GET /api/agent-events streams NotificationEvent objects
  - [x] Per-connection cache tracks last-seen state; only deltas are emitted
  - [x] Optional ?runId query parameter filters events to a specific agent run
  - [x] Heartbeat comments sent every 30s to keep connection alive
  - [x] Service Worker maintains single SSE connection shared across tabs
  - [x] Service Worker broadcasts events and connection status to all tabs
  - [x] React hook (useAgentEvents) uses SW with direct EventSource fallback
  - [x] Exponential backoff reconnection with stable-connection reset
  - [x] NotificationBus provides typed EventEmitter singleton via globalThis
  - [x] NotificationWatcherService polls DB for status transitions and phase completions
  - [x] CLI `shep ui` command initializes and starts the notification watcher
  - [x] Dev-server initializes and starts the notification watcher
  - [x] Graceful shutdown stops the watcher in both CLI and dev-server
  - [x] Unit tests cover NotificationWatcherService status/phase detection
  - [x] Unit tests cover useAgentEvents hook (SW path and fallback path)
  - [x] Integration tests cover SSE endpoint streaming behavior

  ## Functional Requirements

  - **FR-1: SSE Endpoint** — GET /api/agent-events streams Server-Sent Events with
    `event: notification` type. Each event data is a JSON-serialized NotificationEvent.
    Uses DB polling (500ms interval) with per-connection cache to emit only deltas.

  - **FR-2: Status Change Detection** — When an agent run's status changes (e.g.,
    pending → running, running → completed), emit the corresponding NotificationEvent
    with mapped eventType and severity.

  - **FR-3: Phase Completion Detection** — When a phase timing record gains a
    completedAt timestamp, emit a PhaseCompleted NotificationEvent with the phase name.

  - **FR-4: Connection Management** — Heartbeat comments every 30s keep connections
    alive. Client disconnect triggers cleanup of polling intervals and stream closure.

  - **FR-5: Service Worker Multiplexing** — A Service Worker (agent-events-sw.js)
    maintains a single SSE connection and broadcasts events to all connected tabs via
    postMessage. Subscribers register via { type: 'subscribe', runId? } messages.
    Connection starts on first subscriber, closes when last subscriber leaves.

  - **FR-6: React Hook** — useAgentEvents() returns { events, lastEvent, connectionStatus }.
    Uses Service Worker when available, falls back to direct EventSource. Both paths
    implement exponential backoff reconnection (1s base, 30s max) with stable-connection
    reset after 5 seconds.

  - **FR-7: Notification Watcher** — NotificationWatcherService polls agent_runs table,
    tracks per-run state (status + completed phases), emits NotificationEvents through
    INotificationService. Tracks active runs and cleans up terminal ones.

  - **FR-8: Notification Bus** — Typed EventEmitter singleton stored on globalThis via
    Symbol.for() to survive module boundary issues. Provides pub/sub for notification
    fan-out (SSE, desktop notifications, etc.).

  ## Non-Functional Requirements

  - **NFR-1: No Cross-Module Singleton Issues** — SSE route polls DB directly instead
    of relying on in-process event bus, avoiding Turbopack module boundary problems.

  - **NFR-2: Tab Efficiency** — Service Worker ensures only one SSE connection per
    browser regardless of how many tabs are open.

  - **NFR-3: Resilient Connections** — Exponential backoff with jitter prevents
    thundering herd on server restart. Stable-connection detection resets backoff.

  - **NFR-4: Clean Architecture** — NotificationWatcherService depends on repository
    interfaces (IAgentRunRepository, IPhaseTimingRepository, IFeatureRepository) and
    INotificationService. No direct DB access.

  - **NFR-5: Testability** — All services are constructor-injectable. NotificationBus
    and NotificationWatcher have reset functions for test isolation.

  ## Affected Areas

  | Area | Impact | Reasoning |
  | ---- | ------ | --------- |
  | `src/presentation/web/app/api/agent-events/route.ts` | High | Rewritten: DB-polling SSE with per-connection cache |
  | `src/presentation/web/public/agent-events-sw.js` | High | New: Service Worker for SSE multiplexing across tabs |
  | `src/presentation/web/hooks/use-agent-events.ts` | High | Rewritten: SW-first with EventSource fallback |
  | `packages/core/src/infrastructure/services/notifications/notification-bus.ts` | High | New: typed EventEmitter singleton on globalThis |
  | `packages/core/src/infrastructure/services/notifications/notification-watcher.service.ts` | High | New: DB-polling status/phase change detector |
  | `src/presentation/cli/commands/ui.command.ts` | Medium | Modified: initializes notification watcher on startup |
  | `src/presentation/web/dev-server.ts` | Medium | Modified: initializes notification watcher on startup |

  ## Dependencies

  **Existing infrastructure used**:
  - NotificationEvent TypeSpec model (eventType, agentRunId, featureName, phaseName, severity)
  - IAgentRunRepository, IPhaseTimingRepository, IFeatureRepository interfaces
  - INotificationService interface
  - tsyringe DI container
  - AgentRunStatus, NotificationEventType, NotificationSeverity enums
