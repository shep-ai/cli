# Implementation Plan (YAML)
# This is the source of truth. Markdown is auto-generated from this file.

name: realtime-feature-status
summary: >
  Build real-time agent event streaming from backend to web UI. Phase 1 creates the
  notification infrastructure (NotificationBus, NotificationWatcherService) with tests.
  Phase 2 rewrites the SSE endpoint to use DB polling with per-connection cache. Phase 3
  adds the Service Worker and rewrites the React hook. Phase 4 integrates the watcher
  into server startup (CLI + dev-server) and validates.

relatedFeatures: []

technologies:
  - 'Node.js EventEmitter (typed)'
  - 'Server-Sent Events (ReadableStream)'
  - 'Service Workers'
  - 'React 19'
  - 'Next.js 16+'
  - 'tsyringe DI'
  - 'Vitest'

relatedLinks: []

phases:
  - id: phase-1
    name: 'Notification Infrastructure (TDD)'
    description: >
      Create NotificationBus (typed EventEmitter singleton on globalThis) and
      NotificationWatcherService (DB-polling status/phase change detector). Write
      tests first for the watcher service covering status transitions, phase
      completions, terminal run cleanup, and feature name resolution.
    parallel: false

  - id: phase-2
    name: 'SSE Endpoint Rewrite (TDD)'
    description: >
      Rewrite GET /api/agent-events to poll the database directly instead of
      subscribing to the event bus. Implement per-connection cache with delta
      detection. Add heartbeat, runId filtering, and cleanup on disconnect.
      Write integration tests for SSE streaming behavior.
    parallel: false

  - id: phase-3
    name: 'Service Worker + React Hook'
    description: >
      Create agent-events-sw.js Service Worker for SSE connection multiplexing
      across browser tabs. Rewrite useAgentEvents hook to use SW with direct
      EventSource fallback. Both paths implement exponential backoff reconnection.
      Write unit tests for the hook.
    parallel: false

  - id: phase-4
    name: 'Server Startup Integration + Validation'
    description: >
      Integrate NotificationWatcherService into CLI ui command and dev-server
      startup. Add graceful shutdown. Run full test suite, typecheck, and lint.
    parallel: false

filesToCreate:
  - packages/core/src/infrastructure/services/notifications/notification-bus.ts
  - packages/core/src/infrastructure/services/notifications/notification-watcher.service.ts
  - src/presentation/web/public/agent-events-sw.js

filesToModify:
  - src/presentation/web/app/api/agent-events/route.ts
  - src/presentation/web/hooks/use-agent-events.ts
  - src/presentation/web/dev-server.ts
  - src/presentation/cli/commands/ui.command.ts
  - tests/unit/infrastructure/services/notifications/notification-watcher.service.test.ts
  - tests/unit/presentation/web/hooks/use-agent-events.test.ts
  - tests/unit/presentation/cli/commands/ui.command.test.ts
  - tests/integration/api/agent-events-sse.test.ts

openQuestions: []

content: |
  ## Architecture Overview

  Two independent paths deliver real-time events:

  **Path 1: CLI/Backend notifications** (NotificationWatcherService → NotificationBus)
  - Polls agent_runs table every 3 seconds
  - Detects status changes and phase completions
  - Emits NotificationEvents through INotificationService
  - Used for desktop notifications, CLI output, etc.

  **Path 2: Web UI streaming** (SSE route → Service Worker → React hook)
  - SSE route polls DB every 500ms per connection
  - Per-connection cache ensures only deltas are sent
  - Service Worker multiplexes single connection across tabs
  - React hook provides { events, lastEvent, connectionStatus }

  Both paths read from the same DB tables but operate independently to avoid
  cross-module singleton issues with Next.js Turbopack.

  ## Key Design Decisions

  ### 1. DB Polling Over Event Bus in SSE Route
  Next.js Turbopack creates separate module contexts for route handlers. An
  EventEmitter singleton in one context is invisible to another. The SSE route
  polls the DB directly, making it fully self-contained.

  ### 2. Per-Connection Cache with Seed-Then-Delta
  On first observation, a feature's state is cached without emitting an event.
  Subsequent polls emit only when status changes or new phases complete. This
  prevents initial event bursts when a client connects.

  ### 3. Service Worker Over SharedWorker
  Service Workers have broader browser support (including Safari iOS) and
  persist across page navigations. The SW manages SSE lifecycle (subscribe/
  unsubscribe) based on active tab count.

  ### 4. globalThis Singleton for NotificationBus
  Symbol.for() key on globalThis survives Turbopack module duplication.
  Reset function provided for test isolation.

  ## Risk Mitigation

  | Risk | Mitigation |
  | ---- | ---------- |
  | Turbopack module isolation breaks singletons | SSE route polls DB directly; NotificationBus uses globalThis |
  | Multiple tabs create redundant SSE connections | Service Worker multiplexes to single connection |
  | SSE connection drops silently | Heartbeat every 30s; exponential backoff reconnection |
  | DB polling load from many connections | Single-user tool; SW reduces to 1 connection; 500ms interval acceptable |
  | Service Worker not available (HTTP, old browser) | Graceful fallback to direct EventSource |
