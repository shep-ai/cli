# Task Breakdown (YAML)
# This is the source of truth. Markdown is auto-generated from this file.

name: realtime-feature-status
summary: >
  7 tasks across 4 phases. Phase 1 builds the notification infrastructure (bus + watcher)
  with tests. Phase 2 rewrites the SSE endpoint with DB polling. Phase 3 adds the Service
  Worker and rewrites the React hook. Phase 4 integrates into server startup and validates.

relatedFeatures: []
technologies:
  - 'Node.js EventEmitter'
  - 'Server-Sent Events'
  - 'Service Workers'
  - 'React 19'
  - 'Next.js 16+'
  - 'tsyringe'
  - 'Vitest'
relatedLinks: []

tasks:
  - id: task-1
    phaseId: phase-1
    title: 'Create NotificationBus typed EventEmitter singleton'
    description: >
      Create notification-bus.ts with a typed EventEmitter singleton stored on globalThis
      via Symbol.for(). Exports getNotificationBus() for lazy access and
      resetNotificationBus() for test isolation.
    state: Done
    dependencies: []
    acceptanceCriteria:
      - 'NotificationBus type exported as EventEmitter<NotificationEventMap>'
      - 'getNotificationBus() returns the same instance across calls'
      - 'globalThis storage via Symbol.for() survives module duplication'
      - 'resetNotificationBus() removes all listeners and clears instance'
    tdd:
      red:
        - 'Test getNotificationBus() returns same instance across multiple calls'
        - 'Test resetNotificationBus() clears the singleton'
      green:
        - 'Implement globalThis-based singleton with Symbol.for key'
      refactor:
        - 'Ensure JSDoc comments describe the cross-module singleton pattern'
    estimatedEffort: '15min'

  - id: task-2
    phaseId: phase-1
    title: 'Create NotificationWatcherService with tests'
    description: >
      Create notification-watcher.service.ts that polls agent_runs table, tracks per-run
      state (status + completed phases), and emits NotificationEvents through
      INotificationService. Includes singleton accessors (initialize/get/has/reset).
      Write comprehensive tests covering status transitions, phase completions,
      terminal run cleanup, and feature name resolution.
    state: Done
    dependencies:
      - task-1
    acceptanceCriteria:
      - 'Polls via setInterval with configurable interval'
      - 'Tracks active runs (pending, running, waitingApproval) in Map'
      - 'Emits status events on AgentRunStatus transitions'
      - 'Emits PhaseCompleted events on new phase_timings.completedAt'
      - 'Cleans up terminal runs after emitting final event'
      - 'resolveFeatureName falls back to Agent ${id} on error'
      - 'Singleton pattern: initialize/get/has/reset functions'
      - 'start()/stop() lifecycle with isRunning() check'
      - 'Unit tests cover all status transitions and phase detection'
    tdd:
      red:
        - 'Test status change detection (running → completed, etc.)'
        - 'Test phase completion detection via completedAt'
        - 'Test terminal run cleanup'
        - 'Test feature name resolution with fallback'
        - 'Test singleton lifecycle (initialize, get, reset)'
      green:
        - 'Implement polling loop with per-run state tracking'
        - 'Implement STATUS_TO_EVENT mapping and emitStatusEvent'
        - 'Implement checkPhaseCompletions'
        - 'Implement singleton accessors'
      refactor:
        - 'Extract constants (ACTIVE_STATUSES, TERMINAL_STATUSES, EVENT_MESSAGES)'
    estimatedEffort: '45min'

  - id: task-3
    phaseId: phase-2
    title: 'Rewrite SSE endpoint with DB polling and per-connection cache'
    description: >
      Rewrite GET /api/agent-events to poll the database directly using
      ListFeaturesUseCase, IAgentRunRepository, and IPhaseTimingRepository.
      Implement per-connection cache (Map<featureId, CachedFeatureState>) that
      seeds on first observation and emits only deltas. Add heartbeat, runId
      filtering, and abort signal cleanup.
    state: Done
    dependencies:
      - task-1
    acceptanceCriteria:
      - 'Route handler creates ReadableStream with DB polling'
      - 'Per-connection cache seeds on first feature observation (no initial burst)'
      - 'Status changes emit mapped NotificationEvent with correct eventType/severity'
      - 'Phase completions emit PhaseCompleted events'
      - 'Optional ?runId query parameter filters events'
      - 'Heartbeat comments every 30s'
      - 'Cleanup on request.signal abort'
      - 'Integration tests verify SSE streaming behavior'
    tdd:
      red:
        - 'Integration test: SSE connection receives notification events'
        - 'Integration test: runId filtering works correctly'
      green:
        - 'Implement ReadableStream with poll loop and cache'
        - 'Implement STATUS_TO_EVENT mapping and resultToPhase helper'
      refactor:
        - 'Remove debug logging (dbg helper)'
    estimatedEffort: '30min'

  - id: task-4
    phaseId: phase-3
    title: 'Create Service Worker for SSE multiplexing'
    description: >
      Create agent-events-sw.js that maintains a single EventSource connection
      and broadcasts events to all open tabs via clients.matchAll(). Handles
      subscribe/unsubscribe messages from tabs. Opens connection on first
      subscriber, closes on last. Implements exponential backoff reconnection.
    state: Done
    dependencies:
      - task-3
    acceptanceCriteria:
      - 'SW registers with skipWaiting and clients.claim()'
      - 'Opens EventSource on first subscribe message'
      - 'Closes EventSource when subscriber count reaches 0'
      - 'Broadcasts { type: notification, data } to all tabs'
      - 'Broadcasts { type: status, status } on connection changes'
      - 'Exponential backoff: 1s base, 30s max, reset after 5s stable'
      - 'Sends current status to new subscribers immediately'
    tdd: null
    estimatedEffort: '20min'

  - id: task-5
    phaseId: phase-3
    title: 'Rewrite useAgentEvents hook with SW support and fallback'
    description: >
      Rewrite useAgentEvents to use the Service Worker as primary transport.
      Falls back to direct EventSource when SW is unavailable. Both paths
      implement exponential backoff reconnection. Returns { events, lastEvent,
      connectionStatus }. Write unit tests for both paths.
    state: Done
    dependencies:
      - task-4
    acceptanceCriteria:
      - 'Attempts SW registration first'
      - 'Falls back to direct EventSource on SW failure'
      - 'SW path: subscribe/unsubscribe via postMessage'
      - 'Fallback path: exponential backoff (1s base, 30s max)'
      - 'Returns { events, lastEvent, connectionStatus }'
      - 'Cleanup on unmount (unsubscribe SW or close EventSource)'
      - 'Unit tests cover SW path and fallback path'
    tdd:
      red:
        - 'Test hook returns disconnected initially'
        - 'Test SW registration and subscription'
        - 'Test EventSource fallback when SW unavailable'
        - 'Test event accumulation and lastEvent tracking'
      green:
        - 'Implement SW registration with activate/statechange handling'
        - 'Implement connectDirectEventSource fallback'
      refactor:
        - 'Extract backoff constants to module level'
    estimatedEffort: '30min'

  - id: task-6
    phaseId: phase-4
    title: 'Integrate notification watcher into CLI and dev-server startup'
    description: >
      Add NotificationWatcherService initialization to both the CLI ui command
      and the dev-server. Resolve repositories from DI container, initialize
      and start the watcher. Add graceful shutdown (stop watcher on SIGINT/SIGTERM).
      Update existing tests to account for new initialization.
    state: Done
    dependencies:
      - task-2
    acceptanceCriteria:
      - 'CLI ui command initializes and starts watcher after web server starts'
      - 'Dev-server initializes and starts watcher after DI container setup'
      - 'Both stop the watcher on graceful shutdown'
      - 'ui.command.test.ts updated for watcher initialization'
    tdd:
      red:
        - 'Test ui command initializes notification watcher'
        - 'Test shutdown stops the watcher'
      green:
        - 'Add watcher initialization after container.resolve calls'
        - 'Add getNotificationWatcher().stop() to shutdown handlers'
      refactor:
        - 'Ensure consistent initialization pattern between CLI and dev-server'
    estimatedEffort: '20min'

  - id: task-7
    phaseId: phase-4
    title: 'Validate: run tests, typecheck, and lint'
    description: >
      Run the full test suite, type checker, and linter to verify no regressions.
      Confirm all new and existing tests pass.
    state: Done
    dependencies:
      - task-3
      - task-5
      - task-6
    acceptanceCriteria:
      - 'pnpm test passes — all unit and integration tests green'
      - 'pnpm typecheck passes'
      - 'pnpm typecheck:web passes'
      - 'pnpm lint passes'
    tdd: null
    estimatedEffort: '10min'

totalEstimate: '2h 50min'
openQuestions: []

content: |
  ## Summary

  The implementation follows a bottom-up approach across 4 phases and 7 tasks. Phase 1
  builds the notification infrastructure (bus + watcher service) with comprehensive tests.
  Phase 2 rewrites the SSE endpoint to poll the DB directly, avoiding cross-module
  singleton issues. Phase 3 adds the Service Worker for tab multiplexing and rewrites
  the React hook. Phase 4 integrates everything into server startup and validates.

  Files created: 3 (notification-bus.ts, notification-watcher.service.ts, agent-events-sw.js)
  Files modified: 7 (route.ts, use-agent-events.ts, dev-server.ts, ui.command.ts, + 3 test files)
