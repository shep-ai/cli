# Task Breakdown (YAML)
# This is the source of truth. Markdown is auto-generated from this file.

name: hitl-approval-gates
summary: Task breakdown for 016-hitl-approval-gates

# Relationships
relatedFeatures:
  - '008-agent-configuration'
  - '013-feature-agent'
technologies:
  - TypeSpec
  - TypeScript
  - LangGraph
  - Commander.js
  - better-sqlite3
  - tsyringe
relatedLinks: []

# Structured task list — this is the single source of truth for tasks.
# The content field below is a summary only; it does NOT duplicate task details.
tasks:
  # ── Phase 1: TypeSpec Models & Code Generation (Foundation, no tests) ──

  - id: task-1
    title: Create ApprovalGates and PhaseTiming TypeSpec models
    description: >
      Define ApprovalGates as a plain value object (allowPrd: boolean,
      allowPlan: boolean) in tsp/agents/approval-gates.tsp. Define PhaseTiming
      extending BaseEntity (agentRunId, phase, startedAt, completedAt?,
      durationMs?) in tsp/agents/phase-timing.tsp. Import both in
      tsp/agents/index.tsp.
    state: Todo
    dependencies: []
    acceptanceCriteria:
      - ApprovalGates model compiles with two boolean fields
      - PhaseTiming model compiles extending BaseEntity with all specified fields
      - Both models imported in tsp/agents/index.tsp
    tdd: null # Foundation — pure code generation
    estimatedEffort: S

  - id: task-2
    title: Update AgentRun TypeSpec model and compile
    description: >
      In tsp/agents/agent-run.tsp, replace approvalMode?: string and
      approvalStatus?: string with approvalGates?: ApprovalGates. Run
      pnpm tsp:compile. Verify generated output.ts contains ApprovalGates
      type and updated AgentRun interface.
    state: Todo
    dependencies:
      - task-1
    acceptanceCriteria:
      - AgentRun no longer has approvalMode or approvalStatus string fields
      - AgentRun has approvalGates?: ApprovalGates field
      - pnpm tsp:compile succeeds without errors
      - src/domain/generated/output.ts contains ApprovalGates interface
    tdd: null # Foundation — pure code generation
    estimatedEffort: S

  # ── Phase 2: Database Migration & Phase Timing Repository (TDD) ──

  - id: task-3
    title: Migration 008, PhaseTimingRepository, and AgentRun mapper update
    description: >
      Add migration 008: ALTER TABLE agent_runs ADD COLUMN approval_gates TEXT
      with UPDATE statements transforming approval_mode strings to JSON. CREATE
      TABLE phase_timings with proper indexes. Create IPhaseTimingRepository
      port interface (save, update, findByRunId, findByFeatureId). Implement
      SQLitePhaseTimingRepository. Update AgentRunRepository mapper to
      serialize/deserialize approval_gates JSON column. Register in DI container.
    state: Todo
    dependencies:
      - task-2
    acceptanceCriteria:
      - Migration 008 adds approval_gates column and creates phase_timings table
      - Existing approval_mode values transformed to JSON correctly
      - IPhaseTimingRepository interface with save, update, findByRunId, findByFeatureId
      - SQLitePhaseTimingRepository passes all repository tests
      - AgentRunRepository reads/writes approval_gates as JSON
      - PhaseTimingRepository registered in DI container
    tdd:
      red:
        - Write integration tests for SQLitePhaseTimingRepository (save, findByRunId, findByFeatureId)
        - Write integration tests for AgentRunRepository approval_gates serialization
        - Write migration test verifying data transformation from approval_mode strings
      green:
        - Implement IPhaseTimingRepository interface
        - Implement SQLitePhaseTimingRepository with SQL queries
        - Write migration 008 SQL
        - Update AgentRunRepository mapper for approval_gates
      refactor:
        - Extract shared mapper helpers if patterns emerge
        - Ensure consistent error handling in repository methods
    estimatedEffort: L

  # ── Phase 3: Agent System Core — ApprovalGates & Phase Timing (TDD) ──

  - id: task-4
    title: Refactor shouldInterrupt() and update worker/process service
    description: >
      Refactor shouldInterrupt() in node-helpers.ts to accept ApprovalGates
      instead of string. Replace AUTO_APPROVED_NODES lookup table with direct
      boolean checks. Update FeatureAgentState to use approvalGates instead of
      approvalMode. Update worker to parse --approval-gates JSON arg. Update
      process service to pass --approval-gates JSON in spawn().
    state: Todo
    dependencies:
      - task-2
    acceptanceCriteria:
      - shouldInterrupt() accepts ApprovalGates?, returns boolean
      - Requirements node interrupts when !gates.allowPrd
      - Plan node interrupts when !gates.allowPlan
      - Other nodes never interrupt
      - No gates (undefined) means no interrupts
      - AUTO_APPROVED_NODES map deleted
      - Worker parses --approval-gates JSON correctly
      - Process service passes --approval-gates JSON string
      - FeatureAgentState.approvalGates replaces approvalMode
    tdd:
      red:
        - Write tests for shouldInterrupt() with all ApprovalGates combinations
        - Write tests for undefined gates (backward compat)
        - Write tests for worker --approval-gates arg parsing
      green:
        - Implement shouldInterrupt() with boolean checks
        - Update FeatureAgentState annotation
        - Update worker parseWorkerArgs() for --approval-gates
        - Update process service spawn() args
      refactor:
        - Remove all traces of approval_mode string handling
        - Clean up imports of removed constants
    estimatedEffort: M

  - id: task-5
    title: Add phase timing recording to executeNode()
    description: >
      Add optional IPhaseTimingRepository parameter to executeNode(). On node
      entry, save a PhaseTiming record with startedAt. On success, update with
      completedAt and durationMs. On error, leave completedAt null (partial
      timing). When repository is not provided, skip timing (backward compat).
    state: Todo
    dependencies:
      - task-3
      - task-4
    acceptanceCriteria:
      - executeNode() accepts optional IPhaseTimingRepository parameter
      - Timing record saved with startedAt on node entry
      - Timing record updated with completedAt + durationMs on success
      - Partial timing (no completedAt) preserved on error
      - No timing when repository is not provided
      - Existing tests pass without providing repository
    tdd:
      red:
        - Write tests for executeNode() with mock IPhaseTimingRepository
        - Test timing save on entry, update on success, partial on error
        - Test no-op when repository is undefined
      green:
        - Add repository parameter to executeNode()
        - Add save() call at entry, update() call at exit
        - Handle error case for partial timing
      refactor:
        - Extract timing helper if logic becomes complex
    estimatedEffort: M

  # ── Phase 4: Application Layer — Use Case Updates (TDD) [P] ──

  - id: task-6
    title: Update CreateFeatureUseCase for ApprovalGates
    description: >
      Change CreateFeatureInput.approvalMode?: string to
      approvalGates?: ApprovalGates. Update the use case to pass the
      ApprovalGates object through to RunAgentUseCase and ultimately
      to the process service. Ensure backward compatibility when
      approvalGates is undefined (no gates = autonomous).
    state: Todo
    dependencies:
      - task-4
    acceptanceCriteria:
      - CreateFeatureInput accepts approvalGates?: ApprovalGates
      - ApprovalGates passed through to RunAgentUseCase
      - Undefined approvalGates results in autonomous behavior
      - No reference to approvalMode string in create-feature flow
    tdd:
      red:
        - Write tests for CreateFeatureUseCase with ApprovalGates input
        - Test that gates are passed through to agent run creation
        - Test undefined gates behavior
      green:
        - Update CreateFeatureInput type
        - Update use case execute() to pass approvalGates
      refactor:
        - Remove any leftover approvalMode references in use case chain
    estimatedEffort: S

  - id: task-7
    title: Create resolveWaitingFeature() helper
    description: >
      Create a shared helper function in
      src/presentation/cli/commands/feat/resolve-waiting-feature.ts. Given an
      optional feature ID and current repo path, resolve the target feature
      waiting for approval. If ID provided, look it up directly. If omitted,
      list features for the repo, find their agent runs, filter to
      waiting_approval status. Return the feature if exactly one match. Error
      with helpful message if zero or multiple.
    state: Todo
    dependencies:
      - task-3
    acceptanceCriteria:
      - Returns single waiting feature when exactly one exists
      - Uses provided ID directly when given
      - Errors with "No features waiting for approval" when none found
      - Errors listing waiting features when multiple found
      - Scoped to current repository (not global)
    tdd:
      red:
        - Write tests for auto-resolve with 0, 1, 2+ waiting features
        - Write tests for explicit ID lookup
        - Write tests for repo-scoped resolution
      green:
        - Implement resolveWaitingFeature() with ListFeaturesUseCase + agent run queries
        - Return feature or throw descriptive error
      refactor:
        - Ensure error messages include actionable instructions
    estimatedEffort: M

  # ── Phase 5: New CLI Commands — feat review/approve/reject (TDD) [P] ──

  - id: task-8
    title: Create feat review command
    description: >
      Add createReviewCommand() in review.command.ts. Accepts optional [id]
      argument. Uses resolveWaitingFeature() to find target. Shows the
      feature's current waiting state, which phase triggered the interrupt,
      and the generated content (requirements or plan output). Displays
      approval instructions at the bottom.
    state: Todo
    dependencies:
      - task-7
    acceptanceCriteria:
      - feat review (no args) auto-resolves single waiting feature
      - feat review with explicit id looks up specific feature
      - Shows waiting phase and generated content
      - Displays approval/rejection instructions
      - Registered in feat/index.ts
    tdd:
      red:
        - Write tests for review command with mocked use cases
        - Test auto-resolve and explicit ID paths
        - Test output formatting
      green:
        - Implement createReviewCommand() with Commander
        - Integrate resolveWaitingFeature()
        - Format and display review output
      refactor:
        - Extract display formatting helpers if needed
    estimatedEffort: M

  - id: task-9
    title: Create feat approve command
    description: >
      Add createApproveCommand() in approve.command.ts. Accepts optional [id]
      argument. Uses resolveWaitingFeature() to find target. Delegates to
      existing ApproveAgentRunUseCase to resume the agent. Shows which phase
      was approved and what comes next.
    state: Todo
    dependencies:
      - task-7
    acceptanceCriteria:
      - feat approve (no args) auto-resolves single waiting feature
      - feat approve with explicit id looks up specific feature
      - Delegates to ApproveAgentRunUseCase
      - Shows approved phase and next step
      - Registered in feat/index.ts
    tdd:
      red:
        - Write tests for approve command with mocked use cases
        - Test auto-resolve and explicit ID paths
        - Test success output messaging
      green:
        - Implement createApproveCommand() with Commander
        - Integrate resolveWaitingFeature() and ApproveAgentRunUseCase
      refactor:
        - Ensure consistent error handling with other feat commands
    estimatedEffort: S

  - id: task-10
    title: Create feat reject command
    description: >
      Add createRejectCommand() in reject.command.ts. Accepts optional [id]
      argument and --reason <text> option. Uses resolveWaitingFeature() to
      find target. Delegates to existing RejectAgentRunUseCase to cancel
      the agent. Shows confirmation of rejection.
    state: Todo
    dependencies:
      - task-7
    acceptanceCriteria:
      - feat reject (no args) auto-resolves single waiting feature
      - feat reject with explicit id looks up specific feature
      - --reason option passed to RejectAgentRunUseCase
      - Delegates to RejectAgentRunUseCase
      - Shows rejection confirmation
      - Registered in feat/index.ts
    tdd:
      red:
        - Write tests for reject command with mocked use cases
        - Test auto-resolve and explicit ID paths
        - Test --reason option handling
      green:
        - Implement createRejectCommand() with Commander
        - Integrate resolveWaitingFeature() and RejectAgentRunUseCase
      refactor:
        - Ensure consistent error handling with other feat commands
    estimatedEffort: S

  # ── Phase 6: CLI Enhancement — feat new & feat show (TDD) [P] ──

  - id: task-11
    title: Update feat new flags and output messaging
    description: >
      In new.command.ts, remove --interactive flag. Build ApprovalGates object
      from --allow-prd, --allow-plan, --allow-all flags. Default (no flags)
      creates { allowPrd: false, allowPlan: false }. Pass ApprovalGates to
      CreateFeatureUseCase. Add output hint about approval behavior.
    state: Todo
    dependencies:
      - task-6
    acceptanceCriteria:
      - --interactive flag removed
      - No flags defaults to pause after requirements and plan
      - --allow-prd sets allowPrd to true
      - --allow-plan sets allowPlan to true
      - --allow-all sets both to true
      - --allow-prd and --allow-plan composable (both true)
      - Output shows approval behavior hint
      - ApprovalGates object passed to use case (not string)
    tdd:
      red:
        - Write tests for each flag combination to ApprovalGates mapping
        - Test default (no flags) behavior
        - Test output messaging content
      green:
        - Remove --interactive, update flag handling
        - Build ApprovalGates from flags
        - Add output hint after feature creation
      refactor:
        - Clean up any leftover approvalMode string references
    estimatedEffort: M

  - id: task-12
    title: Add phase timing breakdown and approval context to feat show
    description: >
      In show.command.ts, after existing feature display, load phase timings
      via IPhaseTimingRepository.findByRunId(). Display a timing breakdown
      table with phase names, durations, and awaiting-review indicator. When
      the feature is in waiting_approval state, show which phase is waiting
      and approval instructions.
    state: Todo
    dependencies:
      - task-5
      - task-7
    acceptanceCriteria:
      - Phase timing breakdown displayed when timings exist
      - Shows duration for completed phases
      - Shows "awaiting review" indicator for interrupted phase
      - Shows dash for unexecuted phases
      - Shows total elapsed time
      - Approval context shown when in waiting_approval state
      - Approval instructions displayed (shep feat approve/reject)
      - No timing section when no timings exist
    tdd:
      red:
        - Write tests for timing breakdown rendering with various phase states
        - Test waiting_approval context display
        - Test no-timings case (no section shown)
      green:
        - Load phase timings in show command
        - Render timing breakdown table
        - Add approval context section
      refactor:
        - Extract timing formatting into reusable helper
    estimatedEffort: M

  # ── Phase 7: YAML Validation & Auto-Repair Graph Nodes (TDD) ──

  - id: task-13
    title: Create schema validators for spec, research, plan, and tasks YAML
    description: >
      Create hand-written TypeScript validator functions in nodes/schemas/.
      Each returns {valid: boolean, errors: string[]} with specific, AI-friendly
      error messages. spec.schema.ts handles both analyze and requirements phases
      with different required fields. research.schema.ts validates decisions array.
      plan.schema.ts validates phases array and cross-validates tasks.yaml phaseIds.
    state: Todo
    dependencies:
      - task-4
    acceptanceCriteria:
      - spec schema (analyze) validates name, oneLiner, summary, phase, sizeEstimate, content, technologies[]
      - spec schema (requirements) additionally validates openQuestions[] with question/resolved/answer shape
      - research schema validates name, summary, decisions[] with title/chosen/rejected[]/rationale, content
      - plan schema validates phases[] with id/name/parallel, filesToCreate or filesToModify non-empty, content
      - tasks schema validates tasks[] with id/phaseId/title/state/acceptanceCriteria[], phaseId references valid phase
      - All validators return specific error messages (not generic)
      - ValidationResult interface exported for consumers
    tdd:
      red:
        - Write tests for each schema with valid inputs (returns valid true, errors empty)
        - Write tests for each schema with missing required fields
        - Write tests for each schema with wrong types (string where array expected)
        - Write tests for tasks schema cross-referencing plan phases
      green:
        - Implement spec schema validator (analyze + requirements phases)
        - Implement research schema validator
        - Implement plan+tasks schema validators with cross-validation
      refactor:
        - Extract shared validation helpers (requireString, requireArray, requireArrayOfShape)
    estimatedEffort: M

  - id: task-14
    title: Create validate node factory
    description: >
      Create nodes/validate.node.ts with createValidateNode(target, schemaFn)
      factory. The node reads the YAML file from specDir, runs safeYamlLoad,
      then runs the schema validator. On success resets validationRetries to 0,
      clears lastValidationErrors. On failure increments validationRetries,
      sets lastValidationErrors with error messages. State updates drive the
      conditional edge routing.
    state: Todo
    dependencies:
      - task-13
    acceptanceCriteria:
      - createValidateNode returns a LangGraph node function
      - On valid YAML sets validationRetries=0, lastValidationErrors=[]
      - On invalid YAML (parse error) sets errors with parse error message
      - On invalid YAML (schema error) sets errors with schema error messages
      - On retries >= 3 throws error (fails the run)
      - Increments validationRetries on each failure
      - Sets lastValidationTarget for repair node context
    tdd:
      red:
        - Write tests for validate node with valid YAML input
        - Write tests for validate node with unparseable YAML
        - Write tests for validate node with schema violations
        - Write tests for retry exhaustion (retries >= 3 throws)
      green:
        - Implement createValidateNode factory
        - Read file, parse, validate, update state
        - Handle parse errors vs schema errors
      refactor:
        - Extract common state update patterns
    estimatedEffort: M

  - id: task-15
    title: Create repair node factory
    description: >
      Create nodes/repair.node.ts with createRepairNode(filename, executor)
      factory. The node reads the broken YAML file, builds a focused repair
      prompt with the validation errors from state, and calls the executor
      with constrained options (maxTurns 5, write-only tools, disableMcp true).
      The executor writes the fixed file. The node returns updated state.
    state: Todo
    dependencies:
      - task-14
    acceptanceCriteria:
      - createRepairNode returns a LangGraph node function
      - Reads broken YAML content and validation errors from state
      - Builds focused repair prompt with errors + broken content
      - Calls executor with maxTurns 5 and constrained tools
      - Supports single file (spec.yaml) and multi-file (plan.yaml + tasks.yaml)
      - Logs repair attempt number
    tdd:
      red:
        - Write tests for repair node prompt construction
        - Write tests for executor options (maxTurns, tools constraint)
        - Write tests for multi-file repair (plan + tasks)
        - Write tests for state updates after repair
      green:
        - Implement createRepairNode factory
        - Build repair prompt from state
        - Call executor with constrained options
      refactor:
        - Extract prompt template as separate function for testability
    estimatedEffort: M

  - id: task-16
    title: Wire validate/repair nodes into feature-agent-graph with conditional edges
    description: >
      Update feature-agent-graph.ts to add validate and repair nodes after each
      YAML-producing node. Add conditional edges using routeValidation() factory.
      Update state.ts with validationRetries, lastValidationTarget, and
      lastValidationErrors annotations. The graph topology changes from linear
      to linear-with-validation-loops.
    state: Todo
    dependencies:
      - task-14
      - task-15
    acceptanceCriteria:
      - State annotation includes validationRetries, lastValidationTarget, lastValidationErrors
      - Graph has validate nodes after analyze, requirements, research, plan
      - Graph has repair nodes paired with each validate node
      - Conditional edges route pass to next node, fail to repair, exhausted to throw
      - routeValidation() factory produces correct routing functions
      - Graph compiles without errors
      - Existing HITL interrupt behavior preserved
    tdd:
      red:
        - Write tests for routeValidation() with pass/fail/exhausted states
        - Write tests for state annotation defaults
        - Write integration test for validate-repair loop with mocked executor
      green:
        - Add state annotation channels
        - Add all validate and repair nodes to graph
        - Wire conditional edges with routeValidation()
        - Import and configure schema validators
      refactor:
        - Group node registration by concern (producers, validators, repairers)
    estimatedEffort: L

# Total effort estimate
totalEstimate: XL (16 tasks across 7 phases)

# Open questions
openQuestions: []

# Markdown content — summary and acceptance checklist only.
# Individual task details live in the tasks[] array above (no duplication).
content: |
  ## Summary

  HITL Approval Gates + YAML Validation — 16 tasks across 7 phases.
  Covers TypeSpec models, database migration, agent system refactor,
  new CLI commands, existing command enhancements, and LangGraph
  validate-repair loops for AI-generated YAML outputs.

  ## Acceptance Checklist

  Before marking feature complete:

  - [ ] All 16 tasks completed
  - [ ] Tests passing (`pnpm test`)
  - [ ] Linting clean (`pnpm lint`)
  - [ ] Types valid (`pnpm typecheck`)
  - [ ] TypeSpec compiles (`pnpm tsp:compile`)
  - [ ] YAML validation loops tested with mock executor
  - [ ] PR created and reviewed

  ---

  _Task details are in the tasks[] array of tasks.yaml_
