# Research Artifact (YAML)
# This is the source of truth. Markdown is auto-generated from this file.

name: control-center
summary: Technical analysis for 016-control-center

# Relationships
relatedFeatures:
  - '015-feature-flow-canvas'
  - '013-ui-arch'
technologies:
  - '@xyflow/react ^12.10.0'
  - React 19
  - shadcn/ui
  - Tailwind CSS v4
relatedLinks:
  - https://reactflow.dev/api-reference/components/panel
  - https://reactflow.dev/api-reference/hooks/use-on-selection-change
  - https://reactflow.dev/learn/advanced-use/hooks-providers

# Structured technology decisions
decisions:
  - title: Canvas overlay positioning
    chosen: React Flow Panel component
    rejected:
      - Custom absolute-positioned divs
      - CSS Grid overlay layout
    rationale: >
      React Flow provides a built-in <Panel> component with 8 position slots
      (top-left, top-center, top-right, bottom-left, bottom-center, bottom-right,
      center-left, center-right). Panels render above the viewport and do not
      interfere with pan/zoom. This is the idiomatic approach used by React Flow's
      own <Controls> and <MiniMap> components. No additional dependencies needed.

  - title: State management approach
    chosen: Custom hook (useControlCenterState) with React Flow built-in hooks
    rejected:
      - Zustand store
      - React Context provider
      - Lifting state to parent page
    rationale: >
      React Flow already provides useNodesState, useEdgesState, and
      useOnSelectionChange hooks. A custom hook composing these with local
      useState for panel visibility keeps all state co-located with the
      ControlCenter component. No external state library needed. If state
      needs to be shared beyond ControlCenter later, it can be lifted to
      context without changing the hook API.

  - title: Node selection tracking
    chosen: React Flow built-in selection (selected prop) + useOnSelectionChange
    rejected:
      - Custom onNodeClick handler with manual state
      - External selection library
    rationale: >
      React Flow has built-in selection support — clicking a node sets its
      `selected` property to true. The useOnSelectionChange hook fires a
      callback with the currently selected nodes/edges. Custom nodes receive
      `selected` as a prop, which FeatureNode can use for visual highlight.
      This avoids duplicating React Flow's internal selection state.

  - title: Selected node visual highlight
    chosen: Tailwind ring utility via selected prop
    rejected:
      - CSS box-shadow
      - Separate wrapper div with border
      - Framer Motion animated border
    rationale: >
      FeatureNode already accepts props from React Flow. The `selected` prop
      is available on all custom nodes. Adding a conditional `ring-2 ring-blue-500`
      class to the card when selected is minimal, performant, and consistent
      with the existing Tailwind-based styling. No animation library needed.

  - title: Keyboard shortcuts
    chosen: Native useEffect with keydown event listener
    rejected:
      - useHotkeys library (react-hotkeys-hook)
      - React Flow built-in keyboard handling
    rationale: >
      Only one shortcut needed initially (Escape to deselect). A simple useEffect
      with addEventListener('keydown') is sufficient and avoids adding a dependency.
      React Flow's built-in keyboard handling covers node deletion via Backspace/Delete
      when deleteKeyCode is set, but Escape for panel dismissal is custom logic.
      Can migrate to a library later if shortcuts grow.

# Open questions (should be resolved by end of research)
openQuestions: []

# Markdown content (the full research document)
content: |
  ## Status

  - **Phase:** Research
  - **Updated:** 2026-02-12

  ## Technology Decisions

  ### 1. Canvas Overlay Positioning

  **Options considered:**

  1. **React Flow `<Panel>` component** — Built-in component with 8 position slots, renders above viewport
  2. **Custom absolute-positioned divs** — Manual CSS positioning over the canvas
  3. **CSS Grid overlay layout** — Grid wrapper with canvas in one cell, overlays in others

  **Decision:** React Flow `<Panel>` component

  **Rationale:** Panel is the idiomatic React Flow approach. It's used internally by `<Controls>` and `<MiniMap>`. Panels don't interfere with pan/zoom, accept standard div props for styling, and require no additional dependencies. Position slots map directly to our layout needs:
  - `top-left` → Toolbar
  - `top-right` → Detail panel
  - `bottom-left` → Status bar

  ### 2. State Management Approach

  **Options considered:**

  1. **Custom hook composing React Flow hooks** — `useControlCenterState` wrapping `useNodesState`, `useEdgesState`, `useOnSelectionChange`, plus `useState` for panel visibility
  2. **Zustand store** — External store for cross-component state
  3. **React Context provider** — Context wrapping the control center
  4. **Lift state to parent page** — Page component owns all state

  **Decision:** Custom hook (`useControlCenterState`)

  **Rationale:** React Flow already provides `useNodesState`, `useEdgesState`, and `useOnSelectionChange`. These hooks must be used inside a `<ReactFlowProvider>`. A custom hook composing them with local `useState` for panel visibility keeps state co-located and testable. No external dependency needed. The hook can be extracted to context later if state sharing becomes necessary.

  ### 3. Node Selection Tracking

  **Options considered:**

  1. **React Flow built-in selection** — Nodes have a `selected` prop set by React Flow on click
  2. **Custom `onNodeClick` handler** — Manual tracking of selected node ID in state
  3. **External selection library** — Third-party selection management

  **Decision:** React Flow built-in selection + `useOnSelectionChange`

  **Rationale:** React Flow handles selection internally — clicking a node sets `node.selected = true`. The `useOnSelectionChange` hook fires when selection changes, providing the selected nodes array. Custom nodes receive `selected` as a prop. This avoids duplicating selection state and stays in sync with React Flow's internal model. The hook callback opens/closes the detail panel.

  ### 4. Selected Node Visual Highlight

  **Options considered:**

  1. **Tailwind `ring` utility** — `ring-2 ring-blue-500` when `selected` prop is true
  2. **CSS box-shadow** — Custom shadow on selection
  3. **Wrapper div with border** — Additional DOM element
  4. **Framer Motion animated border** — Animated highlight effect

  **Decision:** Tailwind `ring-2 ring-blue-500`

  **Rationale:** FeatureNode already uses Tailwind classes and receives props from React Flow including `selected`. A conditional ring class is minimal (one `cn()` addition), performant, and visually distinct from the existing left border. No new dependencies or DOM changes needed.

  ### 5. Keyboard Shortcuts

  **Options considered:**

  1. **Native `useEffect` with `keydown` listener** — Simple event listener in custom hook
  2. **`react-hotkeys-hook` library** — Declarative hotkey binding
  3. **React Flow built-in keyboard handling** — `deleteKeyCode` prop

  **Decision:** Native `useEffect` with `keydown` listener

  **Rationale:** Only one shortcut needed initially (Escape to deselect). A `useEffect` with `addEventListener('keydown')` is 5 lines of code. Adding a library for one shortcut is unnecessary. React Flow's built-in `deleteKeyCode` handles node deletion but doesn't cover custom logic. Can revisit if shortcuts grow beyond 3-4.

  ## Library Analysis

  | Library | Version | Purpose | Status |
  | --- | --- | --- | --- |
  | `@xyflow/react` | ^12.10.0 | Canvas, Panel, selection hooks | Already installed |
  | `react-hotkeys-hook` | N/A | Keyboard shortcuts | Rejected — overkill for 1 shortcut |

  **No new dependencies required.** All decisions use existing packages (`@xyflow/react`, Tailwind CSS).

  ## Security Considerations

  No security implications identified. This feature is purely presentational UI with no backend integration, user input handling, or data persistence.

  ## Performance Implications

  - **Node enrichment memoization**: The existing `useMemo` in FeaturesCanvas for node enrichment should be preserved. The control center adds selection state which React Flow handles internally — no additional re-render overhead.
  - **Panel rendering**: React Flow Panel uses CSS positioning, not portal rendering. Panels are only re-rendered when their content changes, not on every canvas pan/zoom.
  - **useOnSelectionChange**: The callback must be memoized with `useCallback` (documented requirement from React Flow). Failure to memoize causes unnecessary re-subscriptions.

  ## Open Questions

  All questions resolved.

  ---

  _Updated by `/shep-kit:research` — proceed with `/shep-kit:plan`_
