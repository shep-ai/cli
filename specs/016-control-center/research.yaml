# Research Artifact (YAML)
# This is the source of truth. Markdown is auto-generated from this file.

name: control-center
summary: Technical analysis for 016-control-center

# Relationships
relatedFeatures:
  - '015-feature-flow-canvas'
  - '013-ui-arch'
technologies:
  - '@xyflow/react ^12.10.0'
  - React 19
  - shadcn/ui
  - Tailwind CSS v4
relatedLinks:
  - https://reactflow.dev/api-reference/components/panel
  - https://reactflow.dev/api-reference/hooks/use-on-selection-change
  - https://reactflow.dev/api-reference/hooks/use-react-flow
  - https://reactflow.dev/learn/advanced-use/hooks-providers

# Structured technology decisions
decisions:
  - title: Canvas overlay positioning
    chosen: React Flow Panel component
    rejected:
      - Custom absolute-positioned divs
      - CSS Grid overlay layout
    rationale: >
      React Flow provides a built-in <Panel> component with 8 position slots
      (top-left, top-center, top-right, bottom-left, bottom-center, bottom-right,
      center-left, center-right). Panels render above the viewport and do not
      interfere with pan/zoom. This is the idiomatic approach used by React Flow's
      own <Controls> and <MiniMap> components. No additional dependencies needed.

  - title: State management approach
    chosen: Custom hook (useControlCenterState) with React Flow built-in hooks
    rejected:
      - Zustand store
      - React Context provider
      - Lifting state to parent page
    rationale: >
      React Flow already provides useNodesState, useEdgesState, and
      useOnSelectionChange hooks. A custom hook composing these with local
      useState for panel visibility keeps all state co-located with the
      ControlCenter component. No external state library needed. If state
      needs to be shared beyond ControlCenter later, it can be lifted to
      context without changing the hook API.

  - title: Node selection tracking
    chosen: React Flow built-in selection (selected prop) + useOnSelectionChange
    rejected:
      - Custom onNodeClick handler with manual state
      - External selection library
    rationale: >
      React Flow has built-in selection support — clicking a node sets its
      `selected` property to true. The useOnSelectionChange hook fires a
      callback with the currently selected nodes/edges. Custom nodes receive
      `selected` as a prop, which FeatureNode can use for visual highlight.
      This avoids duplicating React Flow's internal selection state.

  - title: Selected node visual highlight
    chosen: Tailwind ring utility via selected prop
    rejected:
      - CSS box-shadow
      - Separate wrapper div with border
      - Framer Motion animated border
    rationale: >
      FeatureNode already accepts props from React Flow. The `selected` prop
      is available on all custom nodes. Adding a conditional `ring-2 ring-blue-500`
      class to the card when selected is minimal, performant, and consistent
      with the existing Tailwind-based styling. No animation library needed.

  - title: Keyboard shortcuts
    chosen: Native useEffect with keydown event listener
    rejected:
      - useHotkeys library (react-hotkeys-hook)
      - React Flow built-in keyboard handling
    rationale: >
      Only one shortcut needed initially (Escape to deselect). A simple useEffect
      with addEventListener('keydown') is sufficient and avoids adding a dependency.
      React Flow's built-in keyboard handling covers node deletion via Backspace/Delete
      when deleteKeyCode is set, but Escape for panel dismissal is custom logic.
      Can migrate to a library later if shortcuts grow.

  - title: Programmatic node and edge creation
    chosen: useReactFlow hook (addNodes/addEdges)
    rejected:
      - Manual setNodes/setEdges state updates
      - External graph manipulation library
    rationale: >
      React Flow provides a useReactFlow() hook with addNodes() and addEdges()
      methods that append to the existing graph without replacing state. This is
      the idiomatic approach for programmatic graph manipulation. The hook also
      provides getNode() to look up source node position for calculating new node
      placement. Using setNodes/setEdges directly requires spreading existing state
      which is error-prone. The hook is already available inside ReactFlowProvider.

  - title: New node positioning strategy
    chosen: Offset from source node position (x + 350, same y)
    rejected:
      - Random placement
      - Center of viewport
      - Auto-layout on every add
    rationale: >
      Placing the new node to the right of its source (x + 350px offset) provides
      immediate visual feedback of the parent-child relationship. The 350px offset
      accounts for node width (~288px for FeatureNode) plus spacing. If multiple
      children exist at the same position, a y-offset based on existing children
      count prevents overlap. Auto-layout on every add would be jarring and is
      out of scope. Viewport center placement loses the visual connection context.

  - title: Lifecycle phase alignment with domain
    chosen: Map FeatureLifecyclePhase 1:1 to domain SdlcLifecycle enum values
    rejected:
      - Keep UI-specific simplified phases
      - Create a separate presentation-layer enum
    rationale: >
      The UI had invented phases ('plan', 'test', 'maintenance') that don't exist
      in the domain SdlcLifecycle enum (Requirements, Research, Implementation,
      Review, Deploy & QA, Maintain). The lifecycleMap in page.tsx collapsed
      multiple domain phases into single UI phases (Research→requirements,
      Maintain→deploy), losing information. Aligning 1:1 ensures the UI always
      reflects the real domain state. A display label map handles human-readable
      names (e.g. 'maintain' displays as 'COMPLETED').

  - title: Feature state derivation from agent_runs
    chosen: LEFT JOIN features with agent_runs to derive FeatureNodeState
    rejected:
      - Read feature.yaml spec files from disk for progress
      - Hardcode all features as running
    rationale: >
      The feature-agent graph (analyze→requirements→research→plan→implement)
      updates agent_runs.status in the DB but does NOT update feature.lifecycle
      (stays at 'Requirements'). Both tables live in ~/.shep/data, so a simple
      LEFT JOIN on features.agent_run_id = agent_runs.id provides real operational
      state: pending→running, running→running, completed→done, failed→error,
      waiting_approval→action-required. Reading spec files from disk would couple
      the web UI to the filesystem and is fragile.

  - title: Agent type icon display in feature node badge
    chosen: Inline SVG components per AgentType with typed union mirroring TypeSpec enum
    rejected:
      - Lucide generic icons for all agent types
      - External icon library (react-icons)
    rationale: >
      Each agent type (claude-code, cursor, gemini-cli, aider, continue) needs a
      distinct brand icon recognizable at 14x14px. Inline SVGs keep the bundle small,
      avoid external deps, and allow currentColor inheritance for badge theming. A
      string literal union type (AgentTypeValue) mirrors the TypeSpec AgentType enum
      since the web package can't import from domain/generated due to Turbopack ESM
      incompatibility. The CometSpinner is kept as the activity indicator alongside
      the agent icon in the running state badge. The agent_runs.agent_type column
      stores the enum value per-run, so each feature knows which agent is working on it.

  - title: Maintain lifecycle semantics
    chosen: Maintain = Completed (done state, display label 'COMPLETED')
    rejected:
      - Show as 'MAINTENANCE' with running state
      - Show as 'DEPLOY' (collapse with Deploy & QA)
    rationale: >
      In the Shep platform, a feature reaching the Maintain lifecycle stage means
      it has been fully implemented, reviewed, deployed, and is now in ongoing
      support. From the control center perspective, this is a completed feature.
      Displaying it with 'COMPLETED' label and emerald done state gives clear
      visual feedback that no further agent work is needed.

  - title: Web-to-CLI data access bridge pattern
    chosen: Global DI bridge via globalThis
    rejected:
      - Direct SQL queries in web presentation layer
      - Next.js API routes with manual DB connection
      - Shared ESM module imports from CLI source
    rationale: >
      Next.js (Turbopack) cannot resolve CLI source files that use Node.js ESM
      .js extension imports. However, the web server runs in the same Node.js
      process as the CLI (WebServerService starts Next.js programmatically).
      After initializeContainer(), the CLI bootstrap exposes resolved use case
      instances via globalThis.__shepUseCases. The web layer reads these without
      importing any CLI source. Local TypeScript interfaces in the web package
      mirror the use case contracts for type safety. This preserves Clean
      Architecture (presentation calls use cases, not SQL) while respecting
      the Turbopack constraint.

# Open questions (should be resolved by end of research)
openQuestions: []

# Markdown content (the full research document)
content: |
  ## Status

  - **Phase:** Research
  - **Updated:** 2026-02-12

  ## Technology Decisions

  ### 1. Canvas Overlay Positioning

  **Options considered:**

  1. **React Flow `<Panel>` component** — Built-in component with 8 position slots, renders above viewport
  2. **Custom absolute-positioned divs** — Manual CSS positioning over the canvas
  3. **CSS Grid overlay layout** — Grid wrapper with canvas in one cell, overlays in others

  **Decision:** React Flow `<Panel>` component

  **Rationale:** Panel is the idiomatic React Flow approach. It's used internally by `<Controls>` and `<MiniMap>`. Panels don't interfere with pan/zoom, accept standard div props for styling, and require no additional dependencies. Position slots map directly to our layout needs:
  - `top-left` → Toolbar
  - `top-right` → Detail panel
  - `bottom-left` → Status bar

  ### 2. State Management Approach

  **Options considered:**

  1. **Custom hook composing React Flow hooks** — `useControlCenterState` wrapping `useNodesState`, `useEdgesState`, `useOnSelectionChange`, plus `useState` for panel visibility
  2. **Zustand store** — External store for cross-component state
  3. **React Context provider** — Context wrapping the control center
  4. **Lift state to parent page** — Page component owns all state

  **Decision:** Custom hook (`useControlCenterState`)

  **Rationale:** React Flow already provides `useNodesState`, `useEdgesState`, and `useOnSelectionChange`. These hooks must be used inside a `<ReactFlowProvider>`. A custom hook composing them with local `useState` for panel visibility keeps state co-located and testable. No external dependency needed. The hook can be extracted to context later if state sharing becomes necessary.

  ### 3. Node Selection Tracking

  **Options considered:**

  1. **React Flow built-in selection** — Nodes have a `selected` prop set by React Flow on click
  2. **Custom `onNodeClick` handler** — Manual tracking of selected node ID in state
  3. **External selection library** — Third-party selection management

  **Decision:** React Flow built-in selection + `useOnSelectionChange`

  **Rationale:** React Flow handles selection internally — clicking a node sets `node.selected = true`. The `useOnSelectionChange` hook fires when selection changes, providing the selected nodes array. Custom nodes receive `selected` as a prop. This avoids duplicating selection state and stays in sync with React Flow's internal model. The hook callback opens/closes the detail panel.

  ### 4. Selected Node Visual Highlight

  **Options considered:**

  1. **Tailwind `ring` utility** — `ring-2 ring-blue-500` when `selected` prop is true
  2. **CSS box-shadow** — Custom shadow on selection
  3. **Wrapper div with border** — Additional DOM element
  4. **Framer Motion animated border** — Animated highlight effect

  **Decision:** Tailwind `ring-2 ring-blue-500`

  **Rationale:** FeatureNode already uses Tailwind classes and receives props from React Flow including `selected`. A conditional ring class is minimal (one `cn()` addition), performant, and visually distinct from the existing left border. No new dependencies or DOM changes needed.

  ### 5. Keyboard Shortcuts

  **Options considered:**

  1. **Native `useEffect` with `keydown` listener** — Simple event listener in custom hook
  2. **`react-hotkeys-hook` library** — Declarative hotkey binding
  3. **React Flow built-in keyboard handling** — `deleteKeyCode` prop

  **Decision:** Native `useEffect` with `keydown` listener

  **Rationale:** Only one shortcut needed initially (Escape to deselect). A `useEffect` with `addEventListener('keydown')` is 5 lines of code. Adding a library for one shortcut is unnecessary. React Flow's built-in `deleteKeyCode` handles node deletion but doesn't cover custom logic. Can revisit if shortcuts grow beyond 3-4.

  ### 6. Programmatic Node and Edge Creation

  **Options considered:**

  1. **`useReactFlow` hook** — Built-in `addNodes()` and `addEdges()` methods
  2. **Manual `setNodes`/`setEdges` state updates** — Spread existing state and append
  3. **External graph manipulation library** — Third-party graph management

  **Decision:** `useReactFlow` hook (`addNodes`/`addEdges`)

  **Rationale:** React Flow provides `useReactFlow()` with `addNodes()` and `addEdges()` for appending to the graph without replacing state. The hook also exposes `getNode()` to look up the source node's position for calculating new node placement. Manual `setNodes` requires spreading existing state which is error-prone. The hook is already available inside `ReactFlowProvider`. This is needed for the contextual (+) add actions on RepositoryNode and FeatureNode.

  ### 7. New Node Positioning Strategy

  **Options considered:**

  1. **Offset from source node** — Place new node at `x + 350, same y` relative to source
  2. **Random placement** — Random position within viewport
  3. **Center of viewport** — Always place at viewport center
  4. **Auto-layout on every add** — Re-layout entire graph after each addition

  **Decision:** Offset from source node position (`x + 350`, same `y`)

  **Rationale:** Placing to the right of the source (350px offset = 288px node width + 62px gap) gives immediate visual feedback of parent-child relationship. If multiple children share the same position, a y-offset based on existing children count prevents overlap. Auto-layout on every add would be jarring. Viewport center loses the connection context.

  ## Library Analysis

  | Library | Version | Purpose | Status |
  | --- | --- | --- | --- |
  | `@xyflow/react` | ^12.10.0 | Canvas, Panel, selection hooks, useReactFlow | Already installed |
  | `react-hotkeys-hook` | N/A | Keyboard shortcuts | Rejected — overkill for 1 shortcut |

  **No new dependencies required.** All decisions use existing packages (`@xyflow/react`, Tailwind CSS).

  ## Security Considerations

  No security implications identified. This feature is purely presentational UI with no backend integration, user input handling, or data persistence.

  ## Performance Implications

  - **Node enrichment memoization**: The existing `useMemo` in FeaturesCanvas for node enrichment should be preserved. The control center adds selection state which React Flow handles internally — no additional re-render overhead.
  - **Panel rendering**: React Flow Panel uses CSS positioning, not portal rendering. Panels are only re-rendered when their content changes, not on every canvas pan/zoom.
  - **useOnSelectionChange**: The callback must be memoized with `useCallback` (documented requirement from React Flow). Failure to memoize causes unnecessary re-subscriptions.
  - **addNodes/addEdges**: These methods batch updates internally. Adding a node + edge in sequence is efficient and does not cause double renders.

  ### 8. Lifecycle Phase Alignment with Domain

  **Options considered:**

  1. **Map FeatureLifecyclePhase 1:1 to domain SdlcLifecycle** — Use matching values (requirements, research, implementation, review, deploy, maintain) with display labels
  2. **Keep UI-specific simplified phases** — Continue using invented phases ('plan', 'test', 'maintenance')
  3. **Create a separate presentation-layer enum** — New enum decoupled from domain

  **Decision:** Map 1:1 to domain SdlcLifecycle

  **Rationale:** The UI phases ('plan', 'test', 'maintenance') have no domain counterpart. The lifecycleMap collapsed Research→requirements and Maintain→deploy, losing information. A 1:1 mapping with a display label map (`maintain` → "COMPLETED", `deploy` → "DEPLOY & QA") keeps the UI accurate while providing human-readable names.

  ### 9. Feature State Derivation from agent_runs

  **Options considered:**

  1. **LEFT JOIN features with agent_runs** — Query real status from DB
  2. **Read feature.yaml from disk** — Parse spec files for progress
  3. **Hardcode all features as running** — Current approach (broken)

  **Decision:** LEFT JOIN features with agent_runs

  **Rationale:** The feature-agent graph updates `agent_runs.status` as it progresses but does NOT update `feature.lifecycle` (stays at "Requirements"). Both tables live in `~/.shep/data`. A simple SQL JOIN provides real operational state without filesystem coupling. Maps: running→running, completed→done, failed→error, waiting_approval→action-required.

  **Key finding:** Agent graph nodes do NOT update `feature.lifecycle` in the DB. The `agent_runs.status` column is the real source of truth for operational state.

  ### 10. Maintain Lifecycle Semantics

  **Decision:** Maintain = Completed (done state, "COMPLETED" display label)

  **Rationale:** A feature in the Maintain lifecycle has been fully implemented, reviewed, and deployed. From the control center perspective, this is completed work. Emerald done state gives clear visual feedback.

  ### 11. Web-to-CLI Data Access Bridge Pattern

  **Options considered:**

  1. **Global DI bridge via globalThis** — CLI exposes resolved use cases on globalThis, web reads them
  2. **Direct SQL in web layer** — Web package queries SQLite directly
  3. **Next.js API routes with manual DB** — Create /api/features that opens its own DB connection
  4. **Shared ESM module imports** — Import CLI source directly from web package

  **Decision:** Global DI bridge via globalThis

  **Rationale:** Turbopack cannot resolve .js extension imports from CLI source. Direct SQL in the web layer violates Clean Architecture. API routes with their own DB connection duplicate connection management. Since WebServerService starts Next.js in the same Node.js process, globalThis is shared. The CLI bootstrap sets globalThis.__shepUseCases with resolved instances after initializeContainer(). The web package defines local interfaces mirroring use case contracts (no CLI imports needed). This gives the web layer type-safe access to use cases without any Turbopack compatibility issues.

  ## Open Questions

  All questions resolved.

  ---

  _Updated by `/shep-kit:research` — proceed with `/shep-kit:plan`_
