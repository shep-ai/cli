# Implementation Plan (YAML)
# This is the source of truth. Markdown is auto-generated from this file.

name: control-center
summary: Implementation plan for 016-control-center

# Relationships
relatedFeatures:
  - '015-feature-flow-canvas'
  - '013-ui-arch'
  - '014-ui-sidebar'
technologies:
  - '@xyflow/react ^12.10.0'
  - React 19
  - Tailwind CSS v4
  - shadcn/ui
  - Storybook 8
  - Lucide React
relatedLinks:
  - https://reactflow.dev/api-reference/components/panel
  - https://reactflow.dev/api-reference/hooks/use-on-selection-change
  - https://reactflow.dev/api-reference/hooks/use-react-flow

# Structured implementation phases
phases:
  - id: phase-1
    name: 'Foundation'
    parallel: false
    taskIds:
      - task-1
  - id: phase-2
    name: 'Existing Component Updates'
    parallel: true
    taskIds:
      - task-2
      - task-3
  - id: phase-3
    name: 'State Management Hook'
    parallel: false
    taskIds:
      - task-4
  - id: phase-4
    name: 'Toolbar'
    parallel: false
    taskIds:
      - task-5
  - id: phase-5
    name: 'Orchestrator Integration'
    parallel: false
    taskIds:
      - task-6
  - id: phase-6
    name: 'Clean Architecture Data Layer + DI Bridge'
    parallel: false
    taskIds:
      - task-8
  - id: phase-7
    name: 'Build Validation'
    parallel: false
    taskIds:
      - task-7
  - id: phase-8
    name: 'Lifecycle Alignment'
    parallel: false
    taskIds:
      - task-9
  - id: phase-9
    name: 'Agent State E2E Verification'
    parallel: false
    taskIds:
      - task-10
  - id: phase-10
    name: 'Story Updates'
    parallel: false
    taskIds:
      - task-11
  - id: phase-11
    name: 'Feature Node Badge Improvements'
    parallel: false
    taskIds:
      - task-12
      - task-13
      - task-14

# File change tracking
filesToCreate:
  - src/presentation/web/components/features/control-center/control-center.tsx
  - src/presentation/web/components/features/control-center/control-center-inner.tsx
  - src/presentation/web/components/features/control-center/use-control-center-state.ts
  - src/presentation/web/components/features/control-center/control-center-empty-state.tsx
  - src/presentation/web/components/features/control-center/control-center-empty-state.stories.tsx
  - src/presentation/web/components/features/control-center/control-center.stories.tsx
  - src/presentation/web/components/features/control-center/index.ts
  - tests/unit/presentation/web/components/features/control-center/use-control-center-state.test.tsx
  - tests/unit/presentation/web/components/features/control-center/control-center.test.tsx
  - src/presentation/web/components/common/feature-node/agent-type-icons.tsx
  - src/presentation/web/lib/use-cases.ts # Global DI bridge — reads resolved use cases from globalThis
  - src/application/use-cases/features/list-dashboard-features.use-case.ts # New use case with agent run data
  - tests/unit/application/use-cases/features/list-dashboard-features.use-case.test.ts
  - tests/unit/infrastructure/repositories/sqlite-feature-repository-list-with-agent-runs.test.ts
  # NOTE: control-center-toolbar.tsx was created then removed — replaced by contextual node actions

filesToModify:
  - src/presentation/web/components/common/feature-node/feature-node.tsx
  - src/presentation/web/components/common/feature-node/feature-node.stories.tsx
  - src/presentation/web/components/common/feature-node/feature-node-state-config.ts
  - src/presentation/web/components/common/feature-node/index.ts
  - src/presentation/web/components/features/features-canvas/features-canvas.tsx
  - src/presentation/web/components/features/features-canvas/features-canvas.stories.tsx
  - tests/unit/presentation/web/components/features/features-canvas/features-canvas.test.tsx
  - src/presentation/web/app/page.tsx # Control Center is the homepage (/ route)
  - src/application/ports/output/repositories/feature-repository.interface.ts # Add listWithAgentRuns()
  - src/infrastructure/repositories/sqlite-feature.repository.ts # Implement listWithAgentRuns()
  - src/infrastructure/persistence/sqlite/mappers/feature.mapper.ts # Add DashboardFeature mapping
  - src/infrastructure/di/container.ts # Register ListDashboardFeaturesUseCase
  - src/presentation/cli/index.ts # Expose use cases via globalThis after initializeContainer()

filesToDelete:
  - src/presentation/web/lib/shep-data.ts # Direct filesystem access replaced by use case
  - src/presentation/web/lib/features.ts # Direct SQL replaced by DI bridge
  - src/presentation/web/app/control-center/ # Removed — control center is now the homepage (/ route)

# Open questions
openQuestions: []

# Status
status:
  phase: in-progress
  updatedAt: '2026-02-15'
  notes: 'Reopened Phase 6 and 9 — replacing direct SQL with use cases via global DI bridge'

# Markdown content (the full plan document)
content: |
  ## Status

  - **Phase:** In Progress (Phase 6 and 9 reopened)
  - **Updated:** 2026-02-15

  ## Architecture Overview

  ```
  ┌──────────────────────────────────────────────────────────────┐
  │  ControlCenter (Tier 3 orchestrator)                         │
  │  ┌────────────────────────────────────────────────────────┐  │
  │  │  <Panel position="top-left">                          │  │
  │  │    ControlCenterToolbar                                │  │
  │  │    [Add Feature] [Auto-Layout]                         │  │
  │  └────────────────────────────────────────────────────────┘  │
  │  ┌────────────────────────────────────────────────────────┐  │
  │  │                                                        │  │
  │  │  FeaturesCanvas                                        │  │
  │  │  (existing, stays pure)                                │  │
  │  │                                                        │  │
  │  │  ┌──────────┐ ┌──────────┐                             │  │
  │  │  │FeatureNode│→│FeatureNode│                           │  │
  │  │  │(selected) │ │          │                            │  │
  │  │  │ ring-2    │ │          │                            │  │
  │  │  └──────────┘ └──────────┘                             │  │
  │  │       ↑                                                │  │
  │  │  RepositoryNode                                        │  │
  │  └────────────────────────────────────────────────────────┘  │
  │                                                              │
  │  useControlCenterState (custom hook)                         │
  │  - Selection tracking (useOnSelectionChange)                 │
  │  - Keyboard shortcuts (Escape)                               │
  └──────────────────────────────────────────────────────────────┘
  ```

  ### Component Hierarchy

  ```
  Tier 3: features/control-center/     ← NEW orchestrator
              ├── composes FeaturesCanvas (Tier 3)
              ├── adds toolbar via React Flow <Panel>
              └── manages state via useControlCenterState hook

  Tier 3: features/features-canvas/    ← EXISTING (extend props)
  Tier 1: common/feature-node/         ← EXISTING (add selected ring)
  Tier 1: common/repository-node/      ← EXISTING (wire onAdd callback)
  ```

  ### Data Flow

  ```
  Props (nodes, edges, callbacks)
       │
       ▼
  ControlCenter
       │
       ├──► useControlCenterState(initialNodes, initialEdges)
       │         │
       │         ├── selectedNode (from useOnSelectionChange)
       │         ├── handleAddFeatureToRepo(repoNodeId)
       │         ├── handleAddFeatureToFeature(featureNodeId)
       │         └── handleAddFeature() (toolbar, unconnected)
       │
       ├──► FeaturesCanvas (nodes, edges, onNodeClick, onPaneClick,
       │         onNodeAction, onRepositoryAdd)
       │
       └──► ControlCenterToolbar (onAddFeature, onAutoLayout)
  ```

  ## Implementation Strategy

  **MANDATORY TDD**: All implementation phases with executable code follow RED-GREEN-REFACTOR cycles.

  ### Phase 1: Foundation (No Tests)

  **Goal:** Scaffold the control-center directory structure with empty component shells and barrel exports.

  **Steps:**

  1. Create `features/control-center/` directory with all component files
  2. Add minimal type-safe placeholder exports for each component
  3. Set up `index.ts` barrel file with all exports

  **Deliverables:** Empty scaffolded directory, compilable with `pnpm typecheck:web`

  ### Phase 2: Existing Component Updates (TDD Cycles 1-2) [P]

  **Goal:** Update FeatureNode with selection visual and extend FeaturesCanvas with interaction callbacks. These two tasks are parallelizable.

  #### 2A: FeatureNode Selected Highlight

  **TDD Workflow:**

  1. **RED:** Write test that FeatureNode renders `ring-2 ring-primary` classes when `selected` prop is true, and does NOT render them when false
  2. **GREEN:** Add conditional `ring-2 ring-primary` class to FeatureNode card wrapper using `cn()`, keyed on the `selected` prop from React Flow
  3. **REFACTOR:** Ensure ring classes integrate cleanly with existing border styles; update Storybook stories to include Selected variant

  #### 2B: FeaturesCanvas Interaction Callbacks

  **TDD Workflow:**

  1. **RED:** Write test that FeaturesCanvas passes `onNodeClick`, `onPaneClick`, `onRepositoryAdd`, and `onNodeAction` through to the underlying ReactFlow/node components
  2. **GREEN:** Add `onNodeClick`, `onPaneClick`, `onRepositoryAdd`, and `onNodeAction` to `FeaturesCanvasProps`. Wire `onRepositoryAdd` to RepositoryNode's `onAdd` and `onNodeAction` to FeatureNode's `onAction` during node enrichment.
  3. **REFACTOR:** Update type exports, verify stories still render correctly

  **Deliverables:** FeatureNode with selection ring, FeaturesCanvas with interaction and contextual add callbacks

  ### Phase 3: State Management Hook (TDD Cycles 3-4)

  **Goal:** Implement `useControlCenterState` — the central state hook for the control center, including selection tracking, keyboard shortcuts, and contextual add handlers.

  **TDD Workflow — Selection & Keyboard:**

  1. **RED:** Write tests for:
     - Returns selectedNode when a node is selected via useOnSelectionChange
     - Returns null selectedNode when selection is cleared
     - Escape keypress clears selection
  2. **GREEN:** Implement hook composing:
     - `useOnSelectionChange` for selection tracking
     - `useEffect` + `keydown` listener for Escape shortcut
     - `useCallback` for memoized event handlers
  3. **REFACTOR:** Ensure all callbacks are properly memoized

  **TDD Workflow — Contextual Add Handlers:**

  1. **RED:** Write tests for:
     - `handleAddFeatureToRepo(repoNodeId)` adds a new FeatureNode + edge to state
     - `handleAddFeatureToFeature(featureNodeId)` adds a new FeatureNode + edge to state
     - `handleAddFeature()` adds an unconnected FeatureNode to state
     - New node is positioned to the right of source node (x + 350)
     - New node is auto-selected after creation
  2. **GREEN:** Implement using `useReactFlow()`:
     - `addNodes()` to append new FeatureNode with default data
     - `addEdges()` to create source→target edge
     - `getNode()` to look up source node position for offset calculation
     - Auto-select new node via `setNodes` with `selected: true`
  3. **REFACTOR:** Extract node factory helper for default FeatureNode data, deduplicate add logic between repo/feature handlers

  **Deliverables:** Fully tested `useControlCenterState` hook with selection + contextual add

  ### Phase 4: Toolbar (TDD Cycle 4)

  **Goal:** Build the toolbar panel sub-component.

  **TDD Workflow:**

  1. **RED:** Write tests that:
     - Renders "Add Feature" button
     - Renders "Auto-Layout" button (disabled placeholder)
     - Calls `onAddFeature` callback when Add Feature clicked
  2. **GREEN:** Implement toolbar as horizontal button bar with Lucide icons (Plus, LayoutGrid), using shadcn/ui Button components inside `<Panel position="top-left">`
  3. **REFACTOR:** Add Storybook stories

  **Deliverables:** Tested and storied toolbar component

  ### Phase 5: Orchestrator Integration (TDD Cycle 6)

  **Goal:** Wire everything together in the `ControlCenter` component, including contextual add actions.

  **TDD Workflow:**

  1. **RED:** Write tests that:
     - Renders FeaturesCanvas with provided nodes and edges
     - Renders toolbar panel
     - Passes onAddFeature through to toolbar
     - Wires handleAddFeatureToRepo to FeaturesCanvas onRepositoryAdd
     - Wires handleAddFeatureToFeature to FeaturesCanvas onNodeAction
  2. **GREEN:** Implement ControlCenter composing:
     - `FeaturesCanvas` with nodes, edges, interaction callbacks, onRepositoryAdd, onNodeAction
     - `ControlCenterToolbar` with action handlers
     - All wired through `useControlCenterState`
  3. **REFACTOR:** Clean up prop threading; ensure minimal re-renders

  **Deliverables:** Full ControlCenter component with Storybook stories (Empty, WithFeatures, WithToolbar, WithNodeActions)

  ### Phase 6: Clean Architecture Data Layer + DI Bridge (TDD)

  **Goal:** Replace direct SQL in `lib/features.ts` with proper use cases accessed via global DI bridge.

  **Constraint:** Next.js (Turbopack) cannot resolve CLI source `.js` extension imports. The web server runs in the same Node.js process as the CLI, so globalThis is shared. See Research Decision #11.

  #### 6A: Repository + Use Case (TDD)

  **RED:**

  1. Write test: `IFeatureRepository.listWithAgentRuns()` returns features with agentStatus, agentError, agentResult, agentType from LEFT JOIN
  2. Write test: `ListDashboardFeaturesUseCase.execute()` returns `DashboardFeature[]` with agent data
  3. Write test: `ListDashboardFeaturesUseCase.execute({ repositoryPath })` filters correctly

  **GREEN:**

  1. Define `DashboardFeature` type (Feature fields + optional agentStatus, agentError, agentResult, agentType)
  2. Add `listWithAgentRuns(filters?)` to `IFeatureRepository` interface
  3. Implement in `SQLiteFeatureRepository` using `LEFT JOIN agent_runs ar ON f.agent_run_id = ar.id` (reuse proven SQL from current `lib/features.ts`)
  4. Create `ListDashboardFeaturesUseCase` calling `repo.listWithAgentRuns()`
  5. Register `ListDashboardFeaturesUseCase` in DI container

  **REFACTOR:**

  - Ensure mapper handles null agent_run columns cleanly
  - Verify DashboardFeature type aligns with web UI needs

  #### 6B: Global DI Bridge

  **Steps:**

  1. In CLI bootstrap (after `initializeContainer()`), expose resolved use cases via `globalThis.__shepUseCases`
  2. Create `web/lib/use-cases.ts` bridge module:
     - Define local TS interfaces mirroring use case contracts (no CLI source imports)
     - Read from `globalThis.__shepUseCases`
     - Export typed accessor functions (e.g. `getDashboardFeatures()`)
  3. Delete `web/lib/features.ts` (direct SQL access removed)
  4. Update `page.tsx` to use bridge module for data fetching
  5. `deriveState()` stays in `page.tsx` (presentation concern — maps domain data to UI state)

  **Deliverables:** Feature data flows through use cases via DI bridge; no direct SQL in presentation layer

  ### Phase 8: Lifecycle Alignment

  **Goal:** Align UI lifecycle phases with domain SdlcLifecycle 1:1 and add display labels.

  **Steps:**

  1. Update `FeatureLifecyclePhase` type: `'plan'→'research'`, `'test'→'review'`, `'maintenance'→'maintain'`
  2. Add `lifecycleDisplayLabels` map (`maintain`→"COMPLETED", `deploy`→"DEPLOY & QA", etc.)
  3. Update `feature-node.tsx` to use `lifecycleDisplayLabels[data.lifecycle]` instead of `.toUpperCase()`
  4. Export `lifecycleDisplayLabels` from `index.ts`
  5. Fix `lifecycleMap` in `page.tsx` to be 1:1 with domain

  **Deliverables:** Lifecycle phases match domain, display labels are human-readable

  ### Phase 9: Agent State E2E Verification

  **Goal:** Verify that agent run status flows correctly from DB through the use case and DI bridge to the UI.

  **Steps:**

  1. Verify `deriveState()` in `page.tsx` works with `DashboardFeature` type from bridge (not raw SQL row)
  2. Confirm all agent states display correctly: running, done, error, action-required
  3. Verify maintain lifecycle forces done state
  4. Update any tests that mock `getFeatures()` to mock the bridge module instead
  5. `pnpm build:web` passes

  **Deliverables:** Features show real operational state from agent_runs via use case (no direct SQL)

  ### Phase 10: Story Updates

  **Goal:** Update all Storybook stories with new lifecycle values.

  **Steps:**

  1. Replace old phases in all story data (`'plan'`→`'research'`, `'test'`→`'review'`, `'maintenance'`→`'maintain'`)
  2. Update `allLifecycles` array in feature-node.stories.tsx
  3. Verify AllLifecycles story shows correct display labels

  **Deliverables:** Stories reflect new lifecycle values, build passes

  ### Phase 11: Feature Node Badge Improvements (TDD Cycles)

  **Goal:** Hide featureId, add agent type icons, show lifecycle verbs in badge, keep CometSpinner.

  #### 11A: Data plumbing + Agent type icons (task-12)

  **Steps:**

  1. `agentType` already flows through `DashboardFeature` from the use case (Phase 6A LEFT JOIN includes `ar.agent_type`)
  2. Create `agent-type-icons.tsx` with `AgentTypeValue` union type mirroring TypeSpec `AgentType` enum
  3. Implement inline SVG components: `ClaudeCodeIcon`, `CursorIcon`, `GeminiCliIcon`, `AiderIcon`, `ContinueIcon`, `DefaultAgentIcon`
  4. Export `getAgentTypeIcon(agentType?)` resolver function
  5. Add `agentType?: AgentTypeValue` to `FeatureNodeData`
  6. Pass `agentType` through in `page.tsx` from bridge data

  **Deliverables:** Agent type flows from DB through use case to UI, icon components ready

  #### 11B: Badge updates (task-13)

  **TDD Workflow:**

  1. **RED:** Write tests for lifecycle running verbs, hidden featureId, agent icon rendering
  2. **GREEN:**
     - Remove featureId display from both views in `feature-node.tsx`
     - Add `lifecycleRunningVerbs` map to `feature-node-state-config.ts`
     - Update `getBadgeText` running case to use lifecycle verb
     - In running badge: `[CometSpinner] [AgentTypeIcon] {lifecycle verb}`
     - For non-running states: show agent icon (if available) before state icon
     - Remove `agentName` from `FeatureNodeData` (replaced by `agentType`)
  3. **REFACTOR:** Clean up unused imports, verify badge sizing

  **Deliverables:** Badge shows agent icon + lifecycle verb, featureId hidden

  #### 11C: Tests + Stories (task-14)

  **Steps:**

  1. Fix broken tests (featureId, badge text assertions)
  2. Add lifecycle running verb tests for all 6 phases
  3. Update all story data: replace `agentName` with `agentType`
  4. Add `AllAgentTypes` story
  5. Export `lifecycleRunningVerbs` and `getAgentTypeIcon` from `index.ts`

  **Deliverables:** All tests green, stories updated, exports clean

  ## Files to Create/Modify

  ### New Files

  | File | Purpose |
  | ---- | ------- |
  | `features/control-center/control-center.tsx` | Main orchestrator component |
  | `features/control-center/use-control-center-state.ts` | Custom hook: selection tracking |
  | `features/control-center/control-center-toolbar.tsx` | Top toolbar (add feature, auto-layout) |
  | `features/control-center/control-center.stories.tsx` | Storybook stories for orchestrator |
  | `features/control-center/index.ts` | Barrel exports |
  | `tests/.../use-control-center-state.test.ts` | Hook unit tests |
  | `tests/.../control-center-toolbar.test.tsx` | Toolbar unit tests |
  | `tests/.../control-center.test.tsx` | Orchestrator integration tests |

  ### Modified Files

  | File | Changes |
  | ---- | ------- |
  | `common/feature-node/feature-node.tsx` | Add conditional `ring-2 ring-primary` when `selected` |
  | `common/feature-node/feature-node.stories.tsx` | Add Selected story variant |
  | `features/features-canvas/features-canvas.tsx` | Add `onNodeClick`, `onPaneClick`, `onRepositoryAdd`, `onNodeAction` props; wire to node enrichment |
  | `features/features-canvas/features-canvas.stories.tsx` | Add Interactive story with callbacks |

  ## Testing Strategy (TDD: Tests FIRST)

  **CRITICAL:** Tests are written FIRST in each TDD cycle.

  ### Unit Tests (RED -> GREEN -> REFACTOR)

  Write FIRST for:
  - `useControlCenterState` hook — selection tracking, keyboard shortcuts, contextual add handlers
  - `ControlCenterToolbar` — button rendering, callback invocation
  - `FeatureNode` — selected ring visual (addition to existing tests)
  - `FeaturesCanvas` — callback prop pass-through including `onRepositoryAdd`, `onNodeAction` (addition to existing tests)

  ### Storybook Stories (Visual Verification)

  Every component has colocated stories:
  - `FeatureNode` — add Selected variant to existing stories
  - `FeaturesCanvas` — add Interactive variant with callbacks
  - `ControlCenterToolbar` — Default, WithCallbacks
  - `ControlCenter` — Empty, WithFeatures, WithToolbar, WithNodeActions

  ### E2E Tests (Stretch)

  Not required for initial implementation. Canvas interaction testing can be added post-merge.

  ## Risk Mitigation

  | Risk | Mitigation |
  | ---- | ---------- |
  | React Flow Panel conflicts with existing Controls/MiniMap | Test with Background and Controls present in stories |
  | useOnSelectionChange callback not memoized causing re-subscriptions | Wrap in useCallback per React Flow docs |
  | FeatureNode ring conflicts with existing left border | Test ring + border combination visually in Storybook |
  | New nodes overlap when adding multiple children to same parent | Y-offset based on existing children count |
  | useReactFlow must be inside ReactFlowProvider | ControlCenter wraps everything in Provider; hook used in child |

  ## Rollback Plan

  Feature is purely additive UI. Rollback by reverting the feature branch merge. No data migrations, no backend changes, no breaking API changes.

  ---

  _Updated by `/shep-kit:plan` — see tasks.md for detailed breakdown_
