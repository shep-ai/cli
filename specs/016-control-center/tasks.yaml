# Task Breakdown (YAML)
# This is the source of truth. Markdown is auto-generated from this file.

name: control-center
summary: Task breakdown for 016-control-center

# Relationships
relatedFeatures:
  - '015-feature-flow-canvas'
  - '013-ui-arch'
technologies:
  - '@xyflow/react ^12.10.0'
  - React 19
  - Tailwind CSS v4
  - shadcn/ui
  - Storybook 8
  - Lucide React
relatedLinks:
  - https://reactflow.dev/api-reference/components/panel
  - https://reactflow.dev/api-reference/hooks/use-on-selection-change

# Structured task list
tasks:
  - id: task-1
    title: 'Scaffold control-center directory structure'
    description: >
      Create the features/control-center/ directory with empty component shells,
      TypeScript interfaces, and barrel exports. All files should compile with
      pnpm typecheck:web.
    state: Done
    dependencies: []
    acceptanceCriteria:
      - 'Directory features/control-center/ exists with all 5 files'
      - 'index.ts barrel exports all components and types'
      - 'pnpm typecheck:web passes with placeholder implementations'
    tdd: null
    estimatedEffort: S

  - id: task-2
    title: 'Add selected visual highlight to FeatureNode [P]'
    description: >
      Add a ring-2 ring-primary highlight to FeatureNode when the selected prop
      is true. React Flow passes selected as a prop to all custom nodes. Update
      Storybook stories with a Selected variant.
    state: Done
    dependencies:
      - task-1
    acceptanceCriteria:
      - 'FeatureNode renders ring-2 ring-primary when selected=true'
      - 'FeatureNode does NOT render ring classes when selected=false'
      - 'Ring does not conflict with existing left border styling'
      - 'Storybook has Selected variant for each state'
      - 'Unit test verifies conditional ring class application'
    tdd:
      red:
        - 'Write test: FeatureNode renders ring-2 ring-primary when selected=true'
        - 'Write test: FeatureNode does NOT render ring classes when selected=false'
      green:
        - 'Add conditional cn() class: ring-2 ring-primary when selected prop is true'
      refactor:
        - 'Verify ring integrates cleanly with existing border-l-4 styles'
        - 'Add Selected story variant to feature-node.stories.tsx'
    estimatedEffort: S

  - id: task-3
    title: 'Extend FeaturesCanvas with interaction and contextual add callbacks [P]'
    description: >
      Add onNodeClick, onPaneClick, onRepositoryAdd, and onNodeAction callback props
      to FeaturesCanvasProps. Pass onNodeClick/onPaneClick to ReactFlow. Wire
      onRepositoryAdd to RepositoryNode's onAdd and onNodeAction to FeatureNode's
      onAction during node enrichment. Update stories.
    state: Done
    dependencies:
      - task-1
    acceptanceCriteria:
      - 'FeaturesCanvasProps includes onNodeClick, onPaneClick, onRepositoryAdd, onNodeAction'
      - 'onNodeClick and onPaneClick passed through to ReactFlow component'
      - 'onRepositoryAdd wired to RepositoryNode onAdd during node enrichment'
      - 'onNodeAction wired to FeatureNode onAction during node enrichment'
      - 'Existing stories still render correctly'
      - 'New Interactive story demonstrates callback usage'
      - 'Unit tests verify callback prop pass-through and node enrichment wiring'
    tdd:
      red:
        - 'Write test: FeaturesCanvas accepts onNodeClick prop'
        - 'Write test: FeaturesCanvas accepts onPaneClick prop'
        - 'Write test: FeaturesCanvas wires onRepositoryAdd to RepositoryNode onAdd'
        - 'Write test: FeaturesCanvas wires onNodeAction to FeatureNode onAction'
      green:
        - 'Add all four callback props to FeaturesCanvasProps interface'
        - 'Pass onNodeClick/onPaneClick to <ReactFlow> component'
        - 'Wire onRepositoryAdd/onNodeAction to nodes in enrichment useMemo'
      refactor:
        - 'Update type exports in index.ts'
        - 'Add Interactive story variant to features-canvas.stories.tsx'
    estimatedEffort: S

  - id: task-4
    title: 'Implement useControlCenterState hook (selection + contextual add)'
    description: >
      Build the central state management hook that composes React Flow hooks
      (useOnSelectionChange, useReactFlow) with local state for selection tracking,
      Escape keyboard shortcut, and contextual add handlers for creating new
      FeatureNodes from repo and feature (+) buttons.
    state: Done
    dependencies:
      - task-2
      - task-3
    acceptanceCriteria:
      - 'Hook returns selectedNode (FeatureNodeData | null)'
      - 'Hook returns clearSelection function'
      - 'Escape key clears selection'
      - 'useOnSelectionChange callback is memoized with useCallback'
      - 'handleAddFeatureToRepo(repoNodeId) adds FeatureNode + edge'
      - 'handleAddFeatureToFeature(featureNodeId) adds FeatureNode + edge'
      - 'handleAddFeature() adds unconnected FeatureNode'
      - 'New nodes positioned to the right of source (x + 350)'
      - 'New nodes are auto-selected after creation'
      - 'All tests pass'
    tdd:
      red:
        - 'Write test: returns selectedNode when FeatureNode selected'
        - 'Write test: returns null selectedNode when no selection'
        - 'Write test: Escape key clears selection'
        - 'Write test: handleAddFeatureToRepo adds node + edge'
        - 'Write test: handleAddFeatureToFeature adds node + edge'
        - 'Write test: handleAddFeature adds unconnected node'
        - 'Write test: new node positioned at source.x + 350'
        - 'Write test: new node is auto-selected'
      green:
        - 'Implement useOnSelectionChange to track selected node'
        - 'Add useEffect with keydown listener for Escape'
        - 'Implement add handlers using useReactFlow (addNodes, addEdges, getNode)'
        - 'Calculate position from source node via getNode()'
      refactor:
        - 'Ensure all callbacks are properly memoized'
        - 'Extract createDefaultFeatureNode factory helper'
        - 'Deduplicate add logic between repo/feature handlers'
    estimatedEffort: M

  - id: task-5
    title: 'Implement ControlCenterToolbar component'
    description: >
      Originally planned as a top toolbar panel with Add Feature and Auto-Layout
      buttons. Implemented initially but REMOVED in refactor (commit 0c9afbe) —
      toolbar was replaced by contextual (+) buttons on nodes and empty state CTA,
      providing a cleaner canvas-first UX.
    state: Removed
    dependencies:
      - task-1
    acceptanceCriteria:
      - 'REMOVED — toolbar replaced by contextual node actions and empty state CTA'
    tdd: null
    estimatedEffort: S
    removedReason: >
      Toolbar was removed post-implementation in favor of contextual (+) buttons
      on repository/feature nodes and an empty-state CTA for initial repo selection.
      This provides a cleaner canvas-first experience without overlay chrome.

  - id: task-6
    title: 'Implement ControlCenter orchestrator component'
    description: >
      Wire all sub-components together in the main ControlCenter component.
      Composes FeaturesCanvas via useControlCenterState hook with
      ControlCenterInner wrapper. Wires contextual add handlers
      (onRepositoryAdd, onNodeAction) to canvas. Shows empty state CTA
      when no nodes present. Toolbar was removed in favor of contextual actions.
    state: Done
    dependencies:
      - task-4
    acceptanceCriteria:
      - 'Renders FeaturesCanvas with nodes and edges'
      - 'Wires handleAddFeatureToRepo to FeaturesCanvas onRepositoryAdd'
      - 'Wires handleAddFeatureToFeature to FeaturesCanvas onNodeAction'
      - 'Shows empty state with "Add Repository" CTA when no nodes'
      - 'Escape key deselects node'
      - 'Storybook stories: Empty, WithFeatures, WithNodeActions'
      - 'ControlCenter props: initialNodes, initialEdges'
      - 'pnpm test passes for all control-center tests'
    tdd:
      red:
        - 'Write test: renders FeaturesCanvas with nodes and edges'
        - 'Write test: shows empty state when no nodes provided'
        - 'Write test: wires onRepositoryAdd to FeaturesCanvas'
        - 'Write test: wires onNodeAction to FeaturesCanvas'
      green:
        - 'Compose all sub-components inside ControlCenter'
        - 'Wire useControlCenterState for state management'
        - 'Pass interaction callbacks and contextual add handlers to FeaturesCanvas'
      refactor:
        - 'Add comprehensive Storybook stories (including WithNodeActions)'
        - 'Verify no unnecessary re-renders with React DevTools'
    estimatedEffort: M

  - id: task-7
    title: 'Build validation and final cleanup'
    description: >
      Run all build validation commands to ensure the feature compiles,
      lints, and builds correctly across all targets.
    state: Done
    dependencies:
      - task-6
    acceptanceCriteria:
      - 'pnpm lint:web passes'
      - 'pnpm typecheck:web passes'
      - 'pnpm build:storybook passes'
      - 'pnpm build:web passes'
      - 'All unit tests pass (pnpm test:unit)'
      - 'Components follow tier import rules (013-ui-arch)'
    tdd: null
    estimatedEffort: S

  - id: task-8
    title: 'Create ListDashboardFeaturesUseCase and global DI bridge'
    description: >
      Replace direct SQL in lib/features.ts with proper Clean Architecture data access.
      Three sub-steps: (A) Add listWithAgentRuns() to IFeatureRepository that LEFT JOINs
      with agent_runs table, returning DashboardFeature[] with agentStatus/agentError/
      agentResult/agentType. Implement in SQLiteFeatureRepository. (B) Create
      ListDashboardFeaturesUseCase calling the new repo method. Register in DI container.
      (C) In CLI bootstrap, expose resolved use cases via globalThis.__shepUseCases.
      Create web/lib/use-cases.ts bridge module with local TS interfaces (no CLI source
      imports). Delete web/lib/features.ts. Update page.tsx to use bridge.
    state: Done
    dependencies:
      - task-6
    acceptanceCriteria:
      - 'IFeatureRepository has listWithAgentRuns(filters?) method'
      - 'SQLiteFeatureRepository implements it with LEFT JOIN agent_runs'
      - 'DashboardFeature type defined with agentStatus/agentError/agentResult/agentType'
      - 'ListDashboardFeaturesUseCase exists and is registered in DI container'
      - 'CLI bootstrap exposes use cases via globalThis.__shepUseCases'
      - 'web/lib/use-cases.ts bridge module reads from globalThis (no CLI imports)'
      - 'web/lib/features.ts deleted (no direct SQL in presentation layer)'
      - 'page.tsx uses bridge module for feature data'
      - 'pnpm typecheck and pnpm typecheck:web pass'
    tdd:
      red:
        - 'Write test: listWithAgentRuns returns features with agentStatus from JOIN'
        - 'Write test: ListDashboardFeaturesUseCase.execute() returns DashboardFeature[]'
        - 'Write test: bridge module returns features when globalThis is populated'
      green:
        - 'Add listWithAgentRuns to IFeatureRepository interface'
        - 'Implement in SQLiteFeatureRepository with LEFT JOIN'
        - 'Create ListDashboardFeaturesUseCase'
        - 'Set globalThis.__shepUseCases in CLI bootstrap'
        - 'Create web/lib/use-cases.ts bridge'
        - 'Delete web/lib/features.ts'
        - 'Update page.tsx'
      refactor:
        - 'Ensure DashboardFeature type covers all web UI needs'
        - 'Clean up unused imports'
    estimatedEffort: M

  - id: task-9
    title: 'Align FeatureLifecyclePhase with domain SdlcLifecycle'
    description: >
      Update FeatureLifecyclePhase type to match domain SdlcLifecycle 1:1.
      Replace invented UI phases ('plan', 'test', 'maintenance') with domain
      values ('research', 'review', 'maintain'). Add lifecycleDisplayLabels
      map for human-readable names (maintain→'COMPLETED', deploy→'DEPLOY & QA').
      Update feature-node.tsx to use display labels. Fix lifecycleMap in page.tsx.
    state: Done
    dependencies:
      - task-7
    acceptanceCriteria:
      - "FeatureLifecyclePhase type is 'requirements'|'research'|'implementation'|'review'|'deploy'|'maintain'"
      - 'lifecycleDisplayLabels map exported from feature-node index.ts'
      - 'feature-node.tsx uses lifecycleDisplayLabels[data.lifecycle] instead of .toUpperCase()'
      - 'lifecycleMap in page.tsx maps domain values 1:1'
      - 'pnpm typecheck:web passes'
    tdd:
      red:
        - 'Write test: lifecycleDisplayLabels maps maintain to COMPLETED'
        - 'Write test: lifecycleDisplayLabels maps deploy to DEPLOY & QA'
      green:
        - 'Update FeatureLifecyclePhase type union'
        - 'Add lifecycleDisplayLabels const'
        - 'Update feature-node.tsx to use display labels'
        - 'Fix lifecycleMap in page.tsx'
      refactor:
        - 'Export lifecycleDisplayLabels from index.ts'
    estimatedEffort: S

  - id: task-10
    title: 'Verify agent state integration end-to-end via use case'
    description: >
      With the DI bridge in place (task-8), verify that agent run status flows
      correctly from DB through the use case to the UI. deriveState() in page.tsx
      maps the DashboardFeature agentStatus to FeatureNodeState. Maintain lifecycle
      forces done state. Ensure all agent states display correctly (running, done,
      error, action-required). Update any tests that mock getFeatures() to mock
      the bridge module instead.
    state: Done
    dependencies:
      - task-8
      - task-9
    acceptanceCriteria:
      - 'Features display correct state from agent_runs via use case (not direct SQL)'
      - 'deriveState() maps DashboardFeature.agentStatus to correct FeatureNodeState'
      - 'Maintain lifecycle always returns done state with progress 100'
      - 'Features with no agent_run show as running (default)'
      - 'agentError propagates to errorMessage in node data'
      - 'pnpm build:web passes'
    tdd:
      red:
        - 'Write test: deriveState returns done for maintain lifecycle'
        - 'Write test: deriveState returns done for completed agent status'
        - 'Write test: deriveState returns error for failed agent status'
        - 'Write test: deriveState returns action-required for waiting_approval'
      green:
        - 'Verify deriveState works with DashboardFeature type from bridge'
        - 'Update page.tsx to use DashboardFeature fields from bridge module'
      refactor:
        - 'Remove any remaining references to direct SQL in presentation layer'
    estimatedEffort: S

  - id: task-11
    title: 'Update stories with new lifecycle values'
    description: >
      Update all Storybook stories in feature-node.stories.tsx to use new
      lifecycle phase values. Replace 'plan' with 'research', 'test' with
      'review', 'maintenance' with 'maintain'. Update allLifecycles array.
      Verify AllLifecycles story renders correct display labels.
    state: Done
    dependencies:
      - task-9
    acceptanceCriteria:
      - 'No old lifecycle values (plan, test, maintenance) in stories'
      - 'allLifecycles array uses new values'
      - 'AllLifecycles story shows REQUIREMENTS, RESEARCH, IMPLEMENTATION, REVIEW, DEPLOY & QA, COMPLETED'
      - 'pnpm build:storybook passes'
    tdd: null
    estimatedEffort: S

  - id: task-12
    title: 'Create agent type icons and plumb agentType from use case'
    description: >
      agentType already flows through DashboardFeature from the use case
      (Phase 6A LEFT JOIN includes ar.agent_type). Create agent-type-icons.tsx
      with an AgentTypeValue union type mirroring the TypeSpec AgentType enum
      (claude-code, cursor, gemini-cli, aider, continue). Implement inline
      SVG icon components for each agent type plus a DefaultAgentIcon fallback.
      Export a getAgentTypeIcon() resolver. Add agentType to FeatureNodeData
      and pass it through in page.tsx from bridge data.
    state: Done
    dependencies:
      - task-10
    acceptanceCriteria:
      - 'agentType flows from DashboardFeature through bridge to page.tsx'
      - 'agent-type-icons.tsx exports AgentTypeValue union type'
      - 'SVG components exist for all 5 AgentType enum values plus DefaultAgentIcon'
      - 'getAgentTypeIcon() resolves agent type string to icon component'
      - 'FeatureNodeData includes agentType?: AgentTypeValue'
      - 'page.tsx passes agentType to FeatureNodeData from bridge data'
      - 'pnpm typecheck:web passes'
    tdd:
      red:
        - 'Write test: getAgentTypeIcon returns ClaudeCodeIcon for claude-code'
        - 'Write test: getAgentTypeIcon returns DefaultAgentIcon for undefined'
      green:
        - 'Create agent-type-icons.tsx with SVG components and resolver'
        - 'Add agentType to FeatureNodeData'
        - 'Pass agentType in page.tsx nodeData from bridge'
      refactor:
        - 'Ensure all SVGs use currentColor and accept className'
    estimatedEffort: M

  - id: task-13
    title: 'Update feature node badge (hide featureId, agent icon, lifecycle verbs)'
    description: >
      Remove featureId rendering from both the progress-bar and non-progress
      views in feature-node.tsx. Add lifecycleRunningVerbs map to
      feature-node-state-config.ts mapping lifecycle phases to present-participle
      verbs (Analyzing, Researching, Implementing, Reviewing, Deploying,
      Maintaining). Update getBadgeText running case to use lifecycle verb.
      In running badge: show CometSpinner + AgentTypeIcon + lifecycle verb text.
      For non-running states: show agent icon (if agentType available) before
      state icon. Remove agentName from FeatureNodeData (replaced by agentType).
    state: Done
    dependencies:
      - task-12
    acceptanceCriteria:
      - 'featureId not rendered in the feature node card'
      - 'Running badge shows CometSpinner + agent type icon + lifecycle verb'
      - 'lifecycleRunningVerbs maps all 6 phases to verbs'
      - 'getBadgeText running case returns lifecycle verb (e.g. Analyzing)'
      - 'Non-running states show agent icon before state icon when agentType set'
      - 'agentName removed from FeatureNodeData'
      - 'pnpm typecheck:web passes'
    tdd:
      red:
        - 'Write test: featureId is NOT rendered in the card'
        - 'Write test: running badge shows lifecycle verb for each phase'
        - 'Write test: running badge does not show featureId in text'
      green:
        - 'Remove featureId spans from both views'
        - 'Add lifecycleRunningVerbs map'
        - 'Update getBadgeText running case'
        - 'Update badge icon rendering with agent type icon + CometSpinner'
        - 'Remove agentName from FeatureNodeData'
      refactor:
        - 'Remove unused agentName imports'
        - 'Verify badge sizing and spacing'
    estimatedEffort: M

  - id: task-14
    title: 'Update tests and Storybook stories for badge improvements'
    description: >
      Fix broken tests that assert featureId rendering and old badge text.
      Add tests for lifecycle running verbs across all 6 phases. Update all
      Storybook story data to replace agentName with agentType. Add
      AllAgentTypes story showcasing all 5 agent types plus fallback.
      Export lifecycleRunningVerbs and getAgentTypeIcon from index.ts.
    state: Done
    dependencies:
      - task-13
    acceptanceCriteria:
      - 'Test "renders featureId" updated to assert featureId NOT rendered'
      - 'Test "agent name and featureId in badge text" updated for lifecycle verb'
      - 'Test "defaults to Agent" updated for lifecycle verb'
      - 'Tests for all 6 lifecycle running verbs pass'
      - 'All story data uses agentType instead of agentName'
      - 'AllAgentTypes story exists showing all 5 types + fallback'
      - 'lifecycleRunningVerbs and getAgentTypeIcon exported from index.ts'
      - 'pnpm build:storybook passes'
      - 'All unit tests pass'
    tdd:
      red:
        - 'Write test: each lifecycle phase shows correct running verb'
        - 'Write test: agent icon renders for known agent type'
        - 'Write test: fallback icon renders for unknown agent type'
      green:
        - 'Fix existing broken tests'
        - 'Add lifecycle verb tests'
        - 'Update stories with agentType'
        - 'Add AllAgentTypes story'
        - 'Export new symbols from index.ts'
      refactor:
        - 'Remove all agentName references from stories'
    estimatedEffort: S

# Total effort estimate
totalEstimate: L

# Open questions
openQuestions: []

# Markdown content (the full tasks document)
content: |
  ## Status

  - **Phase:** In Progress (Phase 6 and 9 reopened — replacing direct SQL with use cases via DI bridge)
  - **Updated:** 2026-02-15

  ## Task List

  ### Phase 1: Foundation

  - [x] **task-1**: Scaffold control-center directory structure
    - Create `features/control-center/` with 5 files (component, hook, toolbar, stories, index)
    - Add minimal type-safe placeholder exports
    - Verify `pnpm typecheck:web` passes

  ### Phase 2: Existing Component Updates [P]

  #### 2A: FeatureNode Selected Highlight

  **RED (Write Failing Tests First):**

  - [x] Write test: FeatureNode renders `ring-2 ring-primary` when `selected=true`
  - [x] Write test: FeatureNode does NOT render ring classes when `selected=false`

  **GREEN (Implement to Pass Tests):**

  - [x] Add conditional `cn()` class for ring highlight keyed on `selected` prop

  **REFACTOR (Clean Up):**

  - [x] Verify ring integrates with existing `border-l-4` styles
  - [x] Add Selected story variant to `feature-node.stories.tsx`

  #### 2B: FeaturesCanvas Interaction and Contextual Add Callbacks

  **RED (Write Failing Tests First):**

  - [x]Write test: FeaturesCanvas accepts and passes `onNodeClick` prop
  - [x]Write test: FeaturesCanvas accepts and passes `onPaneClick` prop
  - [x]Write test: FeaturesCanvas wires `onRepositoryAdd` to RepositoryNode `onAdd`
  - [x]Write test: FeaturesCanvas wires `onNodeAction` to FeatureNode `onAction`

  **GREEN (Implement to Pass Tests):**

  - [x]Add `onNodeClick`, `onPaneClick`, `onRepositoryAdd`, `onNodeAction` to `FeaturesCanvasProps`
  - [x]Pass `onNodeClick`/`onPaneClick` through to `<ReactFlow>` component
  - [x]Wire `onRepositoryAdd`/`onNodeAction` to nodes in enrichment `useMemo`

  **REFACTOR (Clean Up):**

  - [x]Update type exports in index.ts
  - [x]Add Interactive story variant

  ### Phase 3: State Management Hook (Selection + Contextual Add)

  **RED — Selection & Keyboard (Write Failing Tests First):**

  - [x]Write test: returns selectedNode when FeatureNode selected
  - [x]Write test: returns null when no selection
  - [x]Write test: Escape key clears selection

  **GREEN — Selection & Keyboard:**

  - [x]Implement `useOnSelectionChange` for selection tracking
  - [x]Add `useEffect` with keydown listener for Escape

  **RED — Contextual Add Handlers (Write Failing Tests First):**

  - [x]Write test: `handleAddFeatureToRepo` adds node + edge
  - [x]Write test: `handleAddFeatureToFeature` adds node + edge
  - [x]Write test: `handleAddFeature` adds unconnected node
  - [x]Write test: new node positioned at source.x + 350
  - [x]Write test: new node is auto-selected

  **GREEN — Contextual Add Handlers:**

  - [x]Implement add handlers using `useReactFlow` (`addNodes`, `addEdges`, `getNode`)
  - [x]Calculate position from source node position

  **REFACTOR (Clean Up):**

  - [x]Ensure all callbacks properly memoized
  - [x]Extract `createDefaultFeatureNode` factory helper
  - [x]Deduplicate add logic between repo/feature handlers

  ### Phase 4: Toolbar — REMOVED

  ~~Toolbar was removed in favor of contextual (+) node actions and empty state CTA
  for a cleaner canvas-first UX (task-5 removed).~~

  ### Phase 5: Orchestrator Integration

  **RED:**

  - [x]Write test: renders FeaturesCanvas with nodes and edges
  - [x]Write test: shows empty state when no nodes provided
  - [x]Write test: wires onRepositoryAdd to FeaturesCanvas
  - [x]Write test: wires onNodeAction to FeaturesCanvas

  **GREEN:**

  - [x]Compose all sub-components in ControlCenter
  - [x]Wire useControlCenterState hook
  - [x]Connect callbacks, contextual add handlers, and state

  **REFACTOR:**

  - [x]Add comprehensive Storybook stories (Empty, WithFeatures, WithToolbar, WithNodeActions)
  - [x]Verify no unnecessary re-renders

  ### Phase 6: Clean Architecture Data Layer + DI Bridge

  #### 6A: Repository + Use Case (TDD)

  **RED:**

  - [ ] Write test: listWithAgentRuns returns features with agentStatus from JOIN
  - [ ] Write test: ListDashboardFeaturesUseCase.execute() returns DashboardFeature[]
  - [ ] Write test: bridge module returns features when globalThis is populated

  **GREEN:**

  - [ ] Define DashboardFeature type (Feature + optional agentStatus, agentError, agentResult, agentType)
  - [ ] Add listWithAgentRuns(filters?) to IFeatureRepository interface
  - [ ] Implement in SQLiteFeatureRepository with LEFT JOIN agent_runs
  - [ ] Create ListDashboardFeaturesUseCase
  - [ ] Register in DI container

  **REFACTOR:**

  - [ ] Ensure mapper handles null agent_run columns cleanly

  #### 6B: Global DI Bridge

  - [ ] Expose resolved use cases via globalThis.__shepUseCases in CLI bootstrap
  - [ ] Create web/lib/use-cases.ts bridge module (local TS interfaces, no CLI imports)
  - [ ] Delete web/lib/features.ts (direct SQL removed)
  - [ ] Update page.tsx to use bridge module
  - [ ] pnpm typecheck and pnpm typecheck:web pass

  ### Phase 7: Build Validation

  - [x]`pnpm lint:web` passes
  - [x]`pnpm typecheck:web` passes
  - [x]`pnpm build:storybook` passes
  - [x]`pnpm build:web` passes
  - [x]All unit tests pass (`pnpm test:unit`)

  ### Phase 8: Lifecycle Alignment

  **RED:**

  - [x]Write test: lifecycleDisplayLabels maps maintain to COMPLETED
  - [x]Write test: lifecycleDisplayLabels maps deploy to DEPLOY & QA

  **GREEN:**

  - [x]Update FeatureLifecyclePhase type union (plan→research, test→review, maintenance→maintain)
  - [x]Add lifecycleDisplayLabels const in feature-node-state-config.ts
  - [x]Update feature-node.tsx to use lifecycleDisplayLabels[data.lifecycle]
  - [x]Fix lifecycleMap in page.tsx to 1:1 domain mapping

  **REFACTOR:**

  - [x]Export lifecycleDisplayLabels from index.ts

  ### Phase 9: Agent State E2E Verification

  **RED:**

  - [ ] Write test: deriveState returns done for maintain lifecycle
  - [ ] Write test: deriveState returns done for completed agent status
  - [ ] Write test: deriveState returns error for failed agent status
  - [ ] Write test: deriveState returns action-required for waiting_approval

  **GREEN:**

  - [ ] Verify deriveState works with DashboardFeature type from bridge
  - [ ] Update page.tsx to use DashboardFeature fields from bridge module

  **REFACTOR:**

  - [ ] Remove any remaining references to direct SQL in presentation layer

  ### Phase 10: Story Updates

  - [x]Replace old lifecycle values in all story data (plan→research, test→review, maintenance→maintain)
  - [x]Update allLifecycles array
  - [x]Verify AllLifecycles story shows correct display labels
  - [x]pnpm build:storybook passes

  ### Phase 11: Feature Node Badge Improvements

  #### 11A: Agent type icons (task-12)

  - [ ] agentType already flows through DashboardFeature from use case (Phase 6A)
  - [ ] Create `agent-type-icons.tsx` with `AgentTypeValue` union type mirroring TypeSpec `AgentType` enum
  - [ ] Implement SVG components: `ClaudeCodeIcon`, `CursorIcon`, `GeminiCliIcon`, `AiderIcon`, `ContinueIcon`, `DefaultAgentIcon`
  - [ ] Export `getAgentTypeIcon()` resolver
  - [ ] Add `agentType?: AgentTypeValue` to `FeatureNodeData`
  - [ ] Pass `agentType` through in `page.tsx` from bridge data

  #### 11B: Badge updates (task-13)

  **RED:**

  - [ ] Write test: featureId is NOT rendered in the card
  - [ ] Write test: running badge shows lifecycle verb for each phase
  - [ ] Write test: running badge does not show featureId in text

  **GREEN:**

  - [ ] Remove featureId spans from both views
  - [ ] Add `lifecycleRunningVerbs` map
  - [ ] Update `getBadgeText` running case to use lifecycle verb
  - [ ] Running badge: `[CometSpinner] [AgentTypeIcon] {lifecycle verb}`
  - [ ] Non-running states: show agent icon before state icon when agentType set
  - [ ] Remove `agentName` from `FeatureNodeData`

  **REFACTOR:**

  - [ ] Remove unused agentName imports
  - [ ] Verify badge sizing and spacing

  #### 11C: Tests + Stories (task-14)

  - [ ] Fix test "renders featureId" → assert NOT rendered
  - [ ] Fix test "agent name and featureId in badge text" → assert lifecycle verb
  - [ ] Fix test "defaults to Agent" → assert lifecycle verb
  - [ ] Add tests for all 6 lifecycle running verbs
  - [ ] Update all story data: replace `agentName` with `agentType`
  - [ ] Add `AllAgentTypes` story
  - [ ] Export `lifecycleRunningVerbs` and `getAgentTypeIcon` from `index.ts`

  ## TDD Notes

  - **MANDATORY**: All phases with code follow RED -> GREEN -> REFACTOR
  - **RED**: Write failing tests FIRST (never skip this!)
  - **GREEN**: Write minimal code to pass tests
  - **REFACTOR**: Improve code while keeping tests green

  ## Progress Tracking (CRITICAL)

  - **Update checkboxes FREQUENTLY** - as soon as each item is complete!
  - **Don't batch updates** - check off items immediately, not at the end
  - **Commit task.md updates** along with code changes to show progress

  ## Acceptance Checklist

  Before marking feature complete:

  - [ ]All 14 tasks completed (11 done + 3 new)
  - [ ]Tests passing (`pnpm test`)
  - [ ]Linting clean (`pnpm lint:web`)
  - [ ]Types valid (`pnpm typecheck:web`)
  - [ ]Storybook builds (`pnpm build:storybook`)
  - [ ]Web builds (`pnpm build:web`)
  - [ ]Components follow tier import rules (013-ui-arch)
  - [ ]PR updated and reviewed

  ---

  _Task breakdown for implementation tracking_
