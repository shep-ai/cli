# Feature Specification (YAML)
# This is the source of truth. Markdown is auto-generated from this file.

name: feature-toolbar
number: 021
branch: feat/021-feature-toolbar
oneLiner: Feature action buttons in FeatureDrawer to open feature in IDE & Shell
summary: >
  Add "Open in IDE" and "Open in Shell" action buttons exclusively inside the
  FeatureDrawer (right-side detail panel) that launch the feature's worktree
  directory in the user's configured editor or shell via new Next.js API routes
  backed by the existing IDE launcher infrastructure from spec 018. There is no
  canvas-level floating toolbar — all actions live in the drawer.
phase: Requirements
sizeEstimate: M

# Relationships
relatedFeatures:
  - number: 018
    name: feat-ide-open
    relationship: depends-on
    notes: >
      Reuses IdeLauncher interface, launcher registry, and computeWorktreePath
      logic from the shep ide command implementation.

technologies:
  - React (client components with hooks)
  - shadcn/ui (Button, Separator primitives)
  - Next.js App Router API routes
  - lucide-react (icons)
  - Storybook (mandatory colocated stories)
  - Tailwind CSS v4
  - child_process (spawn detached for shell launch)

relatedLinks: []

# Open questions — all resolved with AI-recommended defaults
openQuestions:
  - question: >
      Should the toolbar be a floating panel on the canvas or live inside the
      FeatureDrawer?
    resolved: true
    answer: >
      Drawer-only. The action buttons live exclusively inside the FeatureDrawer
      header area. No canvas-level floating panel. Rationale: (1) the drawer is
      already the primary detail view opened on node click, (2) fewer moving parts
      — no ReactFlow Panel, no conditional canvas overlay, (3) keeps the canvas
      clean and focused on the node graph, (4) avoids z-index and overlap concerns.

  - question: >
      Should "Open in Shell" launch the OS default terminal or a configurable
      shell? Settings already have shellPreference but no terminal app preference.
    resolved: true
    answer: >
      Recommend OS-default shell for v1: macOS uses "open -a Terminal <path>",
      Linux uses "x-terminal-emulator" or "xdg-terminal-emulator" with the
      --working-directory flag. Rationale: (1) zero configuration required —
      works out of the box, (2) EnvironmentConfig.shellPreference already captures
      shell choice (bash/zsh/fish) but terminal app is a separate concern,
      (3) adding a configurable terminal app setting is a clean follow-up that
      doesn't block this feature. Alternative: add a shellApp field to
      EnvironmentConfig in a follow-up spec if users request iTerm2/Alacritty/etc.

  - question: >
      Should the toolbar actions also appear in the FeatureDrawer (right-side
      detail panel) for consistency?
    resolved: true
    answer: >
      The FeatureDrawer is the sole location for "Open in IDE" and "Open in Shell"
      buttons. There is no separate canvas toolbar. The drawer header area is the
      single, discoverable action surface.

  - question: >
      Should the toolbar display the feature name or other context, or only
      action buttons?
    resolved: true
    answer: >
      Recommend action buttons only (icon + tooltip label) with no feature name
      in the toolbar. Rationale: (1) the toolbar is a quick-action surface, not
      an info panel — feature name is already visible on the selected node and
      in the drawer, (2) compact design keeps the toolbar unobtrusive and
      consistent with the minimal Controls component, (3) tooltips on icon
      buttons provide sufficient labeling without visual clutter. Alternative:
      add a small feature name label if usability testing shows confusion about
      which feature the toolbar acts on.

  - question: >
      How should the data pipeline supply repositoryPath and branch to the
      toolbar — extend FeatureNodeData or resolve server-side via API?
    resolved: true
    answer: >
      Recommend extending FeatureNodeData with repositoryPath and branch fields
      populated in page.tsx from the Feature aggregate. Rationale: (1) eliminates
      an extra API round-trip on every action click, (2) page.tsx already has the
      full Feature object including these fields, (3) these are stable,
      non-sensitive strings (repo path and branch name), (4) follows the existing
      pattern where all node display data is pre-computed server-side. The API
      routes then receive these values directly from the client — no server-side
      feature lookup needed. Alternative: API route resolves featureId → path
      if data size becomes a concern, but unlikely for 2 short strings.

  - question: >
      Should the API routes accept repositoryPath + branch directly, or a
      featureId that gets resolved server-side?
    resolved: true
    answer: >
      Recommend repositoryPath + branch as direct inputs. Rationale: (1) avoids
      coupling API routes to feature lookup infrastructure, (2) the client
      already has these values from FeatureNodeData, (3) simpler route
      implementation — just compute worktree path and launch, (4) follows the
      existing /api/dialog pattern where routes receive concrete values. Security
      consideration: validate that repositoryPath is a plausible filesystem path
      and branch is a valid git ref to prevent path traversal. Alternative:
      featureId-based lookup if the routes are ever exposed beyond localhost.

  - question: >
      Should computeWorktreePath be extracted to a shared utility or duplicated
      in the API routes?
    resolved: true
    answer: >
      Recommend extracting to a shared utility in packages/core (e.g.,
      packages/core/src/infrastructure/services/ide-launchers/compute-worktree-path.ts).
      Rationale: (1) currently duplicated in ide-open.command.ts and
      show.command.ts — a third copy in API routes would worsen the problem,
      (2) the function is pure (hash + path join) with no DI dependencies,
      making it trivially extractable, (3) both CLI and web can import from
      packages/core. Alternative: inline in API route if monorepo import proves
      problematic, but this is unlikely given existing cross-package imports.

# Markdown content (the actual spec)
content: |
  ## Problem Statement

  The Shep web UI (Control Center) displays features as interactive canvas nodes but
  provides no way to take action on them beyond viewing details in the drawer. Users
  who want to open a feature's code in their IDE or navigate to its worktree in a
  shell must switch to the CLI and run `shep ide <feat-id>` manually. This
  context-switching breaks flow and undercuts the value of the visual canvas.

  The IDE launcher infrastructure (spec 018: IdeLauncher interface, launcher registry,
  worktree path computation) is fully implemented in `packages/core` but has no
  web-facing integration.

  This feature bridges the gap by adding "Open in IDE" and "Open in Shell" action
  buttons inside the FeatureDrawer, backed by new API routes that reuse the
  existing IDE launcher infrastructure and the user's shellPreference.

  ## Success Criteria

  - [ ] FeatureDrawer header includes "Open in IDE" and "Open in Shell" action buttons
  - [ ] Buttons only render when selectedNode has valid repositoryPath and branch
  - [ ] "Open in IDE" button calls POST /api/ide/open and launches the configured editor at the feature worktree
  - [ ] "Open in Shell" button calls POST /api/shell/open and opens the user's configured shell at the feature worktree
  - [ ] Both buttons show a loading spinner while the API call is in flight
  - [ ] Both buttons display inline error on failure (e.g., IDE not installed, path not found)
  - [ ] API route /api/ide/open validates inputs, computes worktree path, and launches via IdeLauncher registry
  - [ ] API route /api/shell/open validates inputs, computes worktree path, and spawns shell process
  - [ ] API routes return appropriate error responses (400 for bad input, 404 for missing launcher, 500 for spawn failure)
  - [ ] FeatureNodeData includes repositoryPath and branch, populated from Feature aggregate in page.tsx
  - [ ] computeWorktreePath is extracted to a shared utility in packages/core (no duplication)
  - [ ] FeatureDrawer updated stories reflect new action buttons
  - [ ] All new API routes and the useFeatureActions hook have unit tests
  - [ ] All buttons have accessible labels (aria-label or tooltip text)
  - [ ] No canvas-level floating toolbar — actions exist only in the drawer

  ## Functional Requirements

  ### FeatureDrawer Action Buttons

  - **FR-1: Drawer-only placement** — The "Open in IDE" and "Open in Shell" action
    buttons MUST exist exclusively inside the FeatureDrawer header area (below the
    title, above the status section). There is no canvas-level floating toolbar.

  - **FR-2: Conditional rendering** — The action buttons MUST only render when the
    selected node has valid (non-empty) `repositoryPath` and `branch` values.

  - **FR-3: Open in IDE action** — The drawer MUST include an "Open in IDE" button
    (lucide-react `Code2` icon + label) that, when clicked, sends a POST request to
    `/api/ide/open` with `{ repositoryPath, branch }` from the selected node's data.

  - **FR-4: Open in Shell action** — The drawer MUST include an "Open in Shell"
    button (lucide-react `Terminal` icon + label) that, when clicked, sends a POST
    request to `/api/shell/open` with `{ repositoryPath, branch }` from the selected
    node's data.

  - **FR-5: Loading state** — Each action button MUST show a loading spinner (replacing
    the icon) while its API call is in flight. Buttons MUST be disabled during loading
    to prevent duplicate invocations.

  - **FR-6: Error feedback** — If an API call fails, the button MUST display an error
    indicator (AlertCircle icon with destructive styling). Error state clears on next
    successful action or after 5 seconds.

  - **FR-7: Button styling** — Buttons MUST use shadcn/ui Button (variant="outline",
    size="sm") with icon + text label. All buttons have `aria-label` attributes.

  ### Data Pipeline

  - **FR-8: FeatureNodeData extension** — The `FeatureNodeData` interface MUST be extended
    with `repositoryPath: string` and `branch: string` fields.

  - **FR-9: Server-side population** — The page.tsx server component MUST populate
    `repositoryPath` and `branch` on each FeatureNodeData from the corresponding
    `Feature` aggregate fields (`feature.repositoryPath`, `feature.branch`).

  ### API Routes

  - **FR-10: IDE open endpoint** — A new POST route at `/api/ide/open` MUST:
    1. Accept JSON body `{ repositoryPath: string, branch: string }`
    2. Read `getSettings().environment.defaultEditor` to determine the editor type
    3. Compute the worktree path via the shared `computeWorktreePath(repositoryPath, branch)`
    4. Resolve the launcher from `createLauncherRegistry()` using the editor type
    5. Call `launcher.checkAvailable()` — return 404 with message if unavailable
    6. Call `launcher.launch(worktreePath)` — return 200 on success, 500 on failure
    7. Return JSON `{ success: true, editor: string, path: string }` on success
    8. Return JSON `{ error: string }` with appropriate status code on failure

  - **FR-11: Shell open endpoint** — A new POST route at `/api/shell/open` MUST:
    1. Accept JSON body `{ repositoryPath: string, branch: string }`
    2. Read `getSettings().environment.shellPreference` to determine the user's preferred shell
    3. Compute the worktree path via the shared `computeWorktreePath(repositoryPath, branch)`
    4. Verify the worktree path exists on disk (return 404 if not)
    5. Spawn a detached terminal process at the worktree path using OS-appropriate command:
       - macOS: `open -a Terminal <path>` (via child_process.spawn with detached: true)
       - Linux: `x-terminal-emulator --working-directory=<path>` (or xdg-terminal-emulator fallback)
       The spawned terminal SHOULD use the user's shellPreference if available.
    6. Return JSON `{ success: true, path: string, shell: string }` on success
    7. Return JSON `{ error: string }` with appropriate status code on failure

  - **FR-12: Input validation** — Both API routes MUST validate that `repositoryPath` is
    a non-empty string and `branch` is a non-empty string. Return 400 with descriptive
    error if validation fails. Path traversal sequences (`..`) in branch names MUST be
    rejected.

  ### Shared Utility

  - **FR-13: computeWorktreePath extraction** — The `computeWorktreePath(repoPath, branch)`
    function MUST be extracted from `ide-open.command.ts` into a shared module at
    `packages/core/src/infrastructure/services/ide-launchers/compute-worktree-path.ts`
    (or similar location under packages/core). Both the CLI command and the new API routes
    MUST import from this shared location. The existing duplicated copies MUST be replaced.

  ### Storybook

  - **FR-14: Drawer stories update** — The FeatureDrawer stories MUST be updated to
    include the new action buttons in all existing story variants. Stories should cover
    action buttons in idle, loading, and error states, plus a variant without
    repositoryPath (buttons hidden).

  ## Non-Functional Requirements

  - **NFR-1: Responsiveness** — API route responses MUST return within 2 seconds under
    normal conditions. The launcher spawn is fire-and-forget (detached process); the
    route does not wait for the editor/shell to fully open.

  - **NFR-2: Accessibility** — All drawer action buttons MUST have `aria-label`
    attributes describing their action (e.g., "Open in IDE", "Open in Shell").

  - **NFR-3: Security** — API routes MUST validate inputs to prevent path traversal.
    Routes run on localhost only (Next.js dev server) so authentication is not required,
    but input sanitization is mandatory. The `repositoryPath` must be validated as an
    absolute path. The `branch` must not contain `..` or null bytes.

  - **NFR-4: Error resilience** — The drawer action buttons MUST NOT crash or become
    unresponsive if an API call fails. All errors MUST be caught and displayed gracefully.
    Network errors (fetch failure) MUST be handled alongside API error responses.

  - **NFR-5: Component architecture** — The useFeatureActions hook is colocated with the
    FeatureDrawer component in `src/presentation/web/components/common/feature-drawer/`.

  - **NFR-6: Clean Architecture compliance** — API routes MUST instantiate infrastructure
    services directly (matching the existing /api/dialog/* pattern). They MUST NOT import
    from the DI container or use tsyringe. Domain logic (worktree path computation) stays
    in packages/core.

  - **NFR-7: Bundle impact** — Minimal bundle weight. No new npm dependencies — all UI
    primitives (Button, Separator) and icons (lucide-react) are already available.

  - **NFR-8: Cross-platform shell launch** — The shell open API route MUST support
    macOS and Linux. Windows support is out of scope for v1 (consistent with the rest of
    the Shep platform). If the platform is unsupported, the route returns a 501 error
    with a clear message.

  - **NFR-9: Testability** — All action logic MUST be extracted into a custom hook
    (`useFeatureActions`) colocated with the FeatureDrawer that can be unit-tested
    independently. API routes MUST be testable with mocked services.

  ## Product Questions & AI Recommendations

  | # | Question | Decision | Rationale |
  | - | -------- | -------- | --------- |
  | 1 | Canvas toolbar vs. drawer-only? | Drawer-only | Simpler, fewer components, drawer is already the detail view, keeps canvas clean |
  | 2 | OS-default shell vs. configurable? | OS-default shell using shellPreference for v1 | Uses existing shellPreference setting; configurable terminal app is a clean follow-up |
  | 3 | Data pipeline: extend FeatureNodeData or resolve via API? | Extend FeatureNodeData with repositoryPath + branch | Avoids round-trip; page.tsx already has the data; 2 short strings |
  | 4 | API input: repositoryPath+branch vs. featureId? | repositoryPath + branch directly | Simpler routes, no feature lookup coupling, client already has the values |
  | 5 | Extract computeWorktreePath or duplicate? | Extract to packages/core shared utility | Already duplicated twice; a third copy is unacceptable; pure function, easy to extract |

  ## Affected Areas

  | Area | Impact | Reasoning |
  | ---- | ------ | --------- |
  | `src/presentation/web/components/common/feature-drawer/feature-drawer.tsx` | High | Action buttons + useFeatureActions hook colocated here |
  | `src/presentation/web/components/common/feature-node/feature-node-state-config.ts` | Low | Add `repositoryPath` and `branch` to FeatureNodeData |
  | `src/presentation/web/app/page.tsx` | Low | Pass repositoryPath + branch into FeatureNodeData |
  | `src/presentation/web/app/api/ide/open/route.ts` | High | New API route — bridges web → IDE launcher |
  | `src/presentation/web/app/api/shell/open/route.ts` | High | New API route — bridges web → shell launch |
  | `packages/core/src/infrastructure/services/ide-launchers/` | Low | Extract computeWorktreePath; existing launchers consumed as-is |
  | `src/presentation/cli/commands/ide-open.command.ts` | Low | Replace inline computeWorktreePath with shared import |
  | Storybook stories | Medium | Updated drawer stories |

  ## Dependencies

  **Existing Infrastructure (from spec 018)**:
  - `IdeLauncher` interface and 5 implementations (packages/core)
  - `createLauncherRegistry()` for editor resolution
  - `computeWorktreePath()` logic (needs extraction from CLI command to shared utility)
  - `EditorType` enum and `EnvironmentConfig.defaultEditor` setting
  - `getSettings()` singleton for reading configured IDE preference and shellPreference

  **Existing Web Patterns**:
  - Next.js API route pattern (`/api/dialog/pick-folder`) for OS-level operations
  - `FeatureNodeData` interface (needs `repositoryPath` + `branch` fields)
  - `FeatureDrawer` component (receives `selectedNode`)

  **Libraries Already Available**:
  - shadcn/ui Button, Separator
  - lucide-react icons (Code2, Terminal, Loader2, CircleAlert)
  - child_process (Node.js built-in, for shell spawn)

  ## Size Estimate

  **M (days)** — The drawer action buttons and hook are straightforward React with
  existing shadcn/ui primitives. The main complexity lies in:
  1. Two new API routes bridging web → IDE/shell launchers
  2. Extracting `computeWorktreePath` to a shared utility in packages/core
  3. Threading `repositoryPath` + `branch` through the FeatureNodeData pipeline
  4. Custom hook (`useFeatureActions`) encapsulating action logic with loading/error state
  5. TDD test coverage for API routes, hook, and updated drawer

  The IDE launcher infrastructure is fully built (spec 018) and shellPreference is
  already available in Settings. This is primarily a presentation-layer feature with
  thin API route glue. No new npm dependencies required.
