# Implementation Plan (YAML)
# This is the source of truth. Markdown is auto-generated from this file.

name: display-prd-spec
summary: >
  Presentation-layer-only feature that reads and displays PRD spec.yaml content in the CLI
  feat show/review commands and Web UI feature drawer when a feature is awaiting PRD approval.
  Uses direct readFileSync + js-yaml at each call site (no shared utility), a new GET
  /api/features/[id]/spec API route with ShowFeatureUseCase string-token alias, and
  ScrollArea + Badge shadcn components for the drawer. All data types already exist in
  TypeSpec-generated output (FeatureSpec, OpenQuestion). No new domain models, repositories,
  or use cases needed. Implementation follows 3 phases with 8 tasks across ~4 hours.

# Relationships
relatedFeatures: []

technologies:
  - Commander.js (CLI commands)
  - Next.js App Router (API route)
  - React / shadcn-ui (Badge, ScrollArea)
  - js-yaml (YAML parsing - existing dependency)
  - TypeSpec generated types (FeatureSpec, OpenQuestion)
  - tsyringe (DI container - string-token alias)
  - Storybook (component stories)
  - Vitest (unit tests)

relatedLinks: []

phases:
  - id: phase-1
    name: 'DI Container & API Route Foundation'
    description: >
      Add the ShowFeatureUseCase string-token alias in the DI container and create the
      GET /api/features/[id]/spec API route. This must come first because the Web UI
      drawer depends on this API route to fetch spec content. The DI alias follows the
      exact pattern already used for CreateFeatureUseCase, ListFeaturesUseCase, and
      DeleteFeatureUseCase (container.ts lines 263-271).
    parallel: false

  - id: phase-2
    name: 'CLI Commands — PRD Display'
    description: >
      Add PRD spec content display to both feat show and feat review commands. Show command
      adds a "PRD Spec" textBlock (following existing Plan/Messages/Awaiting Approval pattern).
      Review command adds inline console.log statements (following its existing color pattern).
      Both conditionally display when specPath exists + waiting_approval + node:requirements.
      Phase 2 is independent of Phase 1 (no API route dependency for CLI).
    parallel: false

  - id: phase-3
    name: 'Web UI Drawer — PRD Section & Stories'
    description: >
      Add the conditional PRD section to the FeatureDrawer component that fetches spec
      content from the Phase 1 API route and displays it with summary, open questions
      (Badge components), and scrollable content (ScrollArea). Add comprehensive Storybook
      stories covering all states. Depends on Phase 1 for the API route.
    parallel: false

filesToCreate:
  - src/presentation/web/app/api/features/[id]/spec/route.ts
  - tests/unit/presentation/web/api/features/spec/route.test.ts
  - tests/unit/presentation/cli/commands/feat/show-prd.test.ts
  - tests/unit/presentation/cli/commands/feat/review-prd.test.ts

filesToModify:
  - packages/core/src/infrastructure/di/container.ts
  - src/presentation/cli/commands/feat/show.command.ts
  - src/presentation/cli/commands/feat/review.command.ts
  - src/presentation/web/components/common/feature-drawer/feature-drawer.tsx
  - src/presentation/web/components/common/feature-drawer/feature-drawer.stories.tsx

openQuestions: []

content: |
  ## Architecture Overview

  This feature is a pure presentation-layer change that reads an existing disk artifact
  (spec.yaml) and displays it in three surfaces: CLI show, CLI review, and Web UI drawer.

  **Data flow:**
  - CLI: `show.command.ts` / `review.command.ts` -> `readFileSync(specPath + '/spec.yaml')` -> `yaml.load()` -> cast to `FeatureSpec` -> format and display
  - Web: `feature-drawer.tsx` -> `fetch('/api/features/{id}/spec')` -> `route.ts` -> `resolve('ShowFeatureUseCase')` -> `feature.specPath` -> `readFileSync` + `yaml.load` -> JSON response -> drawer renders

  **Conditional display logic (identical across all surfaces):**
  - CLI show: `feature.specPath && run?.status === 'waiting_approval' && run?.result === 'node:requirements'`
  - CLI review: `feature.specPath && run.result === 'node:requirements'` (run is already guaranteed waiting_approval by resolveWaitingFeature)
  - Web drawer: `selectedNode.state === 'action-required' && selectedNode.lifecycle === 'requirements'` (derive-feature-state.ts already maps waiting_approval to action-required)

  **Integration points:**
  - `ShowFeatureUseCase` (packages/core) returns Feature with `specPath?: string`
  - `spec.yaml` at `feature.specPath + '/spec.yaml'` -- specPath is the directory
  - `FeatureSpec` type from `@/domain/generated/output.js` for type casting
  - `renderDetailView` textBlocks array for CLI show (detail-view.ts lines 74-83)
  - Direct console.log with `colors.muted`/`colors.accent` for CLI review (review.command.ts lines 39-44)
  - `Drawer` sections pattern with `Separator` for Web drawer (feature-drawer.tsx lines 79-111)

  ## Key Design Decisions

  ### 1. Direct YAML Reading at Each Call Site (NFR-9)
  Each of the 3 call sites (CLI show, CLI review, API route) performs its own
  `readFileSync` + `yaml.load` + try/catch. This is a deliberate 3-line pattern -- creating
  a shared utility is premature for 3 call sites and the spec explicitly prohibits it.
  The spec.yaml files are structured artifacts (not raw AI output) so the sanitization
  logic in `safeYamlLoad` from node-helpers.ts is unnecessary.

  ### 2. ShowFeatureUseCase String-Token Alias
  The DI container registers ShowFeatureUseCase as a class singleton (line 255) but lacks
  a string-token alias. All other web-route use cases (Create, List, Delete) have one
  (lines 263-271). Adding `container.register('ShowFeatureUseCase', ...)` follows this
  exact pattern. Required because Turbopack cannot resolve .js-to-.ts imports inside
  @shepai/core packages.

  ### 3. On-Demand API Fetch for Web UI
  The drawer fetches spec content from `/api/features/[id]/spec` only when opened for a
  feature in action-required/requirements state. This avoids bloating FeatureNodeData with
  large content for all features on every page load. The API route returns 404 when specPath
  is missing or spec.yaml doesn't exist.

  ### 4. ScrollArea + Badge for Web UI Display
  Uses existing shadcn components: ScrollArea (components/ui/scroll-area.tsx) with max-height
  400px for long content, Badge (components/ui/badge.tsx) with variant styling for
  resolved/unresolved open questions. No react-markdown dependency added.

  ### 5. CLI Content Truncation at 50 Lines
  `content.split('\n').slice(0, 50)` with a `[truncated]` notice and path reference.
  Keeps terminal output manageable while providing enough context for approval decisions.
  Web UI shows full content in ScrollArea (no truncation).

  ### 6. Separate Test Files for PRD Logic
  New test files `show-prd.test.ts` and `review-prd.test.ts` keep PRD-specific tests
  isolated from existing show/review tests, following the pattern where existing tests
  already cover phase timing and approval context.

  ## Implementation Strategy

  Phase 1 (Foundation) is quick -- one line in container.ts plus a ~30-line API route with
  tests. This unblocks Phase 3 (Web UI) which depends on the API.

  Phase 2 (CLI) is independent of Phase 1 and could theoretically run in parallel, but
  sequencing it second allows test patterns established in Phase 1 to inform Phase 2 tests.

  Phase 3 (Web UI) depends on Phase 1's API route. It modifies the existing drawer component
  and adds stories for all PRD-related states.

  Each phase follows strict TDD: write failing tests first (RED), implement minimal code
  to pass (GREEN), then clean up (REFACTOR).

  ## Risk Mitigation

  | Risk | Mitigation |
  | ---- | ---------- |
  | spec.yaml missing or malformed | Every call site wraps readFileSync + yaml.load in try/catch. CLI silently omits PRD section. API route returns 404. No crashes. |
  | FeatureSpec type mismatch | Cast with `as FeatureSpec` after yaml.load. YAML structure matches TypeSpec-generated type. Tests verify with real YAML structures. |
  | API route fails without string token | Task 1 adds the DI token first. Phase 3 tests mock resolve. |
  | Drawer duplicate fetches on re-render | useEffect with proper dependency array (featureId + state conditions). Loading state prevents UI flash. |
  | Long spec overwhelms CLI | 50-line truncation with path reference. Tested explicitly. |
  | ScrollArea sizing on different screens | Fixed max-h-[400px] with overflow-auto works consistently. |
