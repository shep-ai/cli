# Feature Specification (YAML)
# This is the source of truth. Markdown is auto-generated from this file.

name: notification-center
number: 048
branch: feat/048-notification-center
oneLiner: Persistent in-app notification center with chronological feed, read/unread state, and filtering

summary: >
  Add a Notification Center to the Shep web UI — a persistent, scrollable panel accessible via a bell icon
  that aggregates all agent lifecycle notification events (including dismissed toasts) into a durable,
  filterable feed with read/unread state, severity grouping, deep-link navigation, and bulk mark-as-read.

phase: Requirements
sizeEstimate: L

relatedFeatures: []

technologies:
  - TypeScript
  - TypeSpec (tsp/ domain models)
  - React 19 (client components, hooks, context)
  - Next.js 16+ (App Router, server components, API routes)
  - shadcn/ui + Radix primitives (Popover, ScrollArea, Badge, Button)
  - Tailwind CSS 4 (styling, cn() utility)
  - Sonner (existing toast system — integration point)
  - SQLite / better-sqlite3 (notification persistence)
  - SSE / EventSource (existing real-time event delivery)
  - Service Worker (existing agent-events-sw.js)
  - Vitest + Testing Library (unit tests)
  - Storybook 8 (component stories)
  - Playwright (e2e tests)
  - lucide-react (Bell, BellDot, Check, Filter icons)
  - class-variance-authority (CVA variants)
  - tsyringe (DI container registration)

relatedLinks: []

openQuestions:
  - question: 'Should the notification panel be a Popover or a full Drawer/Sheet?'
    resolved: true
    options:
      - option: 'Popover panel'
        description: >
          Lightweight overlay anchored to the bell icon. Fast to open/close, does not obscure the main workspace.
          Matches patterns used by GitHub, GitLab, and most SaaS tools. Constrained width (~400px) keeps it
          focused. Can scroll internally with ScrollArea. Best for a quick-scan use case where users check
          notifications and return to work.
        selected: true
      - option: 'Drawer/Sheet panel'
        description: >
          Full-height side panel (like a sheet) that slides in from the right. Provides more vertical space for
          long notification lists and filtering. Better for power-user workflows with hundreds of notifications.
          However, it obscures part of the main content and feels heavier for a quick check.
        selected: false
      - option: 'Dedicated page route'
        description: >
          Full-page notification view at /notifications. Maximum space for filtering, search, and bulk
          operations. However, navigating away from the current page is disruptive for the quick-check
          use case and adds routing complexity.
        selected: false
    selectionRationale: >
      A Popover panel is recommended because the primary use case is quick-scan: the user clicks the bell,
      glances at recent notifications, marks some as read, and returns to work. This matches the interaction
      pattern of every major development tool (GitHub, GitLab, Jira). A Popover is also simpler to implement
      with shadcn/ui's existing Popover primitive. If power users later need a full-page view, it can be added
      as a follow-up without breaking the Popover.
    answer: 'Popover panel'

  - question: 'What notification retention policy should be applied?'
    resolved: true
    options:
      - option: '30-day retention'
        description: >
          Automatically delete notifications older than 30 days. Keeps the DB lean for local SQLite, prevents
          unbounded growth. 30 days is generous enough that users rarely need older notifications, and agent
          runs older than a month are unlikely to be actionable.
        selected: true
      - option: '7-day retention'
        description: >
          Aggressive cleanup. Keeps DB very small but may frustrate users who check infrequently or work
          on long-running features.
        selected: false
      - option: 'No automatic retention (manual only)'
        description: >
          Never auto-delete. User manually clears notifications. Risk of unbounded DB growth over time,
          though individual notification rows are small (~500 bytes).
        selected: false
    selectionRationale: >
      30-day retention strikes the right balance for a local-first tool. Shep runs on the user's machine with
      a local SQLite DB, so storage is cheap but not unlimited. 30 days covers typical feature development
      cycles. Retention cleanup runs opportunistically (e.g., on startup or when listing notifications), not
      via a background scheduler, keeping implementation simple.
    answer: '30-day retention'

  - question: 'How should the notification center get new notifications — polling the REST API or listening to the existing SSE stream?'
    resolved: true
    options:
      - option: 'Poll REST API'
        description: >
          The notification center hook polls GET /api/notifications/unread-count every few seconds. Simple,
          stateless, and decoupled from the SSE pipeline. However, adds extra HTTP requests and introduces
          latency between event occurrence and badge update.
        selected: false
      - option: 'Reuse existing SSE stream via AgentEventsProvider'
        description: >
          The notification center hook consumes the existing AgentEventsProvider context. When a new SSE event
          arrives, the hook persists it (via POST to the API) and updates the local feed state. Zero additional
          network connections, instant badge updates, and leverages the existing Service Worker connection.
          The REST API is only used for initial load and explicit actions (mark-as-read, filter).
        selected: true
      - option: 'Dedicated SSE stream for notifications'
        description: >
          A separate SSE endpoint (/api/notifications/stream) that watches the notifications table. Provides
          real-time updates independent of agent events. However, adds a second SSE connection per tab (or
          requires Service Worker changes) and duplicates infrastructure.
        selected: false
    selectionRationale: >
      Reusing the existing SSE stream via AgentEventsProvider is recommended because it is the most efficient
      approach — no new connections, no polling overhead, and instant reactivity. The current pipeline already
      delivers NotificationEvents to the client; the notification center hook simply intercepts these events,
      persists them via a fire-and-forget POST, and appends them to the local feed state. REST endpoints
      handle initial page load (GET list), mark-as-read, and filtering. This keeps the architecture simple
      and avoids a second SSE channel.
    answer: 'Reuse existing SSE stream via AgentEventsProvider'

  - question: 'Should notification persistence happen on the server side (in NotificationService.notify) or on the client side (via API call when SSE event is received)?'
    resolved: true
    options:
      - option: 'Server-side persistence in NotificationService'
        description: >
          Modify the existing NotificationService.notify() to also write to the notifications table via
          INotificationRepository. Every event is persisted at the source, regardless of whether any client
          is connected. This ensures completeness — no notifications are lost even if the web UI is closed.
          The notification center UI reads from the same DB via REST API.
        selected: true
      - option: 'Client-side persistence via API call'
        description: >
          The client hook receives SSE events and POST them to a new API endpoint for persistence. Simpler
          server-side change, but events are only persisted when a web client is connected. Notifications
          generated while no browser tab is open would be lost — defeating the core purpose.
        selected: false
    selectionRationale: >
      Server-side persistence is the correct choice because the entire motivation for the notification center
      is to capture events that would otherwise be lost when the user is away. Persisting in NotificationService
      ensures every event is stored regardless of client state. The NotificationService already has the fan-out
      responsibility (bus + desktop), so adding a repository write is a natural extension. The notification
      center UI simply reads from the populated table.
    answer: 'Server-side persistence in NotificationService'

  - question: 'Should clicking a notification navigate to the feature detail page?'
    resolved: true
    options:
      - option: 'Deep-link to feature page'
        description: >
          Clicking a notification navigates to /features/[featureId] (or the relevant detail view) and closes
          the popover. Provides direct access to the context that generated the notification. Natural UX for
          actionable notifications like "waiting for approval" or "agent failed".
        selected: true
      - option: 'No navigation, read-only feed'
        description: >
          Notifications are informational only. No click-through navigation. Simpler to implement but reduces
          the utility of the notification center — users would need to manually find the relevant feature.
        selected: false
    selectionRationale: >
      Deep-linking is recommended because notifications derive from feature-specific agent events, and users
      almost always want to see the feature context (especially for failures and approval requests). The
      featureId is already present on every NotificationEvent, so building the link is trivial. This also
      mirrors the existing toast behavior for WaitingApproval events, which already has a "Review" button
      that navigates to the feature.
    answer: 'Deep-link to feature page'

  - question: 'What filtering options should the notification center support?'
    resolved: true
    options:
      - option: 'Severity filter only'
        description: >
          Filter by severity (Info, Warning, Success, Error). Simple toggle chips. Covers the most common
          use case — "show me only errors and warnings". Minimal UI complexity.
        selected: false
      - option: 'Severity + read/unread filter'
        description: >
          Filter by severity AND by read/unread state. Two filter dimensions cover the primary use cases:
          (1) triage by severity, (2) focus on unseen items. This is the sweet spot of utility vs. complexity.
        selected: true
      - option: 'Severity + read/unread + feature + event type'
        description: >
          Full filter matrix. Maximum flexibility but adds significant UI complexity (multi-select dropdowns,
          filter chips, clear-all). Risk of over-engineering for a v1 notification center.
        selected: false
    selectionRationale: >
      Severity plus read/unread filtering covers the two most common workflows: "show me errors" and "show me
      what I haven't seen yet". Adding feature-level or event-type filtering adds UI complexity that is unlikely
      to be used in v1 — users typically have 1-3 active features, and the chronological feed naturally groups
      events by feature. Feature/event-type filters can be added in a follow-up if user feedback warrants it.
    answer: 'Severity + read/unread filter'

  - question: 'Should the unread count badge show the exact number or a capped indicator?'
    resolved: true
    options:
      - option: 'Exact count up to 99, then "99+"'
        description: >
          Show the exact unread count (e.g., "3", "17", "99+"). Precise and informative. Standard pattern
          across most applications. The "99+" cap prevents the badge from becoming absurdly wide.
        selected: true
      - option: 'Dot indicator only (no number)'
        description: >
          A simple colored dot on the bell icon — "you have unread notifications" with no count. Minimalist
          and clean, but less informative. Users cannot gauge urgency without opening the panel.
        selected: false
    selectionRationale: >
      An exact count (capped at 99+) is recommended because it communicates urgency — "3 unread" vs "47 unread"
      tells the user very different things. This is the industry standard pattern (Slack, GitHub, email clients).
      A dot indicator would be sufficient for a v0 but undersells the notification center's value.
    answer: 'Exact count up to 99, then "99+"'

content: |
  ## Problem Statement

  Currently, the Shep web UI dispatches agent lifecycle notifications exclusively as ephemeral Sonner toasts
  and optional browser/desktop notifications (via `useNotifications` hook in `app-shell.tsx`). Once a toast
  is dismissed or auto-hidden, the notification is permanently lost — there is no persistent history. Users
  who step away from the browser, have multiple features running, or simply miss a toast have no way to
  review past events. This creates a reliability gap: important status changes (agent failures, approval
  requests, phase completions) can be silently missed, eroding trust in the autonomous workflow.

  The Notification Center solves this by converting the ephemeral toast stream into a durable, queryable
  notification log with a dedicated UI panel. Every `NotificationEvent` dispatched through `NotificationService`
  will be persisted server-side into a new `notifications` SQLite table. The UI will provide a bell icon with
  unread count badge, a popover feed panel, read/unread management, severity-based filtering, and deep-link
  navigation to the relevant feature.

  ## Success Criteria

  - [ ] A bell icon appears in the AppShell top-right toolbar (next to SoundToggle and ThemeToggle)
  - [ ] The bell icon displays an unread count badge (exact count, capped at "99+") when unread notifications exist
  - [ ] Clicking the bell icon opens a Popover panel displaying a chronological notification feed (newest first)
  - [ ] Every NotificationEvent dispatched via NotificationService is persisted to a `notifications` SQLite table
  - [ ] Notifications that occurred while the web UI was closed appear in the feed when the user returns
  - [ ] Each notification item shows: severity icon, feature name, message, relative timestamp, and read/unread state
  - [ ] Users can mark individual notifications as read by clicking them
  - [ ] Users can mark all notifications as read via a "Mark all read" button
  - [ ] Users can filter notifications by severity (Info, Warning, Success, Error)
  - [ ] Users can filter notifications by read/unread state
  - [ ] Clicking a notification navigates to the associated feature page and closes the popover
  - [ ] Notifications older than 30 days are automatically cleaned up
  - [ ] An empty state is shown when there are no notifications (or no matches for the current filter)
  - [ ] The notification center works across multiple browser tabs (via the existing Service Worker SSE connection)
  - [ ] All new components have colocated Storybook stories
  - [ ] Unit tests cover: repository, mapper, use cases, hook, and all UI components
  - [ ] Integration tests cover: notification persistence flow and API routes
  - [ ] E2e test covers: full notification lifecycle (event → persistence → feed display → mark as read)
  - [ ] The existing toast and browser notification behavior is unchanged (notification center is additive)

  ## Functional Requirements

  ### Domain Layer

  - **FR-1**: Define a `Notification` entity in TypeSpec (`tsp/domain/entities/notification.tsp`) extending `BaseEntity` with fields: `eventType` (NotificationEventType), `agentRunId` (string), `featureId` (string), `featureName` (string), `phaseName` (optional string), `message` (string), `severity` (NotificationSeverity), `isRead` (boolean, default false), `readAt` (optional utcDateTime), and `eventTimestamp` (utcDateTime — the original event time). The entity inherits `id`, `createdAt`, `updatedAt` from `BaseEntity`.

  - **FR-2**: Define a `NotificationListFilters` model in TypeSpec with optional fields: `severity` (NotificationSeverity), `isRead` (boolean), `featureId` (string), `limit` (integer, default 50), `offset` (integer, default 0). This supports paginated, filtered queries.

  ### Application Layer

  - **FR-3**: Define an `INotificationRepository` output port interface in `application/ports/output/repositories/` with methods: `create(notification: Notification): Promise<void>`, `findById(id: string): Promise<Notification | null>`, `list(filters?: NotificationListFilters): Promise<Notification[]>`, `markAsRead(id: string): Promise<void>`, `markAllAsRead(): Promise<void>`, `getUnreadCount(): Promise<number>`, `deleteOlderThan(date: Date): Promise<number>`.

  - **FR-4**: Implement `CreateNotificationUseCase` — accepts a NotificationEvent, maps it to a Notification entity with a generated UUID and `isRead: false`, and calls `repository.create()`.

  - **FR-5**: Implement `ListNotificationsUseCase` — accepts optional `NotificationListFilters`, delegates to `repository.list()`, returns an array of Notification entities.

  - **FR-6**: Implement `MarkNotificationReadUseCase` — accepts a notification `id`, calls `repository.markAsRead(id)`. Returns void. Throws if notification not found.

  - **FR-7**: Implement `MarkAllNotificationsReadUseCase` — calls `repository.markAllAsRead()`. No input required.

  - **FR-8**: Implement `GetUnreadCountUseCase` — calls `repository.getUnreadCount()`, returns the integer count.

  - **FR-9**: Implement `CleanupOldNotificationsUseCase` — computes a date 30 days in the past, calls `repository.deleteOlderThan(date)`, returns the number of deleted rows.

  ### Infrastructure Layer

  - **FR-10**: Add SQLite migration (version 24) creating a `notifications` table with columns: `id` (TEXT PRIMARY KEY), `event_type` (TEXT NOT NULL), `agent_run_id` (TEXT NOT NULL), `feature_id` (TEXT NOT NULL), `feature_name` (TEXT NOT NULL), `phase_name` (TEXT), `message` (TEXT NOT NULL), `severity` (TEXT NOT NULL), `is_read` (INTEGER NOT NULL DEFAULT 0), `read_at` (TEXT), `event_timestamp` (TEXT NOT NULL), `created_at` (TEXT NOT NULL), `updated_at` (TEXT NOT NULL). Add indexes on `is_read`, `severity`, `feature_id`, and `created_at` for efficient filtering and sorting.

  - **FR-11**: Implement `SQLiteNotificationRepository` in `infrastructure/repositories/` following the existing repository pattern. Use a `notification.mapper.ts` for row-to-entity conversion.

  - **FR-12**: Modify `NotificationService.notify()` to inject `INotificationRepository` and call `CreateNotificationUseCase` (or repository directly) to persist every dispatched event, in addition to the existing bus emit and desktop notifier fan-out. Persistence must not block or fail the existing notification pipeline — wrap in try/catch with error logging.

  - **FR-13**: Register all new components in the DI container (`container.ts`): `INotificationRepository` (factory with DB injection), all notification use cases (singletons), and string-token aliases for web route resolution.

  - **FR-14**: Run `CleanupOldNotificationsUseCase` opportunistically — on application startup and/or when `ListNotificationsUseCase` is called (with a throttle to avoid running on every request). This avoids the need for a background scheduler.

  ### Presentation Layer — API Routes

  - **FR-15**: `GET /api/notifications` — Accepts query parameters: `severity`, `isRead`, `featureId`, `limit` (default 50), `offset` (default 0). Returns `{ notifications: Notification[], total: number }`. Validates input with Zod.

  - **FR-16**: `PATCH /api/notifications/[id]/read` — Marks a single notification as read. Returns `{ success: true }` or 404.

  - **FR-17**: `POST /api/notifications/mark-all-read` — Marks all notifications as read. Returns `{ success: true }`.

  - **FR-18**: `GET /api/notifications/unread-count` — Returns `{ count: number }`.

  ### Presentation Layer — UI Components

  - **FR-19**: Create a `NotificationCenter` component (tier: `common/notification-center/`) consisting of:
    - **NotificationBell**: Bell icon button with unread count badge. Uses `BellDot` icon when unread > 0, `Bell` when all read. Badge shows exact count, capped at "99+".
    - **NotificationPanel**: Popover content panel (~400px wide, max 70vh tall) with a header ("Notifications"), filter bar, scrollable notification list, and footer with "Mark all read" button.
    - **NotificationFilterBar**: Toggle chips for severity filters (Info, Warning, Success, Error) and a read/unread dropdown or toggle. Active filters are visually indicated.
    - **NotificationItem**: Individual notification row showing: severity-colored icon, feature name (bold), message text, relative timestamp (e.g., "2m ago", "1h ago"), and unread indicator (dot or bold styling). Entire row is clickable for navigation.
    - **NotificationEmptyState**: Friendly empty state shown when no notifications match the current filter. Different messages for "no notifications yet" vs "no matching notifications".

  - **FR-20**: Create a `useNotificationCenter` hook that:
    - Fetches the initial notification list from `GET /api/notifications` on mount
    - Fetches the unread count from `GET /api/notifications/unread-count` on mount
    - Subscribes to `AgentEventsProvider` context to detect new SSE events and prepend them to the local feed state (optimistic update), then refreshes the list from the server to ensure consistency
    - Provides `markAsRead(id)`, `markAllAsRead()` functions that call the respective API endpoints and optimistically update local state
    - Manages filter state (severity, read/unread) and re-fetches when filters change
    - Exposes: `notifications`, `unreadCount`, `filters`, `setFilters`, `markAsRead`, `markAllAsRead`, `isLoading`, `isEmpty`

  - **FR-21**: Integrate `NotificationBell` into the AppShell top-right toolbar, positioned between `SoundToggle` and `ThemeToggle`. The bell triggers the Popover containing `NotificationPanel`.

  - **FR-22**: Each notification item click: (a) calls `markAsRead(id)` if unread, (b) navigates to `/features/[featureId]` using Next.js router, (c) closes the popover.

  ### Testing

  - **FR-23**: Write Storybook stories for all new components: `NotificationBell` (with/without unread count), `NotificationPanel` (populated, empty, loading), `NotificationFilterBar` (various active filter states), `NotificationItem` (each severity, read/unread), `NotificationEmptyState`.

  - **FR-24**: Write unit tests (Vitest + Testing Library) for: `SQLiteNotificationRepository` (CRUD, filtering, pagination), `notification.mapper.ts` (row mapping, edge cases), all five use cases, `useNotificationCenter` hook (mock API calls), all UI components (render, interaction).

  - **FR-25**: Write integration tests for: notification persistence end-to-end (NotificationService.notify → DB → API → response), API route request/response validation.

  - **FR-26**: Write Playwright e2e test covering: bell icon visibility, open popover, see notification list, filter by severity, mark as read, mark all as read, navigate to feature from notification.

  ## Non-Functional Requirements

  - **NFR-1 — Performance**: The notification list API (`GET /api/notifications`) must respond within 100ms for up to 1,000 stored notifications. SQLite indexes on `is_read`, `severity`, `feature_id`, and `created_at` must ensure efficient queries.

  - **NFR-2 — Responsiveness**: The unread count badge must update within 2 seconds of a new notification event being emitted (leveraging the existing SSE stream, not requiring a separate poll).

  - **NFR-3 — Non-blocking persistence**: Notification persistence in `NotificationService.notify()` must not block or slow down the existing bus emit or desktop notification fan-out. A persistence failure must be logged but must not throw or prevent the event from being delivered through existing channels.

  - **NFR-4 — Storage efficiency**: Individual notification rows must be compact (~500 bytes). With 30-day retention and typical usage (~50 notifications/day), the notifications table stays under 1MB. The cleanup mechanism must prevent unbounded growth.

  - **NFR-5 — Accessibility**: The notification bell must have appropriate `aria-label` ("Notifications, N unread"). The popover must be keyboard-navigable (Tab through items, Enter to select, Escape to close). Notification items must have appropriate ARIA roles and labels. Severity is conveyed through both color and icon shape (not color alone).

  - **NFR-6 — Multi-tab consistency**: Since the existing Service Worker maintains a single SSE connection shared across tabs, new notifications should appear in all open tabs. Marking notifications as read in one tab should be reflected in other tabs within a reasonable timeframe (next poll or focus event).

  - **NFR-7 — Graceful degradation**: If the notifications table is unavailable (e.g., migration not yet applied), the notification center should hide the bell icon or show an empty state rather than crashing the UI. The existing toast pipeline must remain unaffected.

  - **NFR-8 — Architectural compliance**: All new code must follow the existing Clean Architecture patterns — domain entities in `tsp/`, output port interfaces in `application/ports/output/`, concrete implementations in `infrastructure/`, DI registration with tsyringe, four-tier component hierarchy in web UI.

  - **NFR-9 — Test coverage**: All new code must have corresponding tests per the TDD mandate. Minimum coverage: unit tests for every public method in repository, use cases, and components; integration tests for the persistence-to-API flow; at least one e2e scenario.

  - **NFR-10 — Bundle impact**: The notification center components must not significantly increase the client-side JavaScript bundle. Use dynamic imports or lazy loading for the popover content if it exceeds 10KB gzipped.

  ## Product Questions & AI Recommendations

  | # | Question | AI Recommendation | Rationale |
  | - | -------- | ----------------- | --------- |
  | 1 | Popover vs Drawer vs full page? | Popover panel | Quick-scan UX, lightweight, matches GitHub/GitLab patterns, uses existing shadcn Popover |
  | 2 | Notification retention policy? | 30-day auto-cleanup | Balances storage with utility for local SQLite; covers typical feature dev cycles |
  | 3 | Real-time update mechanism? | Reuse existing SSE via AgentEventsProvider | Zero new connections, instant updates, leverages Service Worker |
  | 4 | Server-side or client-side persistence? | Server-side in NotificationService | Ensures events are captured even when no browser is open — the core value prop |
  | 5 | Deep-link navigation on click? | Yes, navigate to feature page | featureId is already on every event; mirrors existing toast Review button behavior |
  | 6 | Filter dimensions? | Severity + read/unread | Covers primary workflows without UI bloat; feature/event-type filters can follow later |
  | 7 | Unread badge format? | Exact count, capped at "99+" | Industry standard, communicates urgency, simple to implement |

  ## Affected Areas

  | Area | Impact | Reasoning |
  | ---- | ------ | --------- |
  | `tsp/domain/entities/` | High | New `Notification` entity model (persisted version of `NotificationEvent` with `id`, `isRead`, `readAt`) |
  | `packages/core/src/domain/generated/output.ts` | High | Auto-generated from new TypeSpec model (do not edit directly) |
  | `packages/core/src/application/ports/output/repositories/` | High | New `INotificationRepository` output port interface |
  | `packages/core/src/application/use-cases/notifications/` | High | New use cases: `CreateNotificationUseCase`, `ListNotificationsUseCase`, `MarkNotificationReadUseCase`, `MarkAllNotificationsReadUseCase`, `GetUnreadCountUseCase`, `CleanupOldNotificationsUseCase` |
  | `packages/core/src/infrastructure/repositories/` | High | New `SQLiteNotificationRepository` implementation |
  | `packages/core/src/infrastructure/persistence/sqlite/migrations.ts` | High | New migration (version 24) creating `notifications` table with indexes |
  | `packages/core/src/infrastructure/persistence/sqlite/mappers/` | Medium | New `notification.mapper.ts` for row-to-entity mapping |
  | `packages/core/src/infrastructure/di/container.ts` | Medium | Register new repository, use cases, and string-token aliases |
  | `packages/core/src/infrastructure/services/notifications/notification.service.ts` | Medium | Inject INotificationRepository and persist events alongside existing fan-out |
  | `src/presentation/web/app/api/notifications/` | High | New API routes: `GET /api/notifications`, `PATCH /api/notifications/[id]/read`, `POST /api/notifications/mark-all-read`, `GET /api/notifications/unread-count` |
  | `src/presentation/web/hooks/` | High | New `useNotificationCenter` hook (fetch feed, filters, mark-as-read, unread count, SSE integration) |
  | `src/presentation/web/components/common/notification-center/` | High | New component suite: NotificationBell, NotificationPanel, NotificationFilterBar, NotificationItem, NotificationEmptyState |
  | `src/presentation/web/components/layouts/app-shell/app-shell.tsx` | Medium | Add NotificationBell to the top-right action bar |
  | `src/presentation/web/components/common/index.ts` | Low | Re-export new notification-center component |
  | `tests/unit/` | High | Unit tests for repository, mapper, use cases, hook, components |
  | `tests/integration/` | Medium | Integration tests for notification persistence and API routes |
  | `tests/e2e/` | Medium | Playwright tests for notification center UI flow |

  ## Dependencies

  ### Existing Code Dependencies
  - **`NotificationEvent` type** (`domain/generated/output.ts`): The new `Notification` entity wraps this existing type's fields with persistence metadata (`id`, `isRead`, `readAt`, `createdAt`, `updatedAt`).
  - **`BaseEntity`** (`tsp/domain/entities/base.tsp`): The Notification entity extends BaseEntity for standard `id`, `createdAt`, `updatedAt` fields.
  - **`NotificationService`** (`infrastructure/services/notifications/notification.service.ts`): Must be modified to inject `INotificationRepository` and persist events alongside existing fan-out.
  - **`INotificationService` port** (`application/ports/output/services/notification-service.interface.ts`): Interface may need updating if constructor dependencies change.
  - **SSE pipeline** (`app/api/agent-events/route.ts`, `useAgentEvents`, `AgentEventsProvider`): Existing real-time delivery mechanism stays unchanged; notification center hook consumes the same context for instant updates.
  - **`AppShell`** (`components/layouts/app-shell/app-shell.tsx`): Integration point for the bell icon in the top-right toolbar.
  - **SQLite connection and migration system** (`infrastructure/persistence/sqlite/`): Pattern for new table (migration version 24).
  - **DI container** (`infrastructure/di/container.ts`): Registration pattern for new repository and use cases.

  ### Library Dependencies (already installed)
  - `better-sqlite3` — database
  - `radix-ui` (via shadcn/ui) — Popover, ScrollArea primitives
  - `lucide-react` — Bell, BellDot, Check, Filter, CheckCheck icons
  - `class-variance-authority` — CVA for notification item severity variants
  - `sonner` — toast integration (existing, unchanged)
  - `zod` — input validation for new API routes

  ### No New External Dependencies Required
  All needed libraries are already in the project's dependency tree.

  ## Size Estimate

  **L** — This feature spans all four Clean Architecture layers (TypeSpec domain model, 6 application use cases,
  infrastructure repository/migration/mapper/service modification, 4 API routes, 1 React hook, 5+ UI components),
  requires a new SQLite table with migration, and comprehensive test coverage (unit, integration, e2e, Storybook
  stories across ~25+ files). The scope is well-defined with no external dependency risk. Estimated 5-7 working
  days of TDD-driven implementation.

  ---

  _Requirements defined — proceed with research_
