name: merge-review-drawer
summary: >
  The merge review drawer follows the proven 5-file component pattern (config, content, drawer,
  stories, barrel) established by prd-questionnaire and tech-decisions-review. The server action
  reads Feature.pr (already persisted before the merge interrupt in merge.node.ts:226-238) and calls
  IGitPrService.getPrDiffSummary() with graceful fallback. Additionally, it loads plan phases from
  GetPlanArtifactUseCase (best-effort) and constructs branch direction from Feature.branch.
  No new dependencies, no domain model changes, and no backend modifications are needed — all data,
  icons, and UI primitives are already available in the codebase. Codebase verification confirms the
  feature is already fully implemented on this branch.

relatedFeatures: []

technologies:
  - React 19 (Next.js 16+ App Router)
  - shadcn/ui (Radix + Tailwind CSS v4)
  - React Flow (@xyflow/react)
  - Storybook 8
  - Vaul (drawer primitive via ReviewDrawerShell)
  - Lucide React (GitMerge, GitBranch, ArrowRight, ExternalLink, FileDiff, GitCommitHorizontal, Layers, AlertTriangle, CheckCircle2, XCircle, Loader2)
  - sonner (toast notifications)
  - tsyringe (DI container for server actions via resolve())
  - CiStatusBadge (existing shared component)
  - DrawerActionBar (existing shared component with approve/reject pattern)

relatedLinks: []

decisions:
  - title: 'Server Action Architecture for Merge Review Data'
    chosen: >
      Direct server action (get-merge-review-data.ts) that resolves IFeatureRepository,
      IGitPrService, and GetPlanArtifactUseCase via DI. Reads Feature.pr for PR metadata,
      constructs branch direction from Feature.branch, loads plan phases (best-effort), and
      calls getPrDiffSummary() with graceful fallback. Returns a union type
      MergeReviewData | { error: string }.
    rejected:
      - >
        Create a dedicated use case class (e.g., GetMergeReviewDataUseCase): Rejected because
        the existing server action pattern (get-feature-artifact.ts at 56 lines,
        get-research-artifact.ts at 43 lines) resolves repositories and services directly
        via resolve() without a dedicated use case. The merge review data retrieval is a
        composed read operation that doesn't warrant its own use case class — it would add
        unnecessary indirection. The server action already follows the established pattern:
        validate input, resolve dependencies via resolve<T>('Token'), return typed result
        with optional error.
      - >
        Return data from the LangGraph checkpoint interrupt payload: Rejected because it
        couples the UI layer to LangGraph internals, checkpoint format may change between
        versions, and Feature.pr is already persisted before the interrupt
        (merge.node.ts:226-238). The interrupt payload contains diffSummary, prUrl, prNumber,
        and ciStatus, but this data is duplicated on Feature.pr which is persisted to SQLite
        and always available during the Review phase.
    rationale: >
      The server action pattern is established in the codebase (approve-feature.ts at 38 lines,
      get-feature-artifact.ts at 56 lines, get-research-artifact.ts at 43 lines). Each action
      uses 'use server', validates input, resolves dependencies via resolve<T>('Token'), and
      returns a typed result with optional error. The merge review action follows this exact
      pattern but is slightly more complex: it resolves three dependencies (IFeatureRepository,
      GetPlanArtifactUseCase, IGitPrService) and uses nested try/catch blocks for best-effort
      loading of phases and diff summary. The server action file (get-merge-review-data.ts) is
      ~65 lines, matching the complexity of get-feature-artifact.ts. The action imports the
      MergeReviewData type from merge-review-config.ts (the component config), keeping the data
      contract co-located with the consumer.

  - title: 'Component Directory Structure'
    chosen: >
      5-file pattern at components/common/merge-review/ matching prd-questionnaire and
      tech-decisions-review: merge-review-config.ts (types and interfaces), merge-review.tsx
      (content component), merge-review-drawer.tsx (shell wrapper), merge-review.stories.tsx
      (stories), index.ts (barrel exports)
    rejected:
      - >
        Single-file component: Rejected because it violates the established pattern and
        mixes type definitions, content rendering, shell integration, and stories into one
        file. The codebase convention separates config (types), content, drawer wrapper,
        stories, and barrel export into dedicated files for single responsibility. Both
        prd-questionnaire/ and tech-decisions-review/ follow this exact structure.
      - >
        Place in features/ tier (Tier 3) instead of common/ (Tier 1): Rejected because
        prd-questionnaire and tech-decisions-review are both in components/common/ as
        Tier 1 shared domain components. The merge review drawer is the same kind of
        component — a domain-specific review drawer used by the control center. Placing
        it in features/ would break the parallel structure and the expectation that all
        review drawers live in common/.
    rationale: >
      The 5-file pattern is used by both existing review drawers: prd-questionnaire/
      (prd-questionnaire-config.ts, prd-questionnaire.tsx, prd-questionnaire-drawer.tsx,
      prd-questionnaire.stories.tsx, index.ts) and tech-decisions-review/ (same structure
      with tech-decisions-review-config.ts, tech-decisions-review.tsx,
      tech-decisions-drawer.tsx, tech-decisions-review.stories.tsx, index.ts). Following
      this pattern ensures consistency, makes the component discoverable, and allows the
      content component to be used independently from the drawer shell (useful for Storybook
      stories and potential future reuse). The config file defines: MergeReviewDiffSummary,
      MergeReviewPr, MergeReviewPhase, MergeReviewBranch, MergeReviewData, MergeReviewProps,
      and MergeReviewDrawerProps. The DrawerProps extends Omit<MergeReviewProps, 'data'>
      with data: MergeReviewData | null plus shell props (open, onClose, featureName, etc.),
      following the exact pattern of PrdQuestionnaireDrawerProps and TechDecisionsDrawerProps.

  - title: 'Drawer Content Design — Read-Only with Reject Option'
    chosen: >
      Read-only display showing PR metadata, branch direction, diff summary, CI status,
      implementation phases, and an approve button. Also includes reject via DrawerActionBar
      (with revision input and reject dialog) for consistency with the shared approval pattern,
      even though the primary intent is approve-only.
    rejected:
      - >
        Include interactive chat input for multi-turn refinement (matching PRD/Tech drawer
        conversational flow): Rejected because merge review is fundamentally a binary
        approval decision — there is nothing to iteratively "refine" like requirements
        options or tech plan alternatives. The merge node's LangGraph interrupt flow resumes
        on approval; adding a non-functional chat input would mislead users into thinking
        they can request multi-turn code changes.
      - >
        Full code review interface with file-level diffs: Rejected because this would require
        extending IGitPrService with per-file diff data (modifying the DiffSummary interface),
        dramatically increase component complexity, and duplicate GitHub's code review UI.
        The spec explicitly chose aggregate statistics only. Users who want detailed review
        can click the PR link (rendered with target="_blank" rel="noopener noreferrer").
    rationale: >
      The merge approval gate is fundamentally different from PRD (select options from
      questions with stepper navigation) and tech decisions (review plan with collapsible
      alternatives). Merge review is a go/no-go decision: the code has been implemented,
      the PR has been created, and the user just needs to approve the merge. The PR URL
      provides an escape hatch to GitHub for detailed code review. However, the
      implementation pragmatically includes onReject via DrawerActionBar because: (1) the
      DrawerActionBar component already supports this pattern naturally, (2) the control
      center already has handleMergeReject wired to the shared handleReject() callback
      which calls rejectFeature(), and (3) this allows users to send feedback to the agent
      for revision before merge, which the LangGraph interrupt flow does support. The
      content component (merge-review.tsx at 196 lines) is simpler than prd-questionnaire.tsx
      and tech-decisions-review.tsx because it renders structured data without interactive
      state management.

  - title: 'Feature Node Badge Color Scheme for Review Phase'
    chosen: >
      Emerald (green) color scheme with GitMerge icon: text-emerald-700 badge text,
      bg-emerald-50 badge background, for the action-required state when lifecycle is review
    rejected:
      - >
        Purple/violet with GitPullRequest icon: Rejected because purple doesn't carry
        semantic meaning for merging, and GitPullRequest represents the PR object rather
        than the merge action. This would be less intuitive than green for a "ready to
        merge" state.
      - >
        Reuse the default amber with a different icon only: Rejected because it would make
        the merge review state indistinguishable from PRD review (both amber). The spec
        requires three visually distinct review types: amber (requirements), indigo
        (implementation), green (merge). The three-color progression communicates feature
        maturity at a glance.
    rationale: >
      The emerald color creates a natural semantic progression across review states:
      amber (requirements review) → indigo (tech planning review) → emerald (merge review).
      Green semantically means "ready to proceed / ready to merge", matching GitHub's green
      merge button convention. The GitMerge icon from Lucide React directly communicates
      the merge action. Implementation requires three small additions to feature-node.tsx:
      getBadgeIcon() returns GitMerge when lifecycle='review' (line 24), getBadgeText()
      returns 'Review Merge Request' when lifecycle='review' (line 58),
      getActionRequiredBadgeClasses() returns emerald classes when lifecycle='review'
      (lines 38-39). Note that emerald is already used for the "done" state in
      featureNodeStateConfig (lines 121-130), but there's no collision because the badge
      override only applies to action-required state.

  - title: 'Diff Summary Retrieval and Error Handling'
    chosen: >
      Graceful degradation with nested try/catch: server action wraps getPrDiffSummary()
      in its own try/catch separate from the outer error handler, returns PR metadata
      with diffSummary omitted on failure and a warning string, drawer renders AlertTriangle
      with the warning text instead of the diff section
    rejected:
      - >
        Block the drawer with a full error state: Rejected because the diff summary is
        supplementary display information — blocking the approve action because of a
        display issue would frustrate users. Feature.pr is always available since it's
        persisted before the interrupt. The core action (approve merge) only needs the
        agentRunId, not the diff data.
      - >
        Cache diff summary in Feature entity during merge node: Rejected because it would
        require domain model changes (adding a diffSummary field to PullRequest type in
        TypeSpec), database migration, and changes to merge.node.ts persistence — all of
        which violate NFR-8 (no domain model changes).
    rationale: >
      The server action needs three data sources with different reliability profiles:
      (1) Feature.pr (always available, persisted to SQLite before the interrupt at
      merge.node.ts:226-238), (2) plan phases from GetPlanArtifactUseCase (requires
      spec path and plan.yaml to exist, may fail), (3) diff summary from
      IGitPrService.getPrDiffSummary (requires live git worktree and git binary).
      The implemented approach uses three levels of error handling: outer try/catch for
      fatal errors (feature not found, DI resolution failure), inner try/catch for plan
      phases (best-effort, failures silently produce undefined), and inner try/catch for
      diff summary (failures produce undefined diffSummary + warning string). When
      worktreePath is undefined, the action skips the diff call entirely rather than
      failing. The drawer component (merge-review.tsx) independently handles each section
      being undefined: no pr → PR card omitted, no diffSummary → warning shown or section
      hidden, no phases → phases section omitted, no branch → branch section omitted.

  - title: 'Control Center Integration Pattern'
    chosen: >
      Follow the exact same inline pattern as PRD and Tech Decision drawers in
      control-center-inner.tsx: boolean flag (showMergeReviewDrawer), state for data
      (mergeReviewData), useEffect with cancellation for data fetching, approval callback
      via handleSimpleApprove, reject callback via handleReject, conditional rendering
    rejected:
      - >
        Use a custom hook to encapsulate all merge drawer logic: Rejected for the same
        reason PRD and Tech drawers don't use one — the control center already manages
        all drawer state inline with a clear, repeating pattern. Extracting to a hook
        would break the established pattern, add indirection that doesn't exist for the
        other drawers, and make the data flow harder to trace.
      - >
        Use React Suspense with a server component for data loading: Rejected because
        the control center is a client component ('use client') and the drawer data is
        loaded on-demand when a node is selected. Suspense would require restructuring
        the control center's client-side interaction model, which is out of scope and
        would not match how the other drawers work.
    rationale: >
      The control-center-inner.tsx (464 lines) follows a clear, repeating pattern for
      each review drawer: (1) state declarations for data and loading at the top
      (lines 97-99), (2) boolean visibility condition derived from selectedNode lifecycle +
      state (lines 107-108), (3) useEffect with cancellation pattern for data fetching
      keyed on derived featureId (lines 293-321), (4) approval callback using
      handleSimpleApprove('Merge') (line 219), (5) reject callback using handleReject
      with 'Merge' label (lines 190-193), (6) conditional rendering of MergeReviewDrawer
      when showMergeReviewDrawer is true (lines 434-451). The FeatureDrawer suppression
      extends naturally: the existing condition becomes
      showPrdDrawer || showTechDecisionsDrawer || showMergeReviewDrawer ? null : selectedNode
      (line 389). The error handling in useEffect checks for 'error' in result (discriminated
      union pattern) and shows toast.error, matching the tech decisions useEffect pattern.

  - title: 'CI Status Visual Representation'
    chosen: >
      Reuse the existing CiStatusBadge component (ci-status-badge.tsx at 30 lines) which
      renders color-coded shadcn/ui Badge with Lucide icons and text labels: green/CheckCircle2
      for Success ("Passing"), yellow/Loader2+animate-spin for Pending ("Pending"),
      red/XCircle for Failure ("Failing")
    rejected:
      - >
        Plain text status line without color: Rejected because it lacks visual immediacy.
        Color-coded indicators follow universal CI/CD conventions (green=pass, red=fail,
        yellow=pending) and match GitHub's own status indicators. Users can scan CI status
        at a glance with color.
      - >
        Create a new CI status component with animated progress indicator for pending:
        Rejected because CiStatusBadge already exists and is well-tested. A full progress
        bar would imply deterministic progress when CI status is just a three-state enum.
        The Loader2 spin animation in the existing component is sufficient to convey
        "in progress". Creating a new component would duplicate functionality.
    rationale: >
      The CiStatusBadge component (ci-status-badge.tsx) is a shared component already
      used elsewhere in the codebase. It imports CiStatus from the generated domain types,
      uses shadcn/ui Badge with className overrides for each status variant, and pairs each
      color with both an icon AND text label — satisfying NFR-5 accessibility requirement
      (color-coded badges must include text labels, not color-only). The merge review
      content component (merge-review.tsx) renders it conditionally at line 114:
      {pr.ciStatus ? <CiStatusBadge status={pr.ciStatus} /> : null}. No new component
      needed, no modifications to CiStatusBadge required.

  - title: 'Base Branch Determination in Server Action'
    chosen: >
      Hardcode "main" as the base branch parameter for getPrDiffSummary in the server action,
      despite the merge node using getDefaultBranch(cwd) dynamically
    rejected:
      - >
        Call getDefaultBranch dynamically in the server action: Rejected because
        getDefaultBranch requires git access and adds another potential failure point.
        The server action already wraps getPrDiffSummary in a try/catch for graceful
        degradation, so if 'main' is wrong the call fails gracefully. Adding another
        git call to detect the branch would increase latency and complexity for a
        supplementary display feature.
      - >
        Store the base branch on the Feature entity: Rejected because it requires
        TypeSpec model changes, database migration, and modifications to the merge node
        persistence layer — violating NFR-8 (no domain model changes).
    rationale: >
      The merge node (merge.node.ts:101) uses `const baseBranch = await deps.getDefaultBranch(cwd)`
      to dynamically detect the default branch. However, the server action hardcodes 'main'
      because: (1) the vast majority of repositories use 'main' as the default branch,
      (2) detecting the default branch requires resolving IGitService and making an additional
      git call, adding latency to a display-only feature, (3) if the repo uses 'master' or
      another branch, getPrDiffSummary will fail and the graceful degradation path returns
      PR metadata without diff stats plus a warning — the approve action still works.
      A future enhancement can add dynamic detection if needed. Note: this is a known
      inconsistency between the agent (dynamic) and the server action (static) that
      should be documented.

openQuestions:
  - question: >
      Should the server action resolve Feature.worktreePath for the getPrDiffSummary call,
      or should it use Feature.repositoryPath instead?
    resolved: true
    options:
      - option: 'Use Feature.worktreePath'
        description: >
          Feature.worktreePath is the actual git worktree path where the feature branch
          work happens. This is what merge.node.ts uses (state.worktreePath at line 97:
          `const cwd = state.worktreePath`) when calling getDiffSummary. During the Review
          phase, the worktree should still exist because it is created during feature
          initialization and only cleaned up after the feature reaches Maintain. However,
          worktreePath is optional on the Feature type and may be undefined if the feature
          was created without a worktree.
        selected: true
      - option: 'Use Feature.repositoryPath'
        description: >
          Feature.repositoryPath is the base repository path, always present on every
          Feature. However, diff comparisons happen in the worktree (a separate git
          checkout where HEAD points to the feature branch), not the base repo where HEAD
          may point to main. Using repositoryPath would produce incorrect diff results
          (possibly zero diff) if the feature uses a worktree, which is the standard flow.
        selected: false
      - option: 'Use Feature.repositoryPath with branch checkout'
        description: >
          Use repositoryPath but first check out the feature branch. This is dangerous and
          modifies working state in the base repository. It could disrupt other features or
          ongoing work in the main checkout. Not a viable approach for a read-only display
          operation that should have zero side effects.
        selected: false
    selectionRationale: >
      Feature.worktreePath is the correct path because getPrDiffSummary runs
      git diff baseBranch...HEAD, which must execute in the worktree where HEAD points to
      the feature branch. merge.node.ts uses state.worktreePath (line 97) for exactly
      this reason. The implemented server action (get-merge-review-data.ts) checks
      if worktreePath is undefined first — if so, it skips the diff call entirely and
      returns PR metadata without diff stats (no warning needed since there's nothing
      to warn about — the worktree simply doesn't exist). If worktreePath exists but
      the diff call fails (e.g., git binary unavailable), a warning is set. This two-tier
      check ensures clean behavior in both cases.

  - question: >
      How should the baseBranch parameter for getPrDiffSummary be determined in the
      server action?
    resolved: true
    options:
      - option: 'Hardcode "main" as the base branch'
        description: >
          Simple and predictable. The server action passes 'main' directly to
          getPrDiffSummary. Breaks for repos using "master" or custom default branches,
          but the graceful fallback handles this (diff call fails, PR metadata still shown).
          Note: merge.node.ts does NOT hardcode 'main' — it uses getDefaultBranch(cwd)
          at line 101 to detect dynamically.
        selected: true
      - option: 'Read the default branch from git configuration'
        description: >
          Resolve IGitService and call getDefaultBranch(worktreePath) to detect the actual
          default branch. More robust for repos using "master" or custom branch names.
          Adds complexity (another DI resolution + git call) and another potential failure
          point to what is a supplementary display feature.
        selected: false
      - option: 'Store the base branch on the Feature entity'
        description: >
          Add a baseBranch field to Feature and persist it during agent execution. Most
          robust but requires domain model changes (TypeSpec modification, database
          migration), violating NFR-8 (no domain model changes).
        selected: false
    selectionRationale: >
      Hardcoding "main" is a pragmatic choice for the server action. While the merge node
      uses getDefaultBranch(cwd) dynamically (line 101), adding dynamic detection to the
      server action would require resolving an additional service, making another git call,
      and handling its failure — all for a supplementary display feature. If the base branch
      is not 'main', getPrDiffSummary fails gracefully and the drawer shows PR metadata
      without diff stats. The approve action still works. This inconsistency between agent
      (dynamic) and server action (static) is acceptable for an M-sized feature. A future
      enhancement can add dynamic detection or persist baseBranch on the Feature entity.

  - question: >
      Should the merge review data type be defined in the server action file or in the
      component config file?
    resolved: true
    options:
      - option: 'Define MergeReviewData in merge-review-config.ts (component config)'
        description: >
          Define the data interface alongside the component props in the config file.
          The server action imports and returns this type. Co-locates the data contract
          with the consumer, making it easy to understand what the component expects at
          a glance. The server action file stays focused on data fetching logic.
        selected: true
      - option: 'Define MergeReviewData in the server action file'
        description: >
          Define and export the data interface from get-merge-review-data.ts. Components
          import it from the action file. This is what get-research-artifact.ts does —
          TechDecisionsReviewData is defined there (lines 7-12) and exported, though
          tech-decisions-review-config.ts also re-exports it from the domain types.
        selected: false
      - option: 'Define in a shared types file'
        description: >
          Create a separate shared types file that both the server action and component
          import from. Adds a file that doesn't match the established pattern and
          introduces indirection without benefit.
        selected: false
    selectionRationale: >
      The implemented approach defines MergeReviewData and all related interfaces
      (MergeReviewDiffSummary, MergeReviewPr, MergeReviewPhase, MergeReviewBranch,
      MergeReviewProps, MergeReviewDrawerProps) in merge-review-config.ts. The server
      action (get-merge-review-data.ts) imports MergeReviewData and MergeReviewPhase from
      the config file. This keeps the data contract co-located with the component that
      consumes it. The tech-decisions pattern is slightly different (TechDecisionsReviewData
      is defined in get-research-artifact.ts and re-exported), but the merge-review approach
      is cleaner because it avoids the circular dependency potential of importing component
      types from action files. The config file serves as the single source of truth for
      all merge-review related types.

content: |
  ## Technology Decisions

  ### 1. Server Action Architecture

  **Chosen:** Direct server action resolving IFeatureRepository, GetPlanArtifactUseCase, and
  IGitPrService via DI

  **Rejected:**
  - Dedicated use case class — unnecessary indirection for a composed read operation
  - LangGraph checkpoint read — couples UI to agent internals, Feature.pr is already persisted

  **Rationale:** Follows the established pattern in get-feature-artifact.ts (56 lines) and
  get-research-artifact.ts (43 lines). The implemented action (get-merge-review-data.ts, ~65 lines)
  validates featureId, resolves IFeatureRepository via `resolve<IFeatureRepository>('IFeatureRepository')`,
  reads Feature.pr, resolves GetPlanArtifactUseCase for plan phases (best-effort), then resolves
  IGitPrService via `resolve<IGitPrService>('IGitPrService')` to call getPrDiffSummary() with
  a nested try/catch for graceful degradation. The action returns a discriminated union:
  `MergeReviewData | { error: string }`, which the control center checks with `'error' in result`.

  ### 2. Component Structure

  **Chosen:** 5-file pattern at `components/common/merge-review/`

  **Rejected:**
  - Single file — violates codebase conventions
  - Features tier placement — breaks parallel with prd-questionnaire and tech-decisions-review

  **Rationale:** Exact mirror of the existing drawer component pattern. Files:
  - `merge-review-config.ts` — 7 interfaces: MergeReviewDiffSummary, MergeReviewPr,
    MergeReviewPhase, MergeReviewBranch, MergeReviewData, MergeReviewProps, MergeReviewDrawerProps
  - `merge-review.tsx` — Content component (196 lines) with PhaseList sub-component, PR metadata
    card, branch direction pill, diff summary grid, CI badge, warning state, DrawerActionBar
  - `merge-review-drawer.tsx` — Thin wrapper (~43 lines) passing shell props to ReviewDrawerShell
    with Loader2 spinner when data is null
  - `merge-review.stories.tsx` — Stories for all variants
  - `index.ts` — Barrel export of MergeReviewDrawer and all config types

  ### 3. Content Design

  **Chosen:** Read-only PR display with approve action and DrawerActionBar reject support

  **Rejected:**
  - Multi-turn chat refinement — merge node interrupt doesn't support iterative feedback
  - File-level diff details — requires service extension, GitHub link covers detailed review

  **Rationale:** Merge review is primarily a binary decision unlike PRD (option selection with
  stepper) or tech decisions (plan review with collapsible alternatives). The component renders:
  (1) emerald status dot header, (2) branch direction pill (source → target with GitBranch icons),
  (3) PR number as external link with ExternalLink icon, PR status badge, CI status via CiStatusBadge,
  commit hash truncated to 7 chars with GitCommitHorizontal icon, (4) diff summary 4-column grid
  (files, +additions green, -deletions red, commits), (5) implementation phases numbered list with
  Layers icon, (6) DrawerActionBar with "Approve Merge" button (GitMerge icon) plus optional reject.

  ### 4. Badge Visualization

  **Chosen:** Emerald (green) + GitMerge icon for review + action-required

  **Rejected:**
  - Purple/GitPullRequest — no semantic meaning for merging
  - Default amber — indistinguishable from PRD review

  **Rationale:** Three functions in feature-node.tsx handle badge customization per lifecycle:
  - `getBadgeIcon()` (line 24): returns `GitMerge` when lifecycle='review'
  - `getActionRequiredBadgeClasses()` (lines 38-39): returns `{ badgeClass: 'text-emerald-700',
    badgeBgClass: 'bg-emerald-50' }` when lifecycle='review'
  - `getBadgeText()` (line 58): returns `'Review Merge Request'` when lifecycle='review'
  This creates the visual progression: amber/FileText (requirements) → indigo/Wrench
  (implementation) → emerald/GitMerge (merge review).

  ### 5. Error Handling Strategy

  **Chosen:** Graceful degradation with nested try/catch in server action

  **Rejected:**
  - Block drawer on error — frustrates users, approval doesn't need diff data
  - Cache diff on Feature — requires domain model changes (NFR-8 violation)

  **Rationale:** The implemented server action structure:
  ```
  try {
    feature = featureRepo.findById(featureId)    // fatal if not found
    pr = feature.pr ? { ...extract fields } : undefined
    branch = feature.branch ? { source, target: 'main' } : undefined

    try {
      phases = planUseCase.execute(featureId).phases  // best-effort
    } catch { /* plan unavailable — not critical */ }

    if (!feature.worktreePath) {
      return { pr, branch, phases, warning: pr ? undefined : '...' }
    }

    try {
      diffSummary = gitPrService.getPrDiffSummary(worktreePath, 'main')
      return { pr, branch, phases, diffSummary }
    } catch {
      return { pr, branch, phases, warning: 'Diff statistics unavailable' }
    }
  } catch {
    return { error: message }
  }
  ```

  ### 6. Control Center Integration

  **Chosen:** Same inline pattern as PRD/Tech drawers

  **Rejected:**
  - Custom hook extraction — breaks established pattern
  - React Suspense — requires restructuring client component model

  **Rationale:** Adds to control-center-inner.tsx (464 lines):
  - State: `mergeReviewData` (line 98), `isLoadingMergeReview` (line 99)
  - Boolean: `showMergeReviewDrawer` = lifecycle 'review' && state 'action-required' (lines 107-108)
  - useEffect: fetch data via getMergeReviewData(mergeFeatureId) with cancellation (lines 293-321)
  - Callback: `handleMergeApprove` = handleSimpleApprove('Merge') (line 219)
  - Callback: `handleMergeReject` = handleReject(feedback, 'Merge') (lines 190-193)
  - Render: `MergeReviewDrawer` conditionally (lines 434-451)
  - Suppress: extend FeatureDrawer null condition (line 389)

  ### 7. CI Status Display

  **Chosen:** Reuse existing CiStatusBadge component (30 lines)

  **Rejected:**
  - Plain text — lacks visual immediacy
  - New animated component — duplicates existing functionality

  **Rationale:** CiStatusBadge is a shared component already handling:
  - Success: `bg-green-50 text-green-700` + CheckCircle2 + "Passing"
  - Pending: `bg-yellow-50 text-yellow-700` + Loader2 (animate-spin) + "Pending"
  - Failure: `bg-red-50 text-red-700` + XCircle + "Failing"
  Includes text labels for accessibility (NFR-5). Renders conditionally when pr.ciStatus exists.

  ### 8. Base Branch Handling

  **Chosen:** Hardcode 'main' in server action

  **Rejected:**
  - Dynamic detection via getDefaultBranch — adds latency and failure point
  - Persist on Feature entity — requires domain model changes

  **Rationale:** merge.node.ts dynamically detects via getDefaultBranch(cwd) (line 101), but the
  server action hardcodes 'main' for simplicity. If wrong, diff call fails gracefully and PR
  metadata is shown with warning. Known inconsistency documented for future improvement.

  ## Library Analysis

  | Library | Purpose | Decision | Reasoning |
  | ------- | ------- | -------- | --------- |
  | lucide-react (GitMerge) | Merge badge icon + approve button icon | Use (already installed) | Available in existing lucide-react dependency, directly communicates merge action |
  | lucide-react (GitBranch, ArrowRight) | Branch direction pill layout | Use (already installed) | Standard git-related icons for source → target visualization |
  | lucide-react (FileDiff, GitCommitHorizontal) | Diff summary and commit display | Use (already installed) | Semantically appropriate icons for code changes context |
  | lucide-react (Layers) | Implementation phases header | Use (already installed) | Communicates "layers/phases" concept clearly |
  | lucide-react (AlertTriangle) | Diff unavailable warning | Use (already installed) | Standard warning indicator, consistent with other warning patterns |
  | lucide-react (ExternalLink) | PR link opens in new tab | Use (already installed) | Communicates external navigation behavior |
  | lucide-react (CheckCircle2, XCircle, Loader2) | CI status icons (via CiStatusBadge) | Use (already installed) | Used by existing CiStatusBadge component, no changes needed |
  | sonner (toast) | Success/error notifications | Use (already installed) | Used by all approval/reject callbacks in control-center-inner.tsx |
  | shadcn/ui Badge | PR status and branch name badges | Use (already installed) | Consistent with existing badge usage throughout the UI |
  | CiStatusBadge | CI status display | Use (existing component) | Shared component with proper accessibility (icon + text labels) |
  | ReviewDrawerShell | Drawer chrome (header, actions, delete) | Use (existing component) | Shared by all review drawers, provides header, actions menu, delete confirmation |
  | DrawerActionBar | Approve/reject action bar | Use (existing component) | Shared by all review drawers, provides approve button, revision input, reject dialog |
  | react-markdown | Markdown rendering in content | Reject | Not needed — merge review content is structured data (numbers, statuses, links), not markdown prose |
  | @tanstack/react-query | Data fetching with caching | Reject | Codebase uses useEffect + server actions pattern, not react-query. Adding would be inconsistent |
  | react-diff-viewer | File-level diff display | Reject | Out of scope — aggregate stats only. GitHub link covers detailed code review |

  ## Security Considerations

  **Input Validation:** The server action validates featureId is a non-empty string before
  resolving any dependencies: `if (!featureId.trim()) return { error: 'Feature id is required' }`.
  This matches the pattern in approve-feature.ts and other server actions.

  **External Links:** PR URL rendered with `target="_blank" rel="noopener noreferrer"` (merge-review.tsx
  lines 98-99) to prevent reverse tabnapping per NFR-5.

  **No New Attack Surface:** The server action only reads existing persisted data (Feature.pr from
  SQLite, plan.yaml from filesystem) and calls an existing service method (getPrDiffSummary which
  runs git commands). No user input is passed to git commands — the worktreePath and baseBranch
  are derived from server-side data. The featureId parameter is used only as a lookup key via
  IFeatureRepository.findById(), not interpolated into shell commands.

  **DI Token Safety:** Using string tokens ('IFeatureRepository', 'IGitPrService',
  'GetPlanArtifactUseCase') for DI resolution follows the established pattern. These tokens resolve
  to registered implementations controlled by the infrastructure layer bootstrap.

  **Error Message Safety:** The server action catches errors and returns safe error messages.
  For Error instances, it returns error.message (which is controlled server-side). For non-Error
  throws, it returns a generic 'Failed to load merge review data' string, avoiding information
  leakage.

  ## Performance Implications

  **Server Action Latency:** Three data sources with different performance profiles:
  - Feature.findById() — SQLite read, ~1ms
  - GetPlanArtifactUseCase.execute() — filesystem read (plan.yaml), ~5-15ms
  - getPrDiffSummary() — runs `git diff --stat` and `git log --oneline`, ~50-200ms depending
    on repo size and diff magnitude
  Total expected: ~60-220ms, well within acceptable limits for an on-demand drawer load.

  **Non-Blocking Optional Data:** Plan phases and diff summary are independently wrapped in
  try/catch. A slow or failed diff call does not block plan phase loading (they're sequential
  but independently caught). The action returns as soon as it has whatever data it could gather.

  **No Polling:** The merge drawer does not poll for CI status updates. CI status is a snapshot
  from when Feature.pr was persisted by the merge node. Users can refresh by closing and
  reopening the drawer (re-triggers the useEffect with a fresh server action call). This is
  acceptable because CI status changes infrequently during the merge review phase.

  **Bundle Size:** Zero new npm dependencies. All Lucide icons are tree-shaken via named imports.
  The new component adds ~573 lines across 6 new files (config: ~85, content: ~196, drawer: ~43,
  stories: ~241, barrel: ~8) — negligible impact on bundle size.

  **useEffect Cancellation:** The control center's merge data useEffect (lines 293-321) uses
  the standard cancellation flag pattern to prevent stale data from being set if the user
  navigates away before the server action completes. This prevents memory leaks and race conditions.

  ## Architecture Notes

  **Data Flow:**
  ```
  merge.node.ts (agent)
    → Sets Feature.pr before interrupt (lines 226-238)
    → Sets agentRun.status = waitingApproval
    → Feature enters lifecycle=Review, state=action-required

  page.tsx (server component)
    → nodeToLifecyclePhase map: merge → 'review' (line 35)
    → Derives lifecycle='review' when agent is at merge node
    → Passes lifecycle via FeatureNodeData to canvas

  control-center-inner.tsx (client component)
    → showMergeReviewDrawer = lifecycle==='review' && state==='action-required' (lines 107-108)
    → useEffect calls getMergeReviewData(featureId) server action (lines 293-321)
    → Server action:
      1. resolves Feature via IFeatureRepository.findById
      2. extracts Feature.pr fields (url, number, status, commitHash, ciStatus)
      3. constructs branch = { source: feature.branch, target: 'main' }
      4. loads plan phases via GetPlanArtifactUseCase.execute (best-effort)
      5. calls IGitPrService.getPrDiffSummary(worktreePath, 'main') (graceful fallback)
    → Returns MergeReviewData { pr, branch, phases, diffSummary, warning }
    → MergeReviewDrawer renders ReviewDrawerShell + MergeReview content
    → Approve button calls approveFeature(featureId) → ApproveAgentRunUseCase → resumes agent
  ```

  **Type Architecture:**
  ```
  Domain types (generated, read-only):
    Feature.pr: PullRequest { url, number, status: PrStatus, commitHash?, ciStatus?: CiStatus }
    PrStatus enum: Open | Merged | Closed
    CiStatus enum: Pending | Success | Failure
    TechnicalPlanArtifact.phases: PlanPhase[] { id, name, description?, parallel }

  Service interfaces (read-only, no modifications):
    IFeatureRepository.findById(id) → Feature | null
    IGitPrService.getPrDiffSummary(cwd, baseBranch) → DiffSummary { filesChanged, additions, deletions, commitCount }
    GetPlanArtifactUseCase.execute(featureId) → TechnicalPlanArtifact

  UI types (merge-review-config.ts):
    MergeReviewPr { url, number, status: PrStatus, commitHash?, ciStatus?: CiStatus }
    MergeReviewDiffSummary { filesChanged, additions, deletions, commitCount }
    MergeReviewPhase { id, name, description? }
    MergeReviewBranch { source, target }
    MergeReviewData { pr?, diffSummary?, phases?, branch?, warning? }
    MergeReviewProps { data, onApprove, onReject?, isProcessing?, isRejecting? }
    MergeReviewDrawerProps extends Omit<MergeReviewProps, 'data'> + shell props
  ```

  **Existing Infrastructure Reused (No Modifications):**
  - `ReviewDrawerShell` (review-drawer-shell.tsx, 143 lines) — right-side drawer wrapper with header,
    action menu (OpenActionMenu + useFeatureActions), delete button with AlertDialog confirmation
  - `CiStatusBadge` (ci-status-badge.tsx, 30 lines) — color-coded CI status badge with icon + text
  - `DrawerActionBar` (drawer-action-bar.tsx, 64 lines) — approve/reject footer with revision input
    and RejectFeedbackDialog
  - `useFeatureActions` hook — IDE/shell/folder actions, used by ReviewDrawerShell
  - `approveFeature()` server action (38 lines) — works for all approval gates including merge
  - `rejectFeature()` server action (52 lines) — shared reject flow for all drawer types
  - `resolve()` from lib/server-container.ts (37 lines) — DI resolution for server actions
  - `IFeatureRepository.findById()` — fetch Feature entity with populated pr field
  - `IGitPrService.getPrDiffSummary()` — returns DiffSummary interface
  - `GetPlanArtifactUseCase.execute()` — returns TechnicalPlanArtifact with phases
  - `Feature.pr` (PullRequest type) — PR metadata persisted by merge node
  - `PrStatus`, `CiStatus` enums — domain types for status rendering

  **Implementation Status:**
  Analysis of the current branch (feat/feature-env-deploy) confirms this feature is already
  fully implemented. All 6 new files exist with complete implementations:
  1. `components/common/merge-review/merge-review-config.ts` — 7 interfaces defined
  2. `components/common/merge-review/merge-review.tsx` — 196 lines, complete content component
  3. `components/common/merge-review/merge-review-drawer.tsx` — 43 lines, shell wrapper
  4. `components/common/merge-review/merge-review.stories.tsx` — story variants
  5. `components/common/merge-review/index.ts` — barrel exports
  6. `app/actions/get-merge-review-data.ts` — 65 lines, server action with all three data sources

  Modified files also have all changes:
  - feature-node.tsx: getBadgeIcon, getBadgeText, getActionRequiredBadgeClasses all handle 'review'
  - control-center-inner.tsx: mergeReviewData state, showMergeReviewDrawer, useEffect, handlers,
    conditional MergeReviewDrawer rendering, FeatureDrawer suppression
  - page.tsx: `merge: 'review'` in nodeToLifecyclePhase (line 35)

  Test files exist:
  - tests/unit/presentation/web/actions/merge-review/get-merge-review-data.test.ts (237 lines)
  - tests/unit/presentation/web/components/common/merge-review/merge-review-drawer.test.tsx (46 lines)

  **Files to Create (6 new):**
  1. `src/presentation/web/components/common/merge-review/merge-review-config.ts` — ~85 lines
  2. `src/presentation/web/components/common/merge-review/merge-review.tsx` — ~196 lines
  3. `src/presentation/web/components/common/merge-review/merge-review-drawer.tsx` — ~43 lines
  4. `src/presentation/web/components/common/merge-review/merge-review.stories.tsx` — ~241 lines
  5. `src/presentation/web/components/common/merge-review/index.ts` — ~8 lines
  6. `src/presentation/web/app/actions/get-merge-review-data.ts` — ~65 lines

  **Files to Modify (5 existing):**
  1. `src/presentation/web/components/common/feature-node/feature-node.tsx` — add review cases to
     getBadgeIcon (1 line), getActionRequiredBadgeClasses (2 lines), getBadgeText (1 line)
  2. `src/presentation/web/components/features/control-center/control-center-inner.tsx` — add
     mergeReviewData state, showMergeReviewDrawer boolean, useEffect with cancellation,
     handleMergeApprove and handleMergeReject callbacks, conditional MergeReviewDrawer rendering,
     extend FeatureDrawer suppression condition (~60 lines)
  3. `src/presentation/web/app/page.tsx` — verify `merge: 'review'` in nodeToLifecyclePhase (already present)
  4. `src/presentation/web/components/common/feature-node/feature-node.stories.tsx` — add review +
     action-required story variant in AllStates
  5. `src/presentation/web/components/features/control-center/control-center.stories.tsx` — add merge
     review node variant in WithFeatures

  **Test Files (2 new):**
  1. `tests/unit/presentation/web/actions/merge-review/get-merge-review-data.test.ts` — server action
     tests covering: validation, feature not found, success with full data, diff fallback with warning,
     worktreePath undefined, missing optional PR fields, plan phases available/unavailable, branch
     construction, repository errors, generic error fallback
  2. `tests/unit/presentation/web/components/common/merge-review/merge-review-drawer.test.tsx` — drawer
     integration test covering: shell rendering, content rendering, PR link, approve button
