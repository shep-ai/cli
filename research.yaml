name: merge-review-drawer
summary: >
  The merge review drawer follows the proven 5-file component pattern (config, content, drawer,
  stories, barrel) established by prd-questionnaire and tech-decisions-review. The server action
  (get-merge-review-data.ts) reads Feature.pr (already persisted before the merge interrupt in
  merge.node.ts lines 226-237) and calls IGitPrService.getPrDiffSummary() with graceful fallback.
  The DrawerActionBar provides reject flow at zero cost via the shared component. No new
  dependencies, no domain model changes, and no backend modifications are needed — all data,
  icons, and UI primitives are already available in the codebase.

relatedFeatures: []

technologies:
  - React 19 (Next.js 16+ App Router)
  - shadcn/ui (Radix + Tailwind CSS v4)
  - React Flow (@xyflow/react)
  - Storybook 8
  - Vaul (drawer primitive via ReviewDrawerShell)
  - Lucide React (GitMerge, GitPullRequest, CheckCircle2, XCircle, Loader2, ExternalLink, FileDiff icons)
  - sonner (toast notifications)
  - tsyringe (DI container for server actions via resolve())
  - vitest + @testing-library/react (unit and component tests)

relatedLinks: []

decisions:
  - title: 'Server Action Architecture for Merge Review Data'
    chosen: >
      Direct server action (get-merge-review-data.ts) that resolves IFeatureRepository,
      IGitPrService, and GetPlanArtifactUseCase via the DI container, reads Feature.pr
      for PR metadata, loads plan phases best-effort, and calls getPrDiffSummary() with
      graceful fallback. Returns a discriminated union: MergeReviewData | { error: string }.
    rejected:
      - >
        Create a dedicated use case class (e.g., GetMergeReviewDataUseCase): Rejected because
        the existing server action pattern (get-feature-artifact.ts, get-research-artifact.ts)
        resolves repositories and services directly via resolve() without a dedicated use case.
        The merge review data retrieval is a simple read operation that doesn't warrant its own
        use case class — it would add unnecessary indirection for a server action that reads
        one entity field and calls one service method. Confirmed: get-feature-artifact.ts and
        get-research-artifact.ts both resolve use cases directly via resolve<T>().
      - >
        Return data from the LangGraph checkpoint interrupt payload: Rejected because it
        couples the UI layer to LangGraph internals, checkpoint format may change between
        versions, and Feature.pr is already persisted before the interrupt. Confirmed in
        merge.node.ts lines 226-237: the pr field is populated with url, number, status,
        commitHash, ciStatus using conditional spread syntax before the interrupt() call.
    rationale: >
      The server action pattern is established in the codebase. Each action uses 'use server',
      validates input with trim(), resolves dependencies via resolve<T>('Token') from
      lib/server-container.ts, and returns a typed result with optional error. The merge
      review action follows this exact pattern: (1) validate featureId is non-empty,
      (2) resolve IFeatureRepository to read Feature.pr, (3) resolve GetPlanArtifactUseCase
      for plan phases in a nested try/catch (best-effort), (4) resolve IGitPrService to get
      diff summary in a nested try/catch (graceful fallback). The server-container.ts resolve()
      helper uses tsyringe with globalThis.__shepContainer, throwing an explicit error if
      the container is not initialized.

  - title: 'Component Directory Structure'
    chosen: >
      5-file pattern at components/common/merge-review/ matching prd-questionnaire and
      tech-decisions-review: merge-review-config.ts, merge-review.tsx,
      merge-review-drawer.tsx, merge-review.stories.tsx, index.ts
    rejected:
      - >
        Single-file component: Rejected because it violates the established pattern and
        mixes type definitions, content rendering, shell integration, and stories into one
        file. The codebase convention separates config (types), content, drawer wrapper,
        stories, and barrel export into dedicated files for single responsibility.
        Confirmed: both prd-questionnaire/ and tech-decisions-review/ follow this exact
        5-file pattern with config, content, drawer, stories, barrel.
      - >
        Place in features/ tier (Tier 3) instead of common/ (Tier 1): Rejected because
        prd-questionnaire and tech-decisions-review are both in components/common/ as
        Tier 1 shared domain components. The merge review drawer is the same kind of
        component — a domain-specific review drawer used by the control center. Placing
        it in features/ would break the parallel structure.
    rationale: >
      The 5-file pattern is used by both existing review drawers: prd-questionnaire/
      (prd-questionnaire-config.ts, prd-questionnaire.tsx, prd-questionnaire-drawer.tsx,
      prd-questionnaire.stories.tsx, index.ts) and tech-decisions-review/ (tech-decisions-
      review-config.ts, tech-decisions-review.tsx, tech-decisions-drawer.tsx,
      tech-decisions-review.stories.tsx, index.ts). Following this pattern ensures
      consistency, makes the component discoverable, and allows the content component to
      be used independently from the drawer shell (useful for Storybook stories). The
      barrel index.ts exports the content component, drawer, and all type interfaces.

  - title: 'Drawer Content Design — Read-Only with DrawerActionBar'
    chosen: >
      Read-only display showing PR metadata, diff summary, CI status, branch direction,
      and implementation phases, with DrawerActionBar providing approve and reject flow.
      No chat input beyond the DrawerRevisionInput provided by DrawerActionBar.
    rejected:
      - >
        Include separate chat input for feedback (matching PRD drawer): Rejected because
        merge review is fundamentally a binary approval decision — there is nothing to
        "refine" like requirements or tech decisions. However, the DrawerActionBar's built-in
        reject flow (RejectFeedbackDialog + DrawerRevisionInput) is included at zero cost
        since the shared component provides it automatically.
      - >
        Full code review interface with file-level diffs: Rejected because this would require
        extending IGitPrService with per-file diff data (the DiffSummary interface only has
        filesChanged, additions, deletions, commitCount), dramatically increase component
        complexity, and duplicate GitHub's code review UI. The spec explicitly chose aggregate
        statistics only. Users who want detailed review can click the PR link.
    rationale: >
      The merge approval gate is fundamentally different from PRD (select options from
      questions) and tech decisions (review and refine plan). Merge review is a go/no-go
      decision: the code has been implemented, the PR has been created, and the user just
      needs to approve the merge. The DrawerActionBar (drawer-action-bar.tsx) provides
      approve button, optional inline revision input (DrawerRevisionInput), and reject
      button with feedback dialog (RejectFeedbackDialog) — all at zero additional cost.
      The PR URL provides an escape hatch to GitHub for detailed code review. Props passed:
      approveLabel="Approve Merge", approveIcon={GitMerge or Loader2 spinner},
      revisionPlaceholder="Ask AI to revise before merging...",
      rejectDialogTitle="Reject Merge".

  - title: 'Feature Node Badge Color Scheme for Review Phase'
    chosen: >
      Emerald (green) color scheme with GitMerge icon: text-emerald-700 badge text,
      bg-emerald-50 badge background, distinct from amber (requirements) and indigo
      (implementation) badge schemes.
    rejected:
      - >
        Purple/violet with GitPullRequest icon: Rejected because purple doesn't carry
        semantic meaning for merging, and GitPullRequest represents the PR object rather
        than the merge action. This would be less intuitive than green.
      - >
        Reuse the default amber with a different icon only: Rejected because it would make
        the merge review state indistinguishable from PRD review (both amber). The spec
        requires three visually distinct review types: amber (requirements), indigo
        (implementation), green (merge).
    rationale: >
      The emerald color creates a natural progression: amber (requirements review) →
      indigo (tech planning review) → green (merge review). Green semantically means
      "ready to proceed / ready to merge", matching GitHub's green merge button convention.
      The GitMerge icon from Lucide React directly communicates the action. Three function
      additions to feature-node.tsx: (1) getBadgeIcon() returns GitMerge for review lifecycle,
      (2) getActionRequiredBadgeClasses() returns { badgeClass: 'text-emerald-700',
      badgeBgClass: 'bg-emerald-50' } for review, (3) getBadgeText() returns
      'Review Merge Request' for review lifecycle with action-required state. Note: emerald
      is also used for the "done" state in feature-node-state-config.ts, but there's no
      collision because done and action-required are mutually exclusive states.

  - title: 'Diff Summary Retrieval and Error Handling'
    chosen: >
      Graceful degradation: server action checks Feature.worktreePath existence before
      attempting diff, wraps getPrDiffSummary() in a nested try/catch, returns PR metadata
      with diffSummary omitted and warning field set on failure, drawer renders warning
      text instead of diff section.
    rejected:
      - >
        Block the drawer with a full error state: Rejected because the diff summary is
        supplementary display information — blocking the approve action because of a
        display issue would frustrate users. Feature.pr is always available since it's
        persisted before the interrupt.
      - >
        Cache diff summary in Feature entity during merge node: Rejected because it would
        require domain model changes (adding a diffSummary field to Feature or PullRequest),
        TypeSpec modifications, and database migration — all of which violate NFR-2
        (no domain model changes) and NFR-3 (no backend changes).
    rationale: >
      The server action (get-merge-review-data.ts) uses a three-tier error handling strategy:
      (1) If Feature.worktreePath is undefined, skip diff entirely and return PR + branch +
      phases with warning only if no PR exists either ("No PR or diff data available").
      (2) If worktreePath exists but getPrDiffSummary() fails, return PR + branch + phases
      with warning "Diff statistics unavailable". (3) Outer try/catch catches unexpected
      errors (e.g., DI container not initialized, Feature repo throws). The DiffSummary
      interface (from git-pr-service.interface.ts) has exactly: filesChanged, additions,
      deletions, commitCount — matching the aggregate stats display. The merge node uses
      worktreePath (not repositoryPath) for getPrDiffSummary, and the server action matches
      this by checking Feature.worktreePath. Hardcoded baseBranch='main' matches
      merge.node.ts behavior.

  - title: 'Control Center Integration Pattern'
    chosen: >
      Follow the exact same inline pattern as PRD and Tech Decision drawers: boolean flag
      (showMergeReviewDrawer), state for data (mergeReviewData), useEffect with
      cancellation for data fetching, approval/rejection handlers, conditional rendering,
      and FeatureDrawer suppression.
    rejected:
      - >
        Use a custom hook to encapsulate all merge drawer logic: Rejected for the same
        reason PRD and Tech drawers don't use one — the control center already manages
        all drawer state inline. Extracting to a hook would break the established pattern
        and add indirection that doesn't exist for the other drawers. The control-center-
        inner.tsx manages all three drawer types with the same inline pattern.
      - >
        Use React Suspense with a server component for data loading: Rejected because
        the control center is a client component ('use client') and the drawer data is
        loaded on-demand when a node is selected. Suspense would require restructuring
        the control center's client-side interaction model, which is out of scope.
    rationale: >
      The control-center-inner.tsx follows a clear pattern for each drawer: (1) state
      declarations (data, loading), (2) boolean visibility derived from selectedNode
      lifecycle + state, (3) useEffect with cancellation pattern for data fetching,
      (4) approval callback via approveFeature(), (5) rejection callback via
      rejectFeature() with caution sound effect, (6) conditional rendering. The
      FeatureDrawer suppression extends naturally: selectedNode is set to null when
      showPrdDrawer || showTechDecisionsDrawer || showMergeReviewDrawer is true.
      The approval handler calls approveFeature(featureId), shows success toast
      ("Merge approved — agent resuming"), and clears selection. The rejection handler
      calls rejectFeature(featureId, feedback), plays caution sound, shows toast with
      iteration count, and clears selection.

  - title: 'CI Status Visual Representation'
    chosen: >
      Reuse existing CiStatusBadge shared component (ci-status-badge.tsx) which renders
      color-coded shadcn/ui Badge with Lucide icons: green/CheckCircle2 for Success,
      yellow/Loader2 (animate-spin) for Pending, red/XCircle for Failure, with text labels.
    rejected:
      - >
        Plain text status line without color: Rejected because it lacks visual immediacy.
        Color-coded indicators follow universal CI/CD conventions (green=pass, red=fail,
        yellow=pending) and match GitHub's own status indicators. Users can scan CI status
        at a glance with color.
      - >
        Build a new CI status display component: Rejected because CiStatusBadge already
        exists at components/common/ci-status-badge/ with stories and handles all three
        CiStatus enum values. It accepts a single { status: CiStatus } prop and renders
        the appropriate badge variant. No reason to duplicate this.
    rationale: >
      The CiStatusBadge component (ci-status-badge.tsx) is a stateless component that
      switches on CiStatus enum values imported from @shepai/core/domain/generated/output.
      It renders: Success → green badge + CheckCircle2 + "Passing", Pending → yellow badge
      + Loader2 (animate-spin) + "Pending", Failure → red badge + XCircle + "Failing".
      Uses shadcn/ui Badge component with className overrides for color variants. The
      merge-review.tsx component conditionally renders CiStatusBadge only when
      data.pr?.ciStatus is defined (FR-17: omit CI section when undefined).

  - title: 'Reject Flow Architecture'
    chosen: >
      Include reject flow via shared DrawerActionBar component, which provides inline
      DrawerRevisionInput and RejectFeedbackDialog at zero additional implementation cost.
      The backend rejectFeature() server action already supports all approval gates.
    rejected:
      - >
        Approve-only button without reject: Rejected because the DrawerActionBar already
        provides reject functionality at no additional cost. Omitting it would mean the
        merge review drawer is the only review drawer without reject, which is inconsistent.
        Users benefit from being able to request revisions before merging.
      - >
        Custom reject flow specific to merge: Rejected because the shared DrawerActionBar
        and RejectFeedbackDialog handle all the UI, and rejectFeature() handles all backend
        logic. There's no merge-specific rejection behavior that would warrant a custom
        implementation.
    rationale: >
      The DrawerActionBar (drawer-action-bar.tsx) accepts onReject callback, approve
      callbacks, and state flags. It renders: (1) optional children slot, (2) optional
      DrawerRevisionInput (inline text + send button, placeholder customizable),
      (3) reject button → opens RejectFeedbackDialog (AlertDialog with textarea,
      requires non-empty feedback), (4) full-width approve button with custom icon.
      Both rejection paths (inline and dialog) call the same onReject(feedback) callback.
      The control center passes rejectFeature(featureId, feedback) as the handler.
      DrawerRevisionInput trims input and prevents empty submissions.

openQuestions:
  - question: >
      Should the server action resolve Feature.worktreePath for the getPrDiffSummary call,
      or should it use Feature.repositoryPath instead?
    resolved: true
    options:
      - option: 'Use Feature.worktreePath'
        description: >
          Feature.worktreePath is the actual git worktree path where the feature branch
          work happens. This is what merge.node.ts uses when calling getPrDiffSummary.
          During the Review phase, the worktree should still exist. However, worktreePath
          is optional on the Feature type (line 811 of output.ts) and may be undefined.
        selected: true
      - option: 'Use Feature.repositoryPath'
        description: >
          Feature.repositoryPath is the base repository path, always present. However, diff
          comparisons happen in the worktree (a separate git checkout), not the base repo.
          Using repositoryPath would produce incorrect diff results if the feature uses a
          worktree, which is the standard flow.
        selected: false
      - option: 'Use Feature.repositoryPath with branch checkout'
        description: >
          Use repositoryPath but first check out the feature branch. This is dangerous and
          modifies working state in the base repository. It could disrupt other features or
          ongoing work. Not a viable approach for a read-only display operation.
        selected: false
    selectionRationale: >
      Feature.worktreePath is the correct path because getPrDiffSummary runs git diff
      baseBranch...HEAD, which must execute in the worktree where HEAD points to the
      feature branch. The merge node uses state.worktreePath for exactly this reason.
      The worktree is guaranteed to exist during the Review lifecycle phase because
      it's created during feature initialization and only cleaned up after the feature
      reaches Maintain. The server action checks if worktreePath is defined before
      attempting the diff call, falling back to omitting diffSummary when undefined.
      Confirmed: get-merge-review-data.ts line 49 checks `if (!feature.worktreePath)`
      and line 55 passes `feature.worktreePath` to getPrDiffSummary.

  - question: >
      How should the baseBranch parameter for getPrDiffSummary be determined in the
      server action?
    resolved: true
    options:
      - option: 'Hardcode "main" as the base branch'
        description: >
          merge.node.ts hardcodes baseBranch = "main". Matching this ensures consistency
          between what the agent computed and what the server action displays. Simple and
          predictable. Breaks for repos using "master" or custom default branches but fails
          gracefully via try/catch.
        selected: true
      - option: 'Read the default branch from git configuration'
        description: >
          Use git rev-parse or git remote to detect the actual default branch. More robust
          for repos using "master" or custom branch names. However, this adds complexity and
          another potential failure point, and the merge node itself hardcodes "main".
        selected: false
      - option: 'Store the base branch on the Feature entity'
        description: >
          Add a baseBranch field to Feature and persist it during agent execution. Most
          robust but requires domain model changes (TypeSpec, migration), violating NFR-2.
        selected: false
    selectionRationale: >
      Hardcoding "main" matches the merge node implementation exactly. Since the diff
      summary is computed between the same branches the agent used, the results will be
      consistent. If the repo uses "master" or another default branch, the
      getPrDiffSummary call will fail gracefully (the nested try/catch returns PR metadata
      with warning "Diff statistics unavailable"). Confirmed: get-merge-review-data.ts
      line 55 passes hardcoded 'main' to getPrDiffSummary.

  - question: >
      Should the merge review data type be defined in the server action file or in the
      component config file?
    resolved: true
    options:
      - option: 'Define MergeReviewData in merge-review-config.ts (component config)'
        description: >
          Define the data interface alongside the component props in the config file.
          The server action imports and returns this type. Co-locates the data contract
          with the component that consumes it, making the component self-documenting.
        selected: true
      - option: 'Define MergeReviewData in the server action file'
        description: >
          Define and export the data interface from get-merge-review-data.ts. Components
          import it from the action file. This is what get-research-artifact.ts does —
          TechDecisionsReviewData is defined there and the config re-exports it.
        selected: false
      - option: 'Define in a shared types file'
        description: >
          Create a separate shared types file that both the server action and component
          import from. Adds a file that doesn't match the established pattern and creates
          unnecessary indirection.
        selected: false
    selectionRationale: >
      MergeReviewData is defined in merge-review-config.ts alongside all other component
      interfaces (MergeReviewProps, MergeReviewDrawerProps, MergeReviewPr,
      MergeReviewDiffSummary, MergeReviewPhase, MergeReviewBranch). The server action
      imports MergeReviewData and MergeReviewPhase from the config file. This keeps the
      data shape definition co-located with the component that consumes it, making it
      easier to understand the component's data contract at a glance. The server action
      file stays focused on the data fetching logic. Confirmed: merge-review-config.ts
      defines all 7 interfaces, and get-merge-review-data.ts imports MergeReviewData
      and MergeReviewPhase from it.

content: |
  ## Technology Decisions

  ### 1. Server Action Architecture

  **Chosen:** Direct server action resolving IFeatureRepository, IGitPrService, and
  GetPlanArtifactUseCase via DI

  **Rejected:**
  - Dedicated use case class — unnecessary indirection for a simple read + diff operation
  - LangGraph checkpoint read — couples UI to agent internals, Feature.pr is already persisted

  **Rationale:** Follows the established pattern in get-feature-artifact.ts and
  get-research-artifact.ts. The action (get-merge-review-data.ts, 64 lines) validates
  featureId, resolves IFeatureRepository via `resolve<IFeatureRepository>('IFeatureRepository')`,
  reads Feature.pr, then resolves GetPlanArtifactUseCase for plan phases (best-effort), and
  finally resolves IGitPrService for getPrDiffSummary() with a nested try/catch for graceful
  degradation. Returns `MergeReviewData | { error: string }` discriminated union.

  ### 2. Component Structure

  **Chosen:** 5-file pattern at `components/common/merge-review/`

  **Rejected:**
  - Single file — violates codebase conventions (all review drawers use 5 files)
  - Features tier placement — breaks parallel with prd-questionnaire and tech-decisions-review

  **Rationale:** Exact mirror of the existing drawer component pattern. Files:
  - `merge-review-config.ts` — 7 interfaces: MergeReviewDiffSummary, MergeReviewPr,
    MergeReviewPhase, MergeReviewBranch, MergeReviewData, MergeReviewProps, MergeReviewDrawerProps.
    Imports PrStatus and CiStatus enums from domain/generated/output.
  - `merge-review.tsx` — Content component with PR metadata card, diff stats grid, CI badge,
    branch direction, implementation phases list, and DrawerActionBar footer.
  - `merge-review-drawer.tsx` — Thin wrapper composing ReviewDrawerShell with MergeReview
    content, showing Loader2 spinner while data is null.
  - `merge-review.stories.tsx` — 11 story variants covering all data states.
  - `index.ts` — Barrel export of MergeReview, MergeReviewDrawer, and type interfaces.

  ### 3. Content Design

  **Chosen:** Read-only PR display with DrawerActionBar (approve + reject flow)

  **Rejected:**
  - Separate chat input for refinement — DrawerActionBar already provides inline revision input
  - File-level diff details — requires IGitPrService extension, GitHub link covers detailed review

  **Rationale:** Merge review is a binary decision unlike PRD (option selection) or tech decisions
  (plan refinement). The component renders: PR number as external link (target="_blank",
  rel="noopener noreferrer"), PR status text, CI status via CiStatusBadge, truncated commit
  hash (first 7 characters), aggregate diff stats in a 4-column grid (files changed, +additions
  in green, -deletions in red, commit count), branch direction (source → target), numbered
  implementation phases, and DrawerActionBar with approve/reject.

  ### 4. Badge Visualization

  **Chosen:** Emerald (green) + GitMerge icon for review + action-required

  **Rejected:**
  - Purple/GitPullRequest — no semantic meaning for merging
  - Default amber — indistinguishable from PRD review (both would be amber)

  **Rationale:** Three additions to feature-node.tsx:
  - `getBadgeIcon()`: returns GitMerge for `data.lifecycle === 'review'` when action-required
  - `getActionRequiredBadgeClasses()`: returns `{ badgeClass: 'text-emerald-700', badgeBgClass: 'bg-emerald-50' }` for review
  - `getBadgeText()`: returns `'Review Merge Request'` for review lifecycle
  Forms clear visual progression: amber (requirements) → indigo (implementation) → emerald (merge).

  ### 5. Error Handling Strategy

  **Chosen:** Graceful degradation with three-tier nested try/catch in server action

  **Rejected:**
  - Block drawer on error — frustrates users, approval doesn't need diff data
  - Cache diff on Feature — requires domain model changes (NFR-2 violation)

  **Rationale:** The server action structure:
  ```
  validate featureId → resolve feature
  extract pr metadata from feature.pr (always available)
  construct branch info from feature.branch + 'main'
  try { load plan phases via GetPlanArtifactUseCase } catch { phases = undefined }
  if (!feature.worktreePath) → return { pr, branch, phases, warning? }
  try { diffSummary = getPrDiffSummary(worktreePath, 'main') } catch { warning }
  return { pr, branch, phases, diffSummary? }
  ```
  Each data section degrades independently — a failure in one does not prevent others from
  rendering or block the approve action.

  ### 6. Control Center Integration

  **Chosen:** Same inline pattern as PRD/Tech drawers

  **Rejected:**
  - Custom hook extraction — breaks established pattern
  - React Suspense — requires restructuring client component model

  **Rationale:** Adds to control-center-inner.tsx:
  - State: `mergeReviewData` (MergeReviewData | null)
  - Boolean: `showMergeReviewDrawer = lifecycle === 'review' && state === 'action-required'`
  - useEffect: fetch data via getMergeReviewData(featureId) with cancellation token
  - Callbacks: `handleSimpleApprove` calling approveFeature() with toast, rejection via
    handleReject calling rejectFeature() with caution sound + toast
  - Render: MergeReviewDrawer conditionally when showMergeReviewDrawer is true
  - Suppress: extend FeatureDrawer null condition to include showMergeReviewDrawer

  ### 7. CI Status Display

  **Chosen:** Reuse existing CiStatusBadge shared component

  **Rejected:**
  - Plain text — lacks visual immediacy and color-coded instant recognition
  - Build new component — CiStatusBadge already exists with stories

  **Rationale:** CiStatusBadge (ci-status-badge.tsx) is a stateless component accepting
  { status: CiStatus } prop. Renders:
  - Success: green badge + CheckCircle2 + "Passing"
  - Pending: yellow badge + Loader2 (animate-spin) + "Pending"
  - Failure: red badge + XCircle + "Failing"
  Conditionally rendered only when data.pr?.ciStatus is defined (FR-17).

  ### 8. Reject Flow

  **Chosen:** Include reject flow via shared DrawerActionBar at zero cost

  **Rejected:**
  - Approve-only without reject — inconsistent with other drawers, loses revision capability
  - Custom merge-specific reject — unnecessary when shared component handles everything

  **Rationale:** DrawerActionBar provides:
  - Inline revision input (DrawerRevisionInput with customizable placeholder)
  - Reject button → opens RejectFeedbackDialog (AlertDialog with textarea)
  - Both paths call the same onReject(feedback) callback
  - Approve button (full width, customizable label and icon)
  - isProcessing and isRejecting states disable all inputs during operations
  The rejectFeature() server action already supports all approval gates including merge.

  ## Library Analysis

  | Library | Purpose | Decision | Reasoning |
  | ------- | ------- | -------- | --------- |
  | lucide-react (GitMerge) | Merge badge icon on feature node + approve button | Use (already installed) | Available in existing lucide-react dependency, distinct from FileText (PRD) and Wrench (tech) |
  | lucide-react (CheckCircle2, XCircle, Loader2) | CI status icons via CiStatusBadge | Use (already installed) | Standard status icons already used in ci-status-badge.tsx |
  | lucide-react (ExternalLink) | PR link icon indicator | Use (already installed) | Communicates that the link opens in a new tab |
  | lucide-react (FileDiff) | Diff summary section icon | Use (already installed) | Semantically represents file differences |
  | sonner (toast) | Success/error notifications | Use (already installed) | Used by all approval callbacks in control-center-inner.tsx |
  | shadcn/ui Badge | CI status and PR status badges | Use (already installed) | Consistent with existing badge usage throughout the UI |
  | shadcn/ui Card | PR metadata and diff summary sections | Use (already installed) | Consistent card pattern for data display sections |
  | ReviewDrawerShell | Drawer chrome (header, actions, delete) | Use (existing component) | Shared by all review drawers (143 lines), provides header, actions menu, delete confirmation |
  | DrawerActionBar | Approve/reject action bar | Use (existing component) | Shared footer with inline revision input, reject dialog, approve button |
  | CiStatusBadge | CI status display | Use (existing component) | Stateless badge rendering all CiStatus variants with color-coded icons |
  | react-markdown | Markdown rendering in content | Reject | Not needed — merge review content is structured data (numbers, statuses, links), not markdown prose |
  | @tanstack/react-query | Data fetching with caching | Reject | Codebase uses useEffect + server actions pattern, not react-query. Adding would be inconsistent |
  | DrawerRevisionInput | Inline text input for revision | Use (existing component) | Provided automatically by DrawerActionBar, handles trim/empty validation |
  | RejectFeedbackDialog | Modal dialog for detailed rejection | Use (existing component) | Provided automatically by DrawerActionBar, requires non-empty feedback |

  ## Security Considerations

  **Input Validation:** The server action validates featureId is a non-empty, non-whitespace
  string before resolving any DI dependencies, returning `{ error: 'Feature id is required' }`
  on invalid input. This matches the pattern in approve-feature.ts and reject-feature.ts.

  **External Links:** PR URL rendered with `target="_blank" rel="noopener noreferrer"` per
  NFR-6 to prevent reverse tabnapping. The ExternalLink icon visually indicates the link
  opens externally.

  **No New Attack Surface:** The server action only reads existing persisted data (Feature.pr
  from SQLite via IFeatureRepository.findById) and calls an existing service method
  (IGitPrService.getPrDiffSummary). No user input is passed to git commands — the worktreePath
  and baseBranch are derived entirely from server-side data. The featureId from the client is
  used only as a lookup key, not interpolated into commands.

  **DI Token Safety:** Using string tokens ('IFeatureRepository', 'IGitPrService',
  'GetPlanArtifactUseCase') for DI resolution follows the established pattern. These tokens
  resolve to registered implementations controlled by the infrastructure layer. The
  resolve() helper throws if the container is not initialized, preventing null-pointer issues.

  **Rejection Feedback:** User-provided rejection feedback text is passed to rejectFeature()
  server action which processes it safely. The DrawerRevisionInput and RejectFeedbackDialog
  both trim whitespace and prevent empty submissions.

  ## Performance Implications

  **Server Action Latency:** Feature.findById() is a SQLite read (~1ms). GetPlanArtifactUseCase
  reads a YAML file (~5ms). getPrDiffSummary() runs `git diff --stat` and `git log --oneline`
  (~50-200ms depending on repo size). Total well under any reasonable UX threshold.

  **Best-Effort Plan Loading:** Plan phases are loaded in a nested try/catch. If the plan
  doesn't exist or can't be parsed, phases are silently set to undefined. This prevents the
  plan loading from blocking or delaying the drawer.

  **Graceful Degradation:** If getPrDiffSummary() times out or fails, the action returns
  immediately with PR metadata + warning. The diff section is non-blocking and independent.

  **No Polling:** The merge drawer does not poll for CI status updates. The CI status is a
  snapshot from when Feature.pr was persisted by merge.node.ts. Users can refresh by closing
  and reopening the drawer (re-triggers the useEffect data fetch).

  **Worktree Check:** The server action skips the diff call entirely when worktreePath is
  undefined (NFR-7), avoiding unnecessary git operations for features without worktrees.

  **Bundle Size:** Zero new npm dependencies. All icons are tree-shaken from lucide-react.
  The new component adds ~340 lines across 5 files — negligible impact.

  ## Architecture Notes

  **Data Flow:**
  ```
  page.tsx (server) → nodeToLifecyclePhase includes `merge: 'review'`
                     → when agent is at merge node, lifecycle='review'

  control-center-inner.tsx (client)
    → showMergeReviewDrawer = lifecycle === 'review' && state === 'action-required'
    → useEffect calls getMergeReviewData(featureId) server action
    → server action resolves:
        1. Feature.pr → MergeReviewPr (PR metadata)
        2. feature.branch → MergeReviewBranch (source → 'main')
        3. GetPlanArtifactUseCase → MergeReviewPhase[] (best-effort)
        4. IGitPrService.getPrDiffSummary → MergeReviewDiffSummary (graceful fallback)
    → MergeReviewDrawer renders with ReviewDrawerShell + MergeReview content
    → Approve button calls approveFeature(featureId) (existing action)
    → Reject flow calls rejectFeature(featureId, feedback) (existing action)
  ```

  **Type System:**
  ```
  merge-review-config.ts defines:
    MergeReviewDiffSummary { filesChanged, additions, deletions, commitCount }
    MergeReviewPr { url, number, status: PrStatus, commitHash?, ciStatus?: CiStatus }
    MergeReviewPhase { id, name, description? }
    MergeReviewBranch { source, target }
    MergeReviewData { pr?, diffSummary?, phases?, branch?, warning? }
    MergeReviewProps { data, onApprove, onReject?, isProcessing?, isRejecting? }
    MergeReviewDrawerProps extends Omit<MergeReviewProps, 'data'> + shell props
  ```

  **Existing Infrastructure Reused (No Modifications):**
  - `ReviewDrawerShell` — shared drawer wrapper (143 lines) with header, delete, action menu
  - `DrawerActionBar` — shared footer with approve/reject/revision controls
  - `DrawerRevisionInput` — inline text input with send button
  - `RejectFeedbackDialog` — AlertDialog with textarea for rejection feedback
  - `CiStatusBadge` — color-coded CI status display
  - `useFeatureActions` — IDE/shell/folder actions hook (139 lines)
  - `approveFeature()` — server action for all approval gates (38 lines)
  - `rejectFeature()` — server action for all rejection gates
  - `resolve()` — DI resolution helper (36 lines)
  - `IFeatureRepository.findById()` — fetch Feature entity
  - `IGitPrService.getPrDiffSummary()` — returns DiffSummary with 4 fields
  - `GetPlanArtifactUseCase.execute()` — returns plan with phases array
  - `Feature.pr` (PullRequest type) — PR metadata persisted by merge.node.ts
  - `PrStatus`, `CiStatus` enums — domain types for status rendering

  **Files to Create:**
  1. `src/presentation/web/components/common/merge-review/merge-review-config.ts` — 7 interfaces
  2. `src/presentation/web/components/common/merge-review/merge-review.tsx` — content component (~195 lines)
  3. `src/presentation/web/components/common/merge-review/merge-review-drawer.tsx` — shell wrapper (~35 lines)
  4. `src/presentation/web/components/common/merge-review/merge-review.stories.tsx` — 11 story variants
  5. `src/presentation/web/components/common/merge-review/index.ts` — barrel export
  6. `src/presentation/web/app/actions/get-merge-review-data.ts` — server action (~64 lines)

  **Files to Modify:**
  1. `src/presentation/web/components/common/feature-node/feature-node.tsx` — add review cases to getBadgeIcon, getActionRequiredBadgeClasses, getBadgeText (3 additions, ~5 lines each)
  2. `src/presentation/web/components/features/control-center/control-center-inner.tsx` — add showMergeReviewDrawer, state, useEffect, handlers, conditional rendering, FeatureDrawer suppression
  3. `src/presentation/web/app/page.tsx` — add `merge: 'review'` to nodeToLifecyclePhase map (1 line)
  4. `src/presentation/web/components/common/feature-node/feature-node.stories.tsx` — add MergeReviewActionRequired story variant
  5. `src/presentation/web/components/features/control-center/control-center.stories.tsx` — add merge review node in multi-feature story variants

  **Test Files to Create:**
  1. `tests/unit/presentation/web/actions/get-merge-review-data.test.ts` — server action tests covering: input validation (empty/whitespace featureId), feature not found, data mapping from domain types, diff summary failure fallback, plan phase loading failure fallback, no-PR scenario, no-worktree scenario, complete happy path
  2. `tests/unit/presentation/web/components/common/merge-review/merge-review.test.tsx` — component tests covering: rendering all data sections, conditional section omission (no PR, no CI, no diff, no phases, no branch), PR link with correct attributes, CI status badge states, commit hash truncation, diff stats formatting, button click handlers, processing/rejecting disabled states, inline revision input submission
  3. `tests/unit/presentation/web/components/common/merge-review/merge-review-config.test.ts` — type validation tests using expectTypeOf()
  4. `tests/unit/presentation/web/components/common/merge-review/merge-review-barrel.test.ts` — barrel export validation
  5. `tests/unit/presentation/web/components/common/merge-review/merge-review-drawer.test.tsx` — drawer wrapper tests (delete button, loading state)

  **Test Patterns to Follow:**
  - Server action tests: vi.mock('@/lib/server-container') with token-based resolution, beforeEach with vi.clearAllMocks(), test validation → error paths → happy paths
  - Component tests: helper functions for building test data (makeDefaultData(overrides)), fireEvent for interactions, getByText/getByRole for assertions, test conditional rendering by omitting optional props
  - Type tests: expectTypeOf() from vitest for interface compliance
  - Barrel tests: simple validation that exports are functions/defined
