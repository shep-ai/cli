name: merge-review-drawer
summary: >
  The merge review drawer follows the proven 5-file component pattern (config, content, drawer,
  stories, barrel) established by prd-questionnaire and tech-decisions-review. The server action
  reads Feature.pr (already persisted before the merge interrupt) and calls IGitPrService.getPrDiffSummary()
  with graceful fallback. No new dependencies, no domain model changes, and no backend modifications are
  needed — all data, icons, and UI primitives are already available in the codebase.

relatedFeatures: []

technologies:
  - React 19 (Next.js 16+ App Router)
  - shadcn/ui (Radix + Tailwind CSS v4)
  - React Flow (@xyflow/react)
  - Storybook 8
  - Vaul (drawer primitive via ReviewDrawerShell)
  - Lucide React (GitMerge, CheckCircle2, XCircle, Loader2, ExternalLink icons)
  - sonner (toast notifications)
  - tsyringe (DI container for server actions via resolve())

relatedLinks: []

decisions:
  - title: 'Server Action Architecture for Merge Review Data'
    chosen: >
      Direct server action that resolves IFeatureRepository and IGitPrService via DI,
      reads Feature.pr for PR metadata, and calls getPrDiffSummary() with graceful fallback
    rejected:
      - >
        Create a dedicated use case class (e.g., GetMergeReviewDataUseCase): Rejected because
        the existing server action pattern (get-feature-artifact.ts, get-research-artifact.ts)
        resolves repositories and services directly via resolve() without a dedicated use case.
        The merge review data retrieval is a simple read operation that doesn't warrant its own
        use case class — it would add unnecessary indirection for a server action that reads
        one entity field and calls one service method.
      - >
        Return data from the LangGraph checkpoint interrupt payload: Rejected because it
        couples the UI layer to LangGraph internals, checkpoint format may change between
        versions, and Feature.pr is already persisted before the interrupt (merge.node.ts:144-158).
        This would add complexity without benefit since the same data is available from the
        Feature entity.
    rationale: >
      The server action pattern is established in the codebase (approve-feature.ts,
      get-feature-artifact.ts, get-research-artifact.ts). Each action uses 'use server',
      validates input, resolves dependencies via resolve<T>('Token'), and returns a typed
      result with optional error. The merge review action follows this exact pattern:
      resolve IFeatureRepository to read Feature.pr, then resolve IGitPrService to get
      diff summary. The try/catch with graceful fallback for diff ensures the action
      returns PR metadata even when the worktree is unavailable.

  - title: 'Component Directory Structure'
    chosen: >
      5-file pattern at components/common/merge-review/ matching prd-questionnaire and
      tech-decisions-review: merge-review-config.ts, merge-review.tsx,
      merge-review-drawer.tsx, merge-review.stories.tsx, index.ts
    rejected:
      - >
        Single-file component: Rejected because it violates the established pattern and
        mixes type definitions, content rendering, shell integration, and stories into one
        file. The codebase convention separates config (types), content, drawer wrapper,
        stories, and barrel export into dedicated files for single responsibility.
      - >
        Place in features/ tier (Tier 3) instead of common/ (Tier 1): Rejected because
        prd-questionnaire and tech-decisions-review are both in components/common/ as
        Tier 1 shared domain components. The merge review drawer is the same kind of
        component — a domain-specific review drawer used by the control center. Placing
        it in features/ would break the parallel structure.
    rationale: >
      The 5-file pattern is used by both existing review drawers: prd-questionnaire/
      (prd-questionnaire-config.ts, prd-questionnaire.tsx, prd-questionnaire-drawer.tsx,
      prd-questionnaire.stories.tsx, index.ts) and tech-decisions-review/ (same structure).
      Following this pattern ensures consistency, makes the component discoverable, and
      allows the content component to be used independently from the drawer shell (useful
      for Storybook stories and potential future reuse).

  - title: 'Drawer Content Design — Read-Only vs Interactive'
    chosen: >
      Read-only display showing PR metadata, diff summary, CI status, and an approve
      button with no chat input or refinement flow
    rejected:
      - >
        Include chat input for feedback (matching PRD/Tech drawers): Rejected because merge
        review is a binary approval decision — there is nothing to "refine". The merge node's
        LangGraph interrupt flow does not support feedback-based revision. Adding a
        non-functional chat input would mislead users into thinking they can request changes.
      - >
        Full code review interface with file-level diffs: Rejected because this would require
        extending IGitPrService with per-file diff data, dramatically increase component
        complexity, and duplicate GitHub's code review UI. The spec explicitly chose aggregate
        statistics only. Users who want detailed review can click the PR link.
    rationale: >
      The merge approval gate is fundamentally different from PRD (select options from
      questions) and tech decisions (review and refine plan). Merge review is a go/no-go
      decision: the code has been implemented, the PR has been created, and the user just
      needs to approve the merge. The PR URL provides an escape hatch to GitHub for detailed
      code review. This keeps the component simple (~120 lines for content) and focused.

  - title: 'Feature Node Badge Color Scheme for Review Phase'
    chosen: >
      Emerald (green) color scheme with GitMerge icon: text-emerald-700 badge text,
      bg-emerald-50 badge background, consistent with the done state's emerald palette
    rejected:
      - >
        Purple/violet with GitPullRequest icon: Rejected because purple doesn't carry
        semantic meaning for merging, and GitPullRequest represents the PR object rather
        than the merge action. This would be less intuitive than green.
      - >
        Reuse the default amber with a different icon only: Rejected because it would make
        the merge review state indistinguishable from PRD review (both amber). The spec
        requires three visually distinct review types: amber (requirements), indigo
        (implementation), green (merge).
    rationale: >
      The emerald color creates a natural progression: amber (requirements review) →
      indigo (tech planning review) → green (merge review). Green semantically means
      "ready to proceed / ready to merge", matching GitHub's green merge button convention.
      The GitMerge icon from Lucide React directly communicates the action. Note that
      emerald is already used for the "done" state in feature-node-state-config.ts (line
      113-120), but this is for the action-required state badge override, so there's no
      collision — the action-required border stays amber by default while only the badge
      gets emerald.

  - title: 'Diff Summary Retrieval and Error Handling'
    chosen: >
      Graceful degradation: server action wraps getPrDiffSummary() in a nested try/catch,
      returns PR metadata with diffSummary omitted on failure, drawer renders a subtle
      warning message instead of diff section
    rejected:
      - >
        Block the drawer with a full error state: Rejected because the diff summary is
        supplementary display information — blocking the approve action because of a
        display issue would frustrate users. Feature.pr is always available since it's
        persisted before the interrupt.
      - >
        Cache diff summary in Feature entity during merge node: Rejected because it would
        require domain model changes (adding a diffSummary field to Feature or PullRequest),
        TypeSpec modifications, and database migration — all of which violate the NFR-7
        (no backend changes) constraint.
    rationale: >
      The server action needs two data sources: Feature.pr (always available, persisted
      to SQLite) and diff summary (requires live git worktree). The Feature.pr data is
      populated in merge.node.ts lines 144-158 before the interrupt, so it's guaranteed
      to be in the database during the Review phase. The diff summary requires the worktree
      to exist and git to be available, which should be true during Review but could fail
      in edge cases (manual worktree deletion, disk issues). Nesting a try/catch for just
      the diff call ensures the action returns successfully with PR metadata regardless.
      The drawer component checks for diffSummary presence and renders either the stats
      section or a subtle warning.

  - title: 'Control Center Integration Pattern'
    chosen: >
      Follow the exact same pattern as PRD and Tech Decision drawers: boolean flag
      (showMergeReviewDrawer), state for data (mergeReviewData), useEffect with
      cancellation for data fetching, conditional rendering
    rejected:
      - >
        Use a custom hook to encapsulate all merge drawer logic: Rejected for the same
        reason PRD and Tech drawers don't use one — the control center already manages
        all drawer state inline. Extracting to a hook would break the established pattern
        and add indirection that doesn't exist for the other drawers.
      - >
        Use React Suspense with a server component for data loading: Rejected because
        the control center is a client component ('use client') and the drawer data is
        loaded on-demand when a node is selected. Suspense would require restructuring
        the control center's client-side interaction model, which is out of scope.
    rationale: >
      The control-center-inner.tsx (262 lines) follows a clear pattern for each drawer:
      (1) state declarations for data and loading, (2) boolean visibility condition
      derived from selectedNode lifecycle + state, (3) useEffect with cancellation pattern
      for data fetching keyed on featureId, (4) approval callback using approveFeature(),
      (5) conditional rendering with data null-check. The merge drawer adds one more
      instance of this pattern. The FeatureDrawer suppression also extends naturally:
      the existing `showPrdDrawer || showTechDecisionsDrawer ? null : selectedNode`
      becomes `showPrdDrawer || showTechDecisionsDrawer || showMergeReviewDrawer ? null
      : selectedNode`.

  - title: 'CI Status Visual Representation'
    chosen: >
      Color-coded badge using shadcn/ui Badge component with Lucide icons: green/CheckCircle2
      for Success, yellow/Loader2 for Pending, red/XCircle for Failure, with text labels
    rejected:
      - >
        Plain text status line without color: Rejected because it lacks visual immediacy.
        Color-coded indicators follow universal CI/CD conventions (green=pass, red=fail,
        yellow=pending) and match GitHub's own status indicators. Users can scan CI status
        at a glance with color.
      - >
        Animated progress indicator for pending: Rejected in favor of simpler Loader2 icon
        with animate-spin class. A full progress bar would imply deterministic progress
        when CI status is just a three-state enum. The spin animation is sufficient to
        convey "in progress".
    rationale: >
      The shadcn/ui Badge component is already used throughout the codebase for status
      indicators. Using variant-like className overrides (bg-green-50 text-green-700,
      bg-yellow-50 text-yellow-700, bg-red-50 text-red-700) follows the same pattern as
      the feature node badge classes. Pairing each color with both an icon AND text label
      satisfies NFR-3 accessibility requirement (color-coded badges must include text labels).

openQuestions:
  - question: >
      Should the server action resolve Feature.worktreePath for the getPrDiffSummary call,
      or should it use Feature.repositoryPath instead?
    resolved: true
    options:
      - option: 'Use Feature.worktreePath'
        description: >
          Feature.worktreePath is the actual git worktree path where the feature branch
          work happens. This is what merge.node.ts uses (state.worktreePath at line 54)
          when calling getPrDiffSummary. During the Review phase, the worktree should still
          exist. However, worktreePath is optional on the Feature type and may be undefined.
        selected: true
      - option: 'Use Feature.repositoryPath'
        description: >
          Feature.repositoryPath is the base repository path, always present. However, diff
          comparisons happen in the worktree (a separate git checkout), not the base repo.
          Using repositoryPath would produce incorrect diff results if the feature uses a
          worktree, which is the standard flow.
        selected: false
      - option: 'Use Feature.repositoryPath with branch checkout'
        description: >
          Use repositoryPath but first check out the feature branch. This is dangerous and
          modifies working state in the base repository. It could disrupt other features or
          ongoing work. Not a viable approach for a read-only display operation.
        selected: false
    selectionRationale: >
      Feature.worktreePath is the correct path because getPrDiffSummary runs git diff
      baseBranch...HEAD, which must execute in the worktree where HEAD points to the
      feature branch. merge.node.ts uses state.worktreePath (line 54) for exactly this
      reason. The worktree is guaranteed to exist during the Review lifecycle phase because
      it's created during feature initialization and only cleaned up after the feature
      reaches Maintain. If worktreePath is undefined, the server action falls back to
      omitting the diff summary (graceful degradation) since it can't compute diffs
      without knowing the worktree location.

  - question: >
      How should the baseBranch parameter for getPrDiffSummary be determined in the
      server action?
    resolved: true
    options:
      - option: 'Hardcode "main" as the base branch'
        description: >
          merge.node.ts hardcodes baseBranch = "main" (line 59). Matching this ensures
          consistency between what the agent computed and what the server action displays.
          Simple and predictable. Breaks for repos using "master" or custom default branches.
        selected: true
      - option: 'Read the default branch from git configuration'
        description: >
          Use git rev-parse or git remote to detect the actual default branch. More robust
          for repos using "master" or custom branch names. However, this adds complexity and
          another potential failure point, and the merge node itself hardcodes "main".
        selected: false
      - option: 'Store the base branch on the Feature entity'
        description: >
          Add a baseBranch field to Feature and persist it during agent execution. Most
          robust but requires domain model changes (TypeSpec, migration), violating NFR-7.
        selected: false
    selectionRationale: >
      Hardcoding "main" matches the merge node implementation exactly (merge.node.ts:59
      `const baseBranch = 'main'`). Since the diff summary is computed between the same
      branches the agent used, the results will be consistent. If the repo uses "master"
      or another default branch, the getPrDiffSummary call will fail gracefully (the
      try/catch returns PR metadata without diff stats). This is acceptable for now; a
      future enhancement can detect the default branch dynamically.

  - question: >
      Should the merge review data type be defined in the server action file or in the
      component config file?
    resolved: true
    options:
      - option: 'Define MergeReviewData in merge-review-config.ts (component config)'
        description: >
          Define the data interface alongside the component props in the config file.
          The server action imports and returns this type. This follows the tech-decisions
          pattern where TechDecisionsReviewData is defined in tech-decisions-review-config.ts
          and re-exported from get-research-artifact.ts.
        selected: true
      - option: 'Define MergeReviewData in the server action file'
        description: >
          Define and export the data interface from get-merge-review-data.ts. Components
          import it from the action file. This is what get-research-artifact.ts does —
          TechDecisionsReviewData is actually defined there and exported.
        selected: false
      - option: 'Define in a shared types file'
        description: >
          Create a separate shared types file that both the server action and component
          import from. Adds a file that doesn't match the established pattern.
        selected: false
    selectionRationale: >
      Looking more closely at the codebase, TechDecisionsReviewData is defined in the
      server action file (get-research-artifact.ts:7-12) and also re-exported from
      tech-decisions-review-config.ts. However, for the merge review drawer, the cleaner
      approach is to define MergeReviewData in merge-review-config.ts alongside the
      component props. The server action can import this type. This keeps the data shape
      definition co-located with the component that consumes it, making it easier to
      understand the component's data contract at a glance. The server action file stays
      focused on the data fetching logic.

content: |
  ## Technology Decisions

  ### 1. Server Action Architecture

  **Chosen:** Direct server action resolving IFeatureRepository and IGitPrService via DI

  **Rejected:**
  - Dedicated use case class — unnecessary indirection for a simple read operation
  - LangGraph checkpoint read — couples UI to agent internals, Feature.pr is already persisted

  **Rationale:** Follows the established pattern in get-feature-artifact.ts (56 lines) and
  get-research-artifact.ts (43 lines). The action validates featureId, resolves IFeatureRepository
  via `resolve<IFeatureRepository>('IFeatureRepository')`, reads Feature.pr, then resolves
  IGitPrService via `resolve<IGitPrService>('IGitPrService')` to call getPrDiffSummary() with
  a nested try/catch for graceful degradation.

  ### 2. Component Structure

  **Chosen:** 5-file pattern at `components/common/merge-review/`

  **Rejected:**
  - Single file — violates codebase conventions
  - Features tier placement — breaks parallel with prd-questionnaire and tech-decisions-review

  **Rationale:** Exact mirror of the existing drawer component pattern. Files:
  - `merge-review-config.ts` — MergeReviewData, MergeReviewProps, MergeReviewDrawerProps interfaces
  - `merge-review.tsx` — Content component with PR metadata, diff stats, CI badge, approve button
  - `merge-review-drawer.tsx` — Thin wrapper passing shell props to ReviewDrawerShell
  - `merge-review.stories.tsx` — Stories for all variants (default, CI states, degraded, processing)
  - `index.ts` — Barrel export

  ### 3. Content Design

  **Chosen:** Read-only PR display with approve action, no chat input

  **Rejected:**
  - Chat input for refinement — merge node doesn't support feedback revision
  - File-level diff details — requires service extension, GitHub link covers detailed review

  **Rationale:** Merge review is a binary decision unlike PRD (option selection) or tech decisions
  (plan refinement). The component renders: PR number as external link, PR status indicator,
  CI status badge with icon, aggregate diff stats (files changed, +additions, -deletions,
  commits), commit hash (truncated), and an approve button.

  ### 4. Badge Visualization

  **Chosen:** Emerald (green) + GitMerge icon for review + action-required

  **Rejected:**
  - Purple/GitPullRequest — no semantic meaning for merging
  - Default amber — indistinguishable from PRD review

  **Rationale:** Three additions to feature-node.tsx:
  - `getBadgeIcon()`: add `if (data.lifecycle === 'review') return GitMerge;`
  - `getActionRequiredBadgeClasses()`: add review case returning `{ badgeClass: 'text-emerald-700', badgeBgClass: 'bg-emerald-50' }`
  - `getBadgeText()`: add `if (data.lifecycle === 'review') return 'Review Merge Request';`

  ### 5. Error Handling Strategy

  **Chosen:** Graceful degradation with nested try/catch in server action

  **Rejected:**
  - Block drawer on error — frustrates users, approval doesn't need diff data
  - Cache diff on Feature — requires domain model changes (NFR-7 violation)

  **Rationale:** The server action structure:
  ```
  try {
    feature = featureRepo.findById(featureId)  // always works if feature exists
    prData = feature.pr                        // always available in Review phase
    try {
      diffSummary = gitPrService.getPrDiffSummary(worktreePath, 'main')
    } catch {
      diffSummary = undefined  // graceful fallback
    }
    return { pr: prData, diffSummary }
  } catch {
    return { error: message }
  }
  ```

  ### 6. Control Center Integration

  **Chosen:** Same inline pattern as PRD/Tech drawers

  **Rejected:**
  - Custom hook extraction — breaks established pattern
  - React Suspense — requires restructuring client component model

  **Rationale:** Adds to control-center-inner.tsx:
  - State: `mergeReviewData`, `isLoadingMergeReview`
  - Boolean: `showMergeReviewDrawer = lifecycle === 'review' && state === 'action-required'`
  - useEffect: fetch data via getMergeReviewData(featureId) with cancellation
  - Callback: `handleMergeApprove` calling approveFeature() with toast
  - Render: `MergeReviewDrawer` conditionally when data is loaded
  - Suppress: extend FeatureDrawer null condition

  ### 7. CI Status Display

  **Chosen:** Color-coded shadcn/ui Badge with Lucide icon and text label

  **Rejected:**
  - Plain text — lacks visual immediacy
  - Animated progress bar for pending — implies deterministic progress

  **Rationale:** Mapping:
  - Success: `bg-green-50 text-green-700` + CheckCircle2 + "Passing"
  - Pending: `bg-yellow-50 text-yellow-700` + Loader2 (animate-spin) + "Pending"
  - Failure: `bg-red-50 text-red-700` + XCircle + "Failing"
  Includes text labels for accessibility (NFR-3).

  ## Library Analysis

  | Library | Purpose | Decision | Reasoning |
  | ------- | ------- | -------- | --------- |
  | lucide-react (GitMerge) | Merge badge icon on feature node | Use (already installed) | Available in existing lucide-react dependency, distinct from FileText and Wrench |
  | lucide-react (CheckCircle2, XCircle, Loader2) | CI status icons | Use (already installed) | Standard status icons already used elsewhere in the codebase |
  | lucide-react (ExternalLink) | PR link icon indicator | Use (already installed) | Communicates that the link opens in a new tab |
  | sonner (toast) | Success/error notifications | Use (already installed) | Used by all approval callbacks in control-center-inner.tsx |
  | shadcn/ui Badge | CI status and PR status badges | Use (already installed) | Consistent with existing badge usage throughout the UI |
  | ReviewDrawerShell | Drawer chrome (header, actions, delete) | Use (existing component) | Shared by all review drawers, provides header, actions menu, delete confirmation |
  | react-markdown | Markdown rendering in content | Reject | Not needed — merge review content is structured data (numbers, statuses, links), not markdown prose |
  | @tanstack/react-query | Data fetching with caching | Reject | Codebase uses useEffect + server actions pattern, not react-query. Adding would be inconsistent |

  ## Security Considerations

  **Input Validation:** The server action validates featureId is a non-empty string before
  resolving any dependencies, matching the pattern in approve-feature.ts (line 10).

  **External Links:** PR URL rendered with `target="_blank" rel="noopener noreferrer"` per
  NFR-3 to prevent reverse tabnapping.

  **No New Attack Surface:** The server action only reads existing persisted data (Feature.pr)
  and calls an existing service method (getPrDiffSummary). No user input is passed to git
  commands — the worktreePath and baseBranch are derived from server-side data.

  **DI Token Safety:** Using string tokens ('IFeatureRepository', 'IGitPrService') for DI
  resolution follows the established pattern. These tokens resolve to registered implementations
  controlled by the infrastructure layer.

  ## Performance Implications

  **Server Action Latency:** Feature.findById() is a SQLite read (~1ms). getPrDiffSummary()
  runs `git diff --stat` and `git log --oneline` (~50-200ms depending on repo size). Total
  well under the 2-second NFR-2 requirement.

  **Graceful Degradation:** If getPrDiffSummary() times out or fails, the action returns
  immediately with PR metadata. The diff section is non-blocking.

  **No Polling:** Unlike some review UIs, the merge drawer does not poll for CI status updates.
  The CI status is a snapshot from when Feature.pr was persisted. Users can refresh by
  closing and reopening the drawer (re-triggers the useEffect).

  **Bundle Size:** Zero new npm dependencies (NFR-8). All icons are tree-shaken from
  lucide-react. The new component adds ~340 lines across 5 files — negligible impact.

  ## Architecture Notes

  **Data Flow:**
  ```
  page.tsx (server) → adds `merge: 'review'` to nodeToLifecyclePhase
                     → lifecycle='review' when agent is at merge node
  control-center-inner.tsx (client)
    → showMergeReviewDrawer = lifecycle === 'review' && state === 'action-required'
    → useEffect calls getMergeReviewData(featureId) server action
    → server action resolves Feature.pr + getPrDiffSummary()
    → MergeReviewDrawer renders with ReviewDrawerShell + MergeReview content
    → Approve button calls approveFeature(featureId) (existing action)
  ```

  **Existing Infrastructure Reused (No Modifications):**
  - `ReviewDrawerShell` — shared drawer wrapper (143 lines)
  - `useFeatureActions` — IDE/shell/folder actions hook (139 lines)
  - `approveFeature()` — server action for all approval gates (38 lines)
  - `resolve()` — DI resolution helper (36 lines)
  - `IFeatureRepository.findById()` — fetch Feature entity
  - `IGitPrService.getPrDiffSummary()` — diff statistics
  - `Feature.pr` (PullRequest type) — PR metadata persisted by merge node
  - `PrStatus`, `CiStatus` enums — domain types for status rendering

  **Files to Create:**
  1. `src/presentation/web/components/common/merge-review/merge-review-config.ts` — interfaces
  2. `src/presentation/web/components/common/merge-review/merge-review.tsx` — content component
  3. `src/presentation/web/components/common/merge-review/merge-review-drawer.tsx` — shell wrapper
  4. `src/presentation/web/components/common/merge-review/merge-review.stories.tsx` — stories
  5. `src/presentation/web/components/common/merge-review/index.ts` — barrel export
  6. `src/presentation/web/app/actions/get-merge-review-data.ts` — server action

  **Files to Modify:**
  1. `src/presentation/web/components/common/feature-node/feature-node.tsx` — add review cases to getBadgeIcon, getActionRequiredBadgeClasses, getBadgeText (3 small additions, ~5-10 lines each)
  2. `src/presentation/web/components/features/control-center/control-center-inner.tsx` — add showMergeReviewDrawer, state, useEffect, handler, conditional rendering
  3. `src/presentation/web/app/page.tsx` — add `merge: 'review'` to nodeToLifecyclePhase map
  4. `src/presentation/web/components/common/feature-node/feature-node.stories.tsx` — add review + action-required story variant
  5. `src/presentation/web/components/features/control-center/control-center.stories.tsx` — add merge drawer story variant
